<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>NERV - SN</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-cn</language>
        <pubDate>Thu, 21 Sep 2023 23:00:00 +0800</pubDate>
        <lastBuildDate>Thu, 21 Sep 2023 23:00:00 +0800</lastBuildDate>
        <category>OIer 日记</category>
        <category>图论</category>
        <item>
            <guid isPermalink="true">http://example.com/2023/09/21/%E4%B8%80%E5%8F%AA%E5%9C%A8%E5%BD%B9%20OIer%20%E7%9A%84%E8%87%AA%E8%BF%B0/</guid>
            <title>一只在役 OIer 的自述</title>
            <link>http://example.com/2023/09/21/%E4%B8%80%E5%8F%AA%E5%9C%A8%E5%BD%B9%20OIer%20%E7%9A%84%E8%87%AA%E8%BF%B0/</link>
            <category>OIer 日记</category>
            <pubDate>Thu, 21 Sep 2023 23:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1&gt;一只在役 $OIer$ 的自述&lt;/h1&gt;
&lt;p&gt;其实，我早就想写这篇文章了，直到今天我才把它写出来，我想应该不是懈怠使然。这文章本是写给自己的，但我还是想要发出来，我想让应该看见它的人看见它，这不仅仅是一个 $OIer$ 的自白，我相信也是大部分高中生，尤其是竞赛生的自白。所以这篇文章里将以我的感受为主，说我想说的话，当然我相信也是大部分高中生想说的话。&lt;/p&gt;
&lt;p&gt;$OI$ 是一条不归路，只要踏上了这条船，就再也没有回头的机会了。无论我们是否比别人学得晚，哪怕被各种神犇学弟虐得无地自容，我们依旧坚持着 $OI$，因为热忱，因为喜爱。切掉一道题的喜悦，$AK$ 比赛那就更不用说了，甚至调不出来代码时的烦恼，一遍又一遍地静态查错，这些都是令人回味无穷的过程，$OI$ 就是这样地有魅力，有这可以征服人内心的力量。&lt;/p&gt;
&lt;p&gt;$OIer$ 们在学生之间大多是被崇拜的，但是家长们似乎并不喜欢这门竞赛。大抵是因为这门竞赛是高考外的科目，选择了它，似乎便是不务正业了，家长们不希望孩子走弯路，希望他们可以一帆风顺地度过人生。家长们的想法没错，哪个家长不希望自己的孩子能够通过正常的文化课学习裸分考上清华北大？我相信从初衷来讲，世界上没有几个家长是不好的。但是为了照顾热血青年们的任性与梦想，他们还是选择了支持，尽管心理不支持，嘴上也在支持，这是显而易见且无法隐藏的。于是，家长们克服千辛万苦说服了自己的内心，他们告诉我们：“既然选择了这条路，就要坚定地走下去，要破釜沉舟。”如果他们还把高中生尤其是竞赛生当作懵懂的学生的话，那么已经错了一半了。每个学生，尤其是竞赛生内心都有一杆秤，我们会衡量我们做出的所有选择，家长们对我们的殷勤付出，我们当然历历在目，我们都不想辜负家长的期望，更不想和家长吵架。我相信真正细心的家长是可以发现的。但是我们依旧顶着天大的压力选择了竞赛这条路，我们面对的压力其实不比一个成年人少：我们赌上了自己的高中生活以及人生，为了自己的梦想想要拼命一把；我们赌上了和家长的关系，甚至有些 $OIer$ 做好了闹翻的准备；选择了竞赛就意味着，与你并肩作战的战友在考试时全部都是你的敌人，要横着心去扼杀他们的前途，这让竞赛生心里其实很难受，但是没有办法，现实就是如此残酷；他们内心很恐惧，如果竞赛失败，迎接他们的将是炼狱。于是几乎模拟了一遍自己该怎么活后，竞赛生还是毅然决然地踏上了这条不归路，于是家长们开始想办法，给我们找到了最好的资源。&lt;/p&gt;
&lt;p&gt;原本就天大的压力其实对竞赛生来说不算什么，但是外出培训，尤其是一个人外出培训，那种痛苦与绝望是一个人很难接受的。请你想象，一个月的时间里你将不会和同龄人有任何交流，唯一的交流是冷冰冰的题目讲解，不熟悉的环境令你感到恐惧和害怕，那种与世隔绝坠入深渊的孤独感，是普通高中生，也是家长们无法想象的。于是，你受不了了，你的内心世界在逐渐崩塌，你想要调整好心情，想要回忆快乐的事，但迎接你的是第二天模拟赛的摧残，是眼前可怕的 $Wrong ~Answer$，是其它队员看你不懈的目光，是学校里其他的人对外来杂种偷来的鄙夷的眼神。试问一下家长们，你们真的能理解这种心情么？但是家长们没有必要了解，因为他们已经为你求爷爷告奶奶找到了最顶尖的资源，你理所应当认真地珍惜这些机会，然后努力拼搏，努力奋斗！然后一路逆袭，进入省队，杀出金牌，创造神话！怎么样，听着是不是很带感，我也觉得很带感。但是，请你们不要忘记了，竞赛生也是人，他们虽然比普通的学生心智和思想上成熟许多，但是他们的内心都是很脆弱的，远没有装出来的那么坚强，他们为了不让你们失望，说出来的是最坚定的志向，但是他们的内心，真的很害怕，不仅仅害怕进不了省队，还害怕孤独，害怕被嘴。他们抱怨的时候，爸爸妈妈往往会这样说：“这是你自己选的路，你要是想弄我们可以选择回去学文化课，不要一天到晚说些负能量的话，让自己开心起来。”啊，说话真是这个世界上最轻松的事了。有没有人曾想过，他们需要的只是一句安慰，只是一句鼓励，仅此而已。看到这里，你们还觉得自己理解他们吗？但我还是要感谢家长给了我追逐梦想的机会，他们是最爱你的人。&lt;/p&gt;
&lt;p&gt;上了高中以后，真正懂得我内心，给予我抚慰的是我所谓的“姑姑”，其实读者早就知道我们的关系了，读者只是出于疼爱没有拆穿我而已，这些是我知道，也是我能看出来的，无所谓啊，这不重要。交心的事也只有这层关系作为纽带才能够进行，同龄人的心只有最爱你的同龄人才能了解，互为对方的救赎是我们高中的常态，我希望以后也是。我要感谢我的姑姑，她是除了家长以外最爱我，也是最懂我的人，可以说是我活下去，努力下去和憧憬未来的动力。在 $OIer$ 中，最理解我也是对我帮助最大的非小翼龙莫属了，$OIer$ 最懂 $OIer$，我们之间的烦恼是互通的，所以情感自然也是互通的，毕竟同是天涯沦落人，倘若能和小翼龙一起拿到金牌，该是多么令人欣喜的一件事。谢谢小翼龙一直以来都无私地给我讲题，跟我分享烦恼。&lt;/p&gt;
&lt;p&gt;所以啊，这篇文章是我作为一个竞赛生，写给我的家长，写给全体高中生的家长，写给全世界最爱我，最爱你们的人，写给全中国的学生和家长的，也许我说的有点过于广泛，有点不自量力。家长们，请不要指责你的孩子不懂事，你们的一言一行他们都会记在心里；在你的孩子伤心难过时，请多鼓励鼓励他们，他们需要的是你们的支持；请你们不要低估高中生之间的各种感情，真正理解同龄人的只能是同龄人，他们心灵的港湾与艳阳也一定是同龄人；请你们不要直接否定孩子们做出的决定，他们能做出莽撞的决定，是因为他们真的很难受；请记住，对他们的付出以及将他们养大不是你控制他们人生的借口；也请你记住，有些弯路是需要自己走的，你帮他们过去的弯，会成为他们人生的绊脚石；请你们记住，孩子们也有自己的烦恼，虽然与你们的不同，在你们看起来是自己曾经有过的幼稚的烦恼，但请你不要忘记自己当时是怎么度过的；请你们记住，你们并不是一代人，请不要试图用你的理论去理解他的烦恼；最后请你们记住，他们已经是成年人了，不再是温室里的雏鹰了，是芜湖起飞的时候了。&lt;/p&gt;
&lt;p&gt;时间紧迫没有差错，有错别字请忽略，拜谢 $orz$。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/09/07/%E6%9C%80%E7%9F%AD%E8%B7%AF/</guid>
            <title>最短路径基础总结</title>
            <link>http://example.com/2023/09/07/%E6%9C%80%E7%9F%AD%E8%B7%AF/</link>
            <category>图论</category>
            <pubDate>Thu, 07 Sep 2023 20:34:44 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;operatorname-Floyd-（全源最短路）&#34;&gt;$\operatorname{Floyd}$（全源最短路）&lt;/h2&gt;
&lt;p&gt;我们定义一个数组 $f_{k,x,y}$ 表示只经过节点 $1$ ~ $k$ 的情况下，$x$ 到 $y$ 的最短路长度，那么显然的，当一个图中节点个数为 $n$ 时，$f_{n,x,y}$ 就是我们所要求的答案。实现 $\operatorname{Floyd}$ 算法需要我们从 $k=0$ 时的情况逐渐递推到 $k=n$。$k=0$ 时，$x$ 和 $y$​ 不相等的情况下不可能通过任何情况联通，而一个点到自己的距离显然为 $0$，所以我们认为：&lt;/p&gt;
$$\displaylines{\left\{\begin{matrix}
f_{0,x,y}(x \ne y)=\infty
 \\
f_{0,x,y}(x=y)=0
\end{matrix}\right.
}$$&lt;p&gt;于是我们就得到了递推式的第一项，我们考虑动态规划。对于每一个点，我都有两种选择：第一种是经过这个点，即 $f_{k-1,x,y}$；而第二种是不经过这个点，即 $f_{k-1,x,k}+f_{k-1,k,y}$ 。我们寻找最短路时只要判断经过当前的点的代价和不经过当前点的代价哪个更小就可以了，所以 $k,x,y$ 都从 $1$ 开始枚举一遍就可以得出答案，下面是具体实现（切勿忘记初始化）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (int k = 1; k &amp;lt;= n; ++k) &amp;#123;
	for (int x = 1; x &amp;lt;= n; ++x) &amp;#123;
		for (int y = 1; y &amp;lt;= n; ++y) &amp;#123;
            f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k] +f[k-1][k][y]);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 $f_{k-1,x,y}$ 表示的就是当 $k-1$ 这一维中所有元素的最小值，那么该维其它值对于我们来说没有贡献，我们就可以考虑把这一维去掉，将三维数组压缩成二维数组，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (int k = 1; k &amp;lt;= n; ++k) &amp;#123;
	for (int x = 1; x &amp;lt;= n; ++x) &amp;#123;
		for (int y = 1; y &amp;lt;= n; ++y) &amp;#123;
            f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终我们算法的时间复杂度为 $O(n^3)$，空间复杂度为 $O(n^2)$，常数很小。但是我们发现，当我们要求单源最短路时，这种方法求出的其它最短路对于我们来说就是一种浪费，但这又是无法避免的，所以我们考虑，对于单源最短路有没有其它的做法。&lt;/p&gt;
&lt;h2 id=&#34;operatorname-Dijkstra-（非负权图单源最短路）&#34;&gt;$\operatorname{Dijkstra}$（非负权图单源最短路）&lt;/h2&gt;
&lt;p&gt;$\operatorname{Dijkstra}$ 算法将一张图内所有结点分为了两个集合，其中一个集合内放已经确定了起点到其的最短路的点，另一个放还没有确定最短路的点，我们分别记为 $S$ 和 $T$ 。为了记录源点到每个点的最短路，我们要用一个数组 $dis$。刚开始的时候所有的点都属于集合 $T$，接下来，每一次操作都从 $T$ 中取出最短路长度最小的点放入 $S$ 集合中，对其进行&lt;strong&gt;松弛操作&lt;/strong&gt;，什么是松弛呢？我们进行如下定义：对于一条边$(u,v)$，设其边权为 $w$ ，则 $dis_v = min(dis(v),dis(u) + w)$。这个操作就叫做松弛，而它的含义是显而易见的，就是当我们走到一个点的时候考虑要不要去走某一条边。&lt;/p&gt;
&lt;p&gt;那么如何维护这两个集合呢？我们考虑用一个 $used$ 数组来记录当前点以前是否更新过，也就是说记录其是否在集合 $S$ 中。然后每次遍历找到 $T$ 中最小的那个点，对它所有出边进行松弛即可，下面是代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef long long LL;
const LL N = 2e5 + 7, INF = 1e18;
struct edge &amp;#123; LL v, w; &amp;#125;;
vector&amp;lt;edge&amp;gt; e[N];
LL dis[N];
bool used[N];
LL n, m, b;

inline void Dijkstra(int s) &amp;#123;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123; dis[i] = INF; &amp;#125;
    // 所有点最短路径初始时要置无穷大
    dis[s] = 0;// 起点到自己的最短路为0
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        LL u = 0, now = LONG_LONG_MAX;
        // now用来记录当前T中找到的最短路最小的点
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            if (!used[j] &amp;amp;&amp;amp; dis[j] &amp;lt; now) &amp;#123;
            // 如果在集合T中且其最短路长比之前找到的还小就更新
                u = j; 
                now = dis[j];
            &amp;#125;
        &amp;#125;
        used[u] = true;// 放入S集合
        for (auto it : e[u]) &amp;#123;// 对出边进行松弛
            auto v = it.v, w = it.w;
            if (dis[v] &amp;gt; dis[u] + w) &amp;#123;
                dis[v] = dis[u] + w;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样做的时间复杂度是 $O(n^2)$，比刚刚有了很大的提升，但当我们打开一道题，发现数据可能随随便便就超过了 $10^5$，$O(n^2)$ 显然是过不去的，所以我们考虑对其用优先队列进行堆优化。我们发现，在暴力做法中，我们每次都要遍历 $1$ ~ $n$ 去寻找集合 $T$ 中最短路最小的那个点，那么我们就想能不能每次直接从 $T$ 中拿出最短路最小的点。我们考虑每次从堆顶取出一个点，然后判断这个点是否在集合 $T$ 中，如果不在那么扔掉再取下一个，否则就进行松弛，成功松弛后 $u$ 就光荣完成了它的使命，扔进 $S$ 集合中，而 $v$ 就入队排序等待后面把它取出。这样重复直到队列为空，我们也就更新完了所有的点，下面是具体实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef long long LL;
typedef pair&amp;lt;LL, LL&amp;gt; PII;
const LL N = 2e5 + 7, INF = 1e18;
struct edge &amp;#123; LL v, w; &amp;#125;;
vector&amp;lt;edge&amp;gt; e[N];
priority_queue&amp;lt;PII, vector&amp;lt;PII&amp;gt;, greater&amp;lt;PII&amp;gt; &amp;gt; q;
LL n, m, b;
LL dis[N];
bool used[N];

inline void Dijkstra(int s) &amp;#123;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123; dis[i] = INF; &amp;#125;
    dis[s] = 0;
    q.push(&amp;#123;0, s&amp;#125;);
    while (!q.empty()) &amp;#123;
        auto t = q.top(); q.pop();
        // 按照dis排序，每次取出堆顶的点
        LL u = t.second;
        if (used[u]) &amp;#123; continue; &amp;#125;
        // 如果在S集合中就扔掉不管
        used[u] = true;
        // u完成使命放入S集合中
        for (auto it : e[u]) &amp;#123;
            LL v = it.v, w = it.w;
            if (dis[v] &amp;gt; dis[u] + w) &amp;#123;
                dis[v] = dis[u] + w;
                q.push(&amp;#123;dis[v], v&amp;#125;);
                // 成功松弛就扔进队列里
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;队列中元素的个数是 $O(m)$ 个，那么维护堆的时间复杂度就是 $O(logm)$，我们对每个点都更新一次，所以优化后的时间复杂度是 $O(mlogm)$。&lt;/p&gt;
&lt;p&gt;我们发现，$\operatorname{Dijkstra}$ 算法虽然很好用，但是在遇到负边权的时候，每次松弛都会选到负的那条边，因为这样显然更小。松弛后，开始在 $T$ 中寻找下一个点，结果我们发现最小边权的点变成了上次松弛的 $v$，我们又松弛 $v$，再下一次又找到了第一次的 $u$。结果最后我们在负边相连的两个点间反复横跳，这个算法就寄了，这就是为什么 $\operatorname{Dijkstra}$ 处理的是非负权图单源最短路。那么遇到负权难道我们就得牺牲时间去用 $\operatorname{Floyd}$ 了么？显然不是，我们还有其它算法。&lt;/p&gt;
&lt;h2 id=&#34;operatorname-Bellman-Ford-（带负权单源最短路）&#34;&gt;$\operatorname{Bellman-Ford}$ （带负权单源最短路）&lt;/h2&gt;
&lt;p&gt;$\operatorname{Bellman-Ford}$ 寻找最短路的方法也是通过和刚刚一样的松弛操作，它每次对所有点都松弛一次，直到松弛到无法松弛为止。一个图内单源最短路的数量最多为 $n-1$，这个结论很平凡。所以松弛操作肯定也是最多执行 $n-1$ 次，那么如果执行多了说明什么？显然是说明有一个负权边使得那两个点开始左右横跳了，那么就判断出了负环。请注意，从 $s$ 点出发没有找到负环并不能说明图中没有负环，只能说明 $s$ 点出发抵达的点和边构成的子图中没有负环。想要判断一个图中有没有负环，需要建立一个超级源点，这个源点和图上每一个点都有一条边且边权均为 $0$，以超级源点为源点跑 $\operatorname{Bellman-Ford}$ 就一定可以判断出有没有负环。下面是 $\operatorname{Bellman-Ford}$ 的具体实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef long long LL;
const LL N = 2e5 + 7, INF = 1e18;
struct edge &amp;#123; LL v, w; &amp;#125;;
vector&amp;lt;edge&amp;gt; e[N];
LL n, m, b;
LL dis[N];

inline bool Bellman_Ford(int s) &amp;#123;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123; dis[i] = INF; &amp;#125;
    dis[s] = 0;
    bool flag; 
    // flag用来判断循环时有没有进行松弛
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        flag = false;
        for (int u = 1; u &amp;lt;= n; ++u) &amp;#123;
            for (auto it : e[u]) &amp;#123;
                auto v = it.v, w = it.w;
                if (dis[v] &amp;gt; dis[u] + w) &amp;#123;
                    dis[v] = dis[u] + w;
                    flag = true;
                    // 松弛后打上标记
                &amp;#125;
            &amp;#125;
        &amp;#125;
        if (!flag) &amp;#123; break; &amp;#125;
        // 如果没有松弛说明所有路径更新完毕，可以直接结束
    &amp;#125;
    // n轮松弛后如果仍然能进行松弛，说明一定存在负环
    return flag;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最多进行 $n$ 次松弛操作，每轮操作最多进行 $m$ 次松弛，所以 $\operatorname{Bellman-Ford}$ 的时间复杂度为 $O(nm)$，数据大的题也是过不去的，所以需要对其进行优化，于是就有了一个人们耳熟能详的算法：$\operatorname{SPFA}$ 算法。&lt;/p&gt;
&lt;p&gt;$\operatorname{SPFA}$ 的主要思路就是在 $\operatorname{Bellman-Ford}$ 的基础上，用队列进行优化。我们每次松弛的时候，真正起到实际作用的操作其实只有当 $u$ 为源点或上次被松弛过，这次的松弛操作才有意义，所以我们把每次松弛的点都扔进队列里，只从队列中取出点来松弛就可以降低时间复杂度。**但是请注意，这是一个假算法！**诶，那这很奇怪啊，为什么广为人知，受人追捧的可爱的 $\operatorname{SPFA}$ 会是一个假算法呢？因为我们用优先队列，并不是忽略或者对哪个点不进行松弛，而是改变了松弛的顺序从而达到优化目的，那么如果遇到刻意构造的数据，就可以轻轻松松将 $\operatorname{SPFA}$ 卡到 $O(nm)$ 从而让你的程序寄掉。这是某一年国赛带给全体 $OIer$ 的惨痛教训，所以在没有负环的情况下，尽量不要使用 $\operatorname{SPFA}$。下面给出参考代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef long long LL;
const LL N = 1e6 + 7, INF = 1e18;
struct edge &amp;#123; LL v, w; &amp;#125;;
vector&amp;lt;edge&amp;gt; e[N];
queue&amp;lt;int&amp;gt; q;
LL n, m, b;
LL dis[N], cnt[N];
bool used[N];

inline bool SPFA(int s) &amp;#123;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123; dis[i] = INF; &amp;#125;
    dis[s] = 0;
    used[s] = true;
    q.push(s);
    while (!q.empty()) &amp;#123;
        int u = q.front(); q.pop();
        used[u] = false;
        for (auto it : e[u]) &amp;#123;
            auto v = it.v, w = it.w;
            if (dis[v] &amp;gt; dis[u] + w) &amp;#123;
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] &amp;gt;= n) &amp;#123; return false; &amp;#125;
                if (!used[v]) &amp;#123; 
                    q.push(v);
                    used[v] = true; 
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return true;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说了这么多了让我们来理一理，我们最开始因为 $\operatorname{Floyd}$ 算法求全源最短路对单源最短路的问题又浪费，所以学习了 $\operatorname{Dijkstra}$，又因为其无法处理负权学习了 $\operatorname{Bellman-Ford}$。那么，我们需要考虑这样一个问题：如果我们要处理全源最短路，但是数据范围又比较大该怎么办呢？我们是不是可以跑 $n$ 遍 $\operatorname{Dijkstra}$，这样复杂度也不是很高，但碰到负权就寄了，所以就有了另外一个算法。&lt;/p&gt;
&lt;h2 id=&#34;operatorname-Johnson-（全源最短路）&#34;&gt;$\operatorname{Johnson}$（全源最短路）&lt;/h2&gt;
&lt;p&gt;$\operatorname{Johnson}$ 可以说是前面算法的大杂烩了，$\operatorname{Dijkstra}$ 和 $\operatorname{Bellman-Ford}$ 揉在一起再跑。如何处理负环呢，我们首先建立一个超级源点，也就是传说中的 $0$ 号点，前面已经说过了不再赘述。建立好了以后以这个超级源点为源点跑 $SPFA$，其中 $0$ 号点到 $i$ 号点的最短路记为 $newdis_i$。接下来对于边 $(u,v)=w$，将其边权设置为 $w + newdis_u - newdis_v$，然后再跑 $n$ 遍 $\operatorname{Dijkstra}$，每次求出的 $dis+newdis_v-newdis_u$ 就是答案了。这种做法的正确性在于从 $s$ 到 $t$ 的最短路径长度的势能是没有变的，具体证明见下面这篇博客：&lt;a href=&#34;https://www.luogu.com.cn/blog/StudyingFather/johnson-algorithm&#34;&gt;正确性证明&lt;/a&gt;。下面是参考代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cstring&amp;gt;
#define LL long long
#define PII pair&amp;lt;LL, LL&amp;gt;
#define clear(cc) memset(cc, 0, sizeof(cc))
using namespace std;

namespace SHAWN &amp;#123;
    const LL N = 6e3 + 7, INF = 1e9;
    struct edge &amp;#123; LL v, w; &amp;#125;;
    vector&amp;lt;edge&amp;gt; e[N];
    LL n, m;
    LL dis[N], newdis[N];
    int cnt[N];
    bool used[N];

    inline bool SPFA(int s) &amp;#123;
        queue&amp;lt;int&amp;gt; sq;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123; newdis[i] = INF; &amp;#125;
        clear(used);
        newdis[s] = 0;
        used[s] = true;
        sq.push(s);
        while (!sq.empty()) &amp;#123;
            int u = sq.front(); sq.pop();
            used[u] = false;
            for (auto it : e[u]) &amp;#123;
                LL v = it.v, w = it.w;
                if (newdis[v] &amp;gt; newdis[u] + w) &amp;#123;
                    newdis[v] = newdis[u] + w;
                    cnt[v] = cnt[u] + 1;
                    if (cnt[v] &amp;gt; n) &amp;#123; return false; &amp;#125;
                    // 注意这里因为插入了超级源点，所以要多跑一轮，&amp;gt;=要变成&amp;gt;
                    if (!used[v]) &amp;#123;
                        sq.push(v);
                        used[v] = true;
                    &amp;#125; 
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return true;
    &amp;#125;

    inline void Dijkstra(int s) &amp;#123;
        priority_queue&amp;lt;PII, vector&amp;lt;PII&amp;gt;, greater&amp;lt;PII&amp;gt; &amp;gt; q;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123; dis[i] = INF; &amp;#125;
        clear(used);
        dis[s] = 0;
        q.push(&amp;#123;0,s&amp;#125;);
        while (!q.empty()) &amp;#123;
            auto t = q.top(); q.pop();
            int u = t.second;
            if (used[u]) &amp;#123; continue; &amp;#125;
            used[u] = true;
            for (auto it : e[u]) &amp;#123;
                LL v = it.v, w = it.w;
                if (dis[v] &amp;gt; dis[u] + w) &amp;#123;
                    dis[v] = dis[u] + w;
                    q.push(&amp;#123;dis[v], v&amp;#125;);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return;
    &amp;#125;
    
    int work()
    &amp;#123;
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        for (int i = 1, x, y, z; i &amp;lt;= m; ++i) &amp;#123;
            cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;
            e[x].push_back(&amp;#123;y, z&amp;#125;);
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123; e[0].push_back(&amp;#123;i, 0&amp;#125;); &amp;#125;
        // 建立超级源点
        if (!SPFA(0)) &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;-1\n&amp;quot;; return 0;&amp;#125;
        // 先跑SPFA预处理边权
        for (int u = 1; u &amp;lt;= n; ++u) &amp;#123;
            for (int i = 0; i &amp;lt; e[u].size(); ++i) &amp;#123;
                e[u][i].w += newdis[u] - newdis[e[u][i].v];
            &amp;#125;
        &amp;#125;
        // 更改每条边的边权
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            Dijkstra(i);// 跑n遍Dijkstra就做完了
            LL ans = 0;
            for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
                if (dis[j] == INF) &amp;#123; ans += j * INF; &amp;#125;
                else  &amp;#123; ans += j * (dis[j] + newdis[j] - newdis[i]); &amp;#125;
            &amp;#125;
            cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\n&#39;;
        &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;

signed int main() &amp;#123;
    ios :: sync_with_stdio(false);
    cin.tie(nullptr);
    return SHAWN :: work();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的时间复杂度是 $O(nmlogm)$，相比 $\operatorname{Floyd}$ 还是非常优化的。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;想要求单源最短路，可以选择 $\operatorname{Dijkstra}$ 或 $\operatorname{Bellman-Ford(SPFA)}$，时间复杂度分别为 $O(mlogm)$ 和 $O(nm)$，前者只能处理非负权图，而后者可以处理带负权图。想要求全源最短路，可以选择 $\operatorname{Floyd}$ 或 $\operatorname{Johnson}$，时间复杂度分别为 $O(n^3)$ 和 $O(nmlogm)$，二者均可以处理带负权图。也就是说除了 $\operatorname{Dijkstra}$，其余的三个算法均可以处理带负权图以及判断负环。比赛时尽量使用 $\operatorname{Dijkstra}$ 和 $\operatorname{Johnson}$，不到迫不得已尽量不要用剩下两种，否则很容易被卡。&lt;/p&gt;
&lt;p&gt;以上就是全部内容，如有错误欢迎各位大佬指正。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://oi-wiki.org/graph/shortest-path/&#34;&gt;OI-Wiki 最短路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/blog/StudyingFather/johnson-algorithm&#34;&gt;[洛谷日报#242]Johnson 全源最短路径算法学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《算法导论（第3版）》&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/09/07/Tarjan/</guid>
            <title>Tarjan 基础用法</title>
            <link>http://example.com/2023/09/07/Tarjan/</link>
            <category>图论</category>
            <pubDate>Thu, 07 Sep 2023 16:18:38 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;operatorname-Tarjan-求最近公共祖先&#34;&gt;$\operatorname{Tarjan}$ 求最近公共祖先&lt;/h2&gt;
&lt;h3 id=&#34;前置芝士&#34;&gt;前置芝士&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;最近公共祖先(Lowest Common Ancestor , LCA)&lt;/strong&gt;：一棵树中两个结点的 公共祖先里面，离根最远的那个被称为最近公共祖先。我们记点集 $S=\{v_1,v_2,\dots,v_n\}$ 的最近公共祖先为 $\operatorname{LCA}(v_1,v_2,\dots,v_n)$ 或 $\operatorname{LCA}(S)$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性质&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\operatorname{LCA}(\{u\}=u)$；&lt;/li&gt;
&lt;li&gt;$u$ 是 $v$ 的祖先当且仅当 $\operatorname{LCA}(u,v)=u$；&lt;/li&gt;
&lt;li&gt;若 $u$ 和 $v$ 互相都不是对方的祖先，则 $u,v$ 分别处于 $\operatorname{LCA}(u,v)$ 的两棵不同子树中；&lt;/li&gt;
&lt;li&gt;前序遍历，$\operatorname{LCA}(S)$ 出现在所有 $S$ 中元素之前，后序遍历，$\operatorname{LCA}(S)$ 出现在所有 $S$ 中元素之后；&lt;/li&gt;
&lt;li&gt;两点集的并的最近公共祖先为两点集各自最近公共祖先的最近公共祖先，即$\operatorname{LCA}(A \cup B)=\operatorname{LCA}(\operatorname{LCA}(A),\operatorname{LCA}(B))$；&lt;/li&gt;
&lt;li&gt;两结点的最近公共祖先一定在其这两点最短路上&lt;/li&gt;
&lt;li&gt;设 $d$ 为树上两点间的距离，$h$ 为一个点到树根的距离，则 $d_{uv}=h_u+h_v-2h(\operatorname{LCA}(u,v))$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现过程&#34;&gt;实现过程&lt;/h3&gt;
&lt;p&gt;请注意啦，$\operatorname{Tarjan}$ 是一个离线算法，所以只能处理离线的 $\operatorname{LCA}$ 询问，在线需要使用其它方法。但是 $\operatorname{Tarjan}$ 可以在一次搜索后求出所有点对的 $\operatorname{LCA}$，所以仍然具有研究价值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先我们要建立两个链表，$edge$ 用来存树，而 $qedge$ 用来存储一种查询关系，即对于一个点 $u$，$qedge$ 要记录点 $u$ 都与哪些其它点存在询问；&lt;/li&gt;
&lt;li&gt;接下来我们对整棵树开始 $\operatorname{DFS}$，用 $vis$ 记录是否访问过，用 $fa_i$ 表示 $i$ 的父亲，由于 $\operatorname{DFS}$ 的基本思想是每次只关心当前这一级，所以我们认为当前搜到的点 $u$ 就是以 $u$ 为根的子树的根，&lt;s&gt;这句话看似是废话其实也是废话&lt;/s&gt;，这么写是为了提醒读者在搜索开始时要把这个点的父亲设置为自己，也就是非常容易遗忘的初始化操作；&lt;/li&gt;
&lt;li&gt;回溯的时候将 $fa_v$ 设置为 $u$，也就是逐级递归找爸爸；&lt;/li&gt;
&lt;li&gt;在回溯期间，如果包含当前节点的查询的另一个结点也访问过了，就可以更新这两个点的 $\operatorname{LCA}$ 了；&lt;/li&gt;
&lt;li&gt;最后统计输出答案的时候，不要忘记使用刚刚我们学到的最后一个性质来辅助我们。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;核心代码就长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void Tarjan(int u) &amp;#123;// 递归每一层都处理当前节点的子树
    fa[u] = u;// 初始化
    vis[u] = true;
    for (int i = head[u]; i; i = edge[i].next) &amp;#123;// 向下搜索
        int v = edge[i].to;
        if (!vis[v]) &amp;#123;
            Tarjan(v);
            fa[v] = u;
        &amp;#125;
    &amp;#125;
    for (int i = qhead[u]; i; i = qedge[i].next) &amp;#123;
        // 搜索并标记含有 u 结点的所有询问
        int v = qedge[i].to;
        if (vis[v]) &amp;#123;// 两个结点必须都被标记过
            qedge[i].lca = find(v);// 标记 LCA
            // 2n-1与2n的结果相同
            if (i % 2) &amp;#123; qedge[i + 1].lca = qedge[i].lca; &amp;#125;
            else &amp;#123; qedge[i - 1].lca = qedge[i].lca; &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;例题&#34;&gt;例题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3379&#34;&gt;模板 最近公共祖先（LCA）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这就是个模板题，把上面那段代码套上去补完剩下的建图部分就可以了，所以不必过多赘述。&lt;/p&gt;
&lt;p&gt;参考代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;

namespace SHAWN &amp;#123;
    const int N = 1e6 + 7;
    int head[N], cnt;
    int qhead[N], qcnt;
    struct node &amp;#123; int to, next, lca; &amp;#125;;
    node edge[N], qedge[N]; 
    int n, m, s;
    int fa[N];
    bool vis[N];

    inline void add(int u, int v) &amp;#123;
        edge[++cnt].next = head[u];
        edge[cnt].to = v;
        head[u] = cnt;
    &amp;#125;
    inline void qadd(int u, int v) &amp;#123;
        qedge[++qcnt].next = qhead[u];
        qedge[qcnt].to = v;
        qhead[u] = qcnt;
    &amp;#125;
    int find(int x) &amp;#123;
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    &amp;#125;

    void Tarjan(int u) &amp;#123;
        fa[u] = u;
        vis[u] = true;
        for (int i = head[u]; i; i = edge[i].next) &amp;#123;
            int v = edge[i].to;
            if (!vis[v]) &amp;#123;
                Tarjan(v);
                fa[v] = u;
            &amp;#125;
        &amp;#125;
        for (int i = qhead[u]; i; i = qedge[i].next) &amp;#123;
            int v = qedge[i].to;
            if (vis[v]) &amp;#123;
                qedge[i].lca = find(v);
                if (i % 2) &amp;#123; qedge[i + 1].lca = qedge[i].lca; &amp;#125;
                else &amp;#123; qedge[i - 1].lca = qedge[i].lca; &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    
    int work()
    &amp;#123;
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; s;
        for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
            cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            add(x, y); add(y, x);
        &amp;#125;
        for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
            cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            qadd(x, y); qadd(y, x);
        &amp;#125;
        Tarjan(s);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            cout &amp;lt;&amp;lt; qedge[i &amp;lt;&amp;lt; 1].lca &amp;lt;&amp;lt; &#39;\n&#39;;
        &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;

signed int main() &amp;#123;
    ios :: sync_with_stdio(false);
    cin.tie(nullptr);
    return SHAWN :: work();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;operatorname-Tarjan-求割点、割边&#34;&gt;$\operatorname{Tarjan}$ 求割点、割边&lt;/h2&gt;
&lt;h3 id=&#34;前置芝士-2&#34;&gt;前置芝士&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;割点&lt;/strong&gt;：在一个无向连通图 $G(V,E)$ 中，删去结点 $u$ 和与它相连的边后，若该图变为非连通图，则称结点 $u$ 为该图的&lt;strong&gt;割点（关节点）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;割边&lt;/strong&gt;：在一个无向连通图 $G(V,E)$ 中，删去边 $e$ 后，若该图变为非连通图，则称边 $e$ 为该图的&lt;strong&gt;割边（桥）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如下图中的 $2$ 点和 $6$ 点为割点，边 $(1,2)$ 和边 $(6,7)$ 为割边：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/22/pPJeMZj.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重连通图&lt;/strong&gt;：一个不含割点的连通图称为&lt;strong&gt;重连通图（双连通图）&lt;/strong&gt;。重连通无向图重每对顶点之间至少存在两条路径，下图就是一个重连通图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/22/pPJelon.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些性质&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个割点之间的边不一定是割边&lt;/li&gt;
&lt;li&gt;割边的两个端点不一定都是割点，但一定有一个是割点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;operatorname-Tarjan-求割点&#34;&gt;$\operatorname{Tarjan}$ 求割点&lt;/h3&gt;
&lt;p&gt;比方说我们对刚刚这个图求割点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/22/pPJeMZj.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们从结点 $2$ 开始深度优先遍历，可以得到如下深度优先生成树，实线边构成树边，虚线边构成回边：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/22/pPJeQds.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;设原图为 $G(V,E)$，其深度优先生成树为 $T(V,E)$ ，则 $G$ 和 $T$ 具有如下的性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\forall u \in V(T)$ ，要么是根，要么不是根&lt;/li&gt;
&lt;li&gt;$u$ 为根时，$u$ 是割点 $\Leftrightarrow $ $u$ 有 $2$ 棵或 $2$ 棵以上的子树&lt;/li&gt;
&lt;li&gt;$u$ 不为根时，$u$ 是割点 $\Leftrightarrow $ $u$ 存在儿子 $v$ 使得 $low_v \ge dfn_u$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们发现性质里有一些陌生的东西，$dfn$ 和 $low$，这两个东西分别叫做&lt;strong&gt;深度优先数&lt;/strong&gt;和&lt;strong&gt;最低深度优先数&lt;/strong&gt;。我们在刚刚 $\operatorname{DFS}$ 遍历的时候按照 $\operatorname{DFS}$ 序给每个结点打上时间戳，这些时间戳就是深度优先数，我们用 $dfn$ 数组来存储它。如上图生成树中，$dfn_2=1$，$dfn_1=2$，$dfn_3=3$，$dfn_4=5$，$dfn_5=6$，$dfn_6=4$，$dfn_7=7$。而最低深度优先数 $low$ 则表示从结点 $u$ 出发能到达的点的最小深度优先数，其决定式如下：&lt;/p&gt;
$$\displaylines{low_u=min\left\{\begin{matrix}
 dfn_u\\
 low_v(u,v\in V(T),v是u的孩子)\\
 dfn_v(u,v\in V(T),(u,v)是一条回边)
\end{matrix}\right.
}$$&lt;p&gt;那么知道了这些我们再回过头去看刚刚第三个性质，当 $v$ 是 $u$ 的儿子且 $low_v&amp;lt;dfn_u$ 时，以 $v$ 为根节点的子树中必然有节点与 $u$ 的祖先有回边，如果 $u$ 的任意儿子都满足这个特点时，$u$ 显然不是割点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3388&#34;&gt;模板 P3388 【模板】割点（割顶）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace SHAWN &amp;#123;
    const int N = 2e5 + 7;// 双向边开二倍空间
    int head[N], cnt;
    struct edge&amp;#123; int to, next; &amp;#125;edge[N];
    int dfn[N], low[N];
    bool used[N], flag[N];
    int n, m, res, tim; 

    inline void add(int u, int v) &amp;#123;
        edge[++cnt].next = head[u];
        edge[cnt].to = v;
        head[u] = cnt;
    &amp;#125;

    void Tarjan(int u, int fa) &amp;#123;
        used[u] = true;
        low[u] = dfn[u] = ++tim;
        int child = 0;
        for (int i = head[u]; i; i = edge[i].next) &amp;#123;
            int v = edge[i].to;
            if (!used[v]) &amp;#123;
                if (fa == u) &amp;#123; ++child; &amp;#125;
                Tarjan(v, u);
                // 如果v是u的孩子
                low[u] = min(low[u], low[v]);
                // 如果u不是根且low[u] &amp;gt;= dfn[u]就是割点 
                if (fa != u &amp;amp;&amp;amp; low[v] &amp;gt;= dfn[u] &amp;amp;&amp;amp; !flag[u]) &amp;#123;
                    flag[u] = true;
                    ++res;
                &amp;#125; 
            &amp;#125;
            // 如果(u,v)是一条回边
            else if (fa != v) &amp;#123;
                low[u] = min(low[u], dfn[v]);
            &amp;#125;
        &amp;#125;
        // 如果u是根且有两个或两个以上子树就是割点
        if (fa == u &amp;amp;&amp;amp; child &amp;gt;= 2 &amp;amp;&amp;amp; !flag[u]) &amp;#123;
            flag[u] = true;
            ++res;
        &amp;#125;
    &amp;#125;

    int work()
    &amp;#123;
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
            cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            add(x, y); add(y, x);
        &amp;#125;
        // 不保证连通所以要多次跑
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (!used[i]) &amp;#123;
                tim = 0;
                Tarjan(i, i);
            &amp;#125;
        &amp;#125;
        cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &#39;\n&#39;;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (flag[i]) &amp;#123; cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39; &#39;; &amp;#125;
        &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;operatorname-Tarjan-求割边&#34;&gt;$\operatorname{Tarjan}$ 求割边&lt;/h3&gt;
&lt;p&gt;设原图为 $G(V,E)$，其深度优先生成树为 $T(V,E)$ ，则 $G$ 和 $T$ 满足如下定理：&lt;/p&gt;
&lt;p&gt;$\exists u,v \in T$，$u$ 是 $v$ 的双亲，$u,v$ 之间的边不是有重边，则 $(u,v)$ 是割边 $\Leftrightarrow $ $u$ 到 $v$ 的边不是重边且 $v$ 或 $v$ 的子孙结点中没有指向 $u$ 或着 $u$ 的祖先的回边。即 $(u,v)$ 是割边 $\Leftrightarrow$ $dfn_u&amp;lt;low_v$。&lt;/p&gt;
&lt;p&gt;然后我们把刚刚代码稍微改一改就出来了，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void Tarjan(int u, int fa) &amp;#123;
    par[u] = fa;
    low[u] = dfn[u] = ++tim;
    for (int i = head[u]; i; i = edge[i].next) &amp;#123;
        int v = edge[i].to;
        if (!dfn(v)) &amp;#123;
            Tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] &amp;gt; dfn[u]) &amp;#123;
                flag[v] = true;
                ++res;
            &amp;#125;
        &amp;#125;
        else if (dfn[v] &amp;lt; dfn[u] &amp;amp;&amp;amp; v != fa) &amp;#125;&amp;#123;
            low[u] = min(low[u], dfn[v]);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后当 $flag_u$ 为真时，边 $(u,par_u)$ 就是割边。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1656&#34;&gt;模板 P1656 炸铁路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace SHAWN &amp;#123;
    const int N = 1e4 + 7;
    int head[N], cnt;
    struct edge &amp;#123; int to, next; &amp;#125;edge[N];
    struct node &amp;#123; int a, b; &amp;#125;;
    int dfn[N], low[N];
    int n, m, tim;
    struct cmp&amp;#123; 
        bool operator() (const node &amp;amp;x, const node &amp;amp;y) const &amp;#123;
            if (x.a != y.a) &amp;#123; return x.a &amp;gt; y.a; &amp;#125;
            else &amp;#123; return x.b &amp;gt; y.b; &amp;#125;
        &amp;#125;
    &amp;#125;;
    priority_queue&amp;lt;node, vector&amp;lt;node&amp;gt;, cmp&amp;gt; q;

    inline void add(int u, int v) &amp;#123;
        edge[++cnt].next = head[u];
        edge[cnt].to = v;
        head[u] = cnt;
    &amp;#125;

    void Tarjan(int u, int fa) &amp;#123;
        low[u] = dfn[u] = ++tim;
        for (int i = head[u]; i; i = edge[i].next) &amp;#123;
            int v = edge[i].to;
            if (!dfn[v]) &amp;#123;
                Tarjan(v, u);
                low[u] = min(low[u], low[v]);
                if (low[v] &amp;gt; dfn[u]) &amp;#123;
                    q.push(&amp;#123;u,v&amp;#125;);
                &amp;#125;
            &amp;#125;
            else if (dfn[v] &amp;lt; dfn[u] &amp;amp;&amp;amp; v != fa) &amp;#123;
                low[u] = min(low[u], dfn[v]);
            &amp;#125;
        &amp;#125;
    &amp;#125;

    int work()
    &amp;#123;
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
            cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            add(x, y); add(y, x);
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (!dfn[i]) &amp;#123;
                Tarjan(i, i);
            &amp;#125;
        &amp;#125;
        while (!q.empty()) &amp;#123;
            auto it = q.top(); q.pop();
            cout &amp;lt;&amp;lt; it.a &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; it.b &amp;lt;&amp;lt; &#39;\n&#39;;
        &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;例题-2&#34;&gt;例题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5058&#34;&gt;1、割点 [ZJOI2004] 嗅探器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目要求我们删掉一个点使得给定的两个点不连通，那么其实我们就是要找一个满足要求的割点，如下图标黑的点就是题目给定的两个点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/23/pPJqc80.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;点 $1$ 是一个割点，我们删除点 $1$ 即可使得 $2,4$ 两点不连通，但是并非任意割点都满足要求，比方说下面这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/23/pPJqg2V.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;点 $3$ 和点 $4$ 都是图中的割点，但是删去 $4$ 并不能使得目标点 $1,7$ 不连通，所以只有点 $3$ 是符合条件的点，那么我们就要去筛选割点中符合要求的点。&lt;/p&gt;
&lt;p&gt;怎么筛呢？其实我们想一想建立 $\operatorname{DFS}$ 树的过程，我们从题中给定的一个点开始搜，那么对于一个符合条件的割点来讲，题中给定的另一个点一定在这个符合条件的割点的子树中。所以在搜的时候加个判断条件就好了。本题因为不能删去根，所以不用考虑根是割点的情况，那么代码也就非常简单：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;

namespace SHAWN &amp;#123;
    const int N = 1e6 + 7;
    int head[N], cnt;
    struct edge &amp;#123; int to, next; &amp;#125;edge[N];
    int n, tim, x, y;
    int dfn[N], low[N];
    bool vis[N], flag[N];

    inline void add(int u, int v) &amp;#123;
        edge[++cnt].next = head[u];
        edge[cnt].to = v;
        head[u] = cnt;
    &amp;#125;

    void Tarjan(int u, int fa) &amp;#123;
        low[u] = dfn[u] = ++tim;
        vis[u] = true;
        for (int i = head[u]; i; i = edge[i].next) &amp;#123;
            int v = edge[i].to;
            if (!vis[v]) &amp;#123;
                Tarjan(v, u);
                low[u] = min(low[u], low[v]);
                // 这里多加一个u!=x和dfn[y]&amp;gt;=dfn[v]的特判就OK了
                if (fa != u &amp;amp;&amp;amp; low[v] &amp;gt;= dfn[u] &amp;amp;&amp;amp; u != x &amp;amp;&amp;amp; dfn[y] &amp;gt;= dfn[v]) &amp;#123;
                    flag[u] = true;
                &amp;#125;
            &amp;#125;
            else if (fa != v) &amp;#123;
                low[u] = min(low[u], dfn[v]);
            &amp;#125;
        &amp;#125;
    &amp;#125;

    int work()
    &amp;#123;
        cin &amp;gt;&amp;gt; n;
        while (cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;amp;&amp;amp; x &amp;amp;&amp;amp; y) &amp;#123;
            add(x, y); add(y, x);
        &amp;#125;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        Tarjan(x, x);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (flag[i]) &amp;#123;
                cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39;\n&#39;;
                return 0;
            &amp;#125;
        &amp;#125;
        cout &amp;lt;&amp;lt; &amp;quot;No solution\n&amp;quot;;
        return 0;
    &amp;#125;
&amp;#125;

signed int main() &amp;#123;
    ios :: sync_with_stdio(false);
    cin.tie(nullptr);
    return SHAWN :: work();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7687&#34;&gt;2、割边 [CEOI2005] Critical Network Lines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与上一道题一样，我们显然可以看出来题目想让我们求出满足下面条件的割边——删掉这条边后剩下的两个连通块中至少一个块只包含 $A$ 类点或 $B$ 类点。比如下图（图中边上的数字是编号不是边权）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/24/pPYBlad.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这幅图中的割边有 $1,4,5,6,8$ 五条，而符合题目条件的只有 $1,6,8$ 这三条。我们发现，当一个割边满足条件当且仅当它连接的一个节点在深度优先生成树中的子树内只包含一类点。所以我们在 $\operatorname{Tarjan}$ 求割边的时候，每找到一条割边 $(u,v)$，我们就检查一下以 $v$ 为根结点的子树内 $A$ 和 $B$ 类结点各自的数量，当其中一个个数为 $0$ 或者全满，就是要求的边，打上标记并给计数的答案加一就可以了。求数量的过程，可以在 $\operatorname{DFS}$ 的时候递归计算。下面是 AC 代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;

namespace SHAWN &amp;#123;
    const int N = 2e6 + 7;
    // 请注意这里一定要开二倍空间，要不然会寄
    int head[N], cnt;
    struct edge &amp;#123; int to, next; &amp;#125;edge[N];
    int n, m, a, b, tim, res;
    int dfn[N], low[N], acnt[N], bcnt[N], par[N];
    // acnt[i]表示i结点子树中A类点数量，bcnt同理
    // par用来记每个结点在dfs生成树中的父亲
    bool flag[N];

    inline void add(int u, int v) &amp;#123;
        edge[++cnt].next = head[u];
        edge[cnt].to = v;
        head[u] = cnt;
    &amp;#125;

    void Tarjan(int u, int fa) &amp;#123;
        low[u] = dfn[u] = ++tim;
        par[u] = fa;
        for (int i = head[u]; i; i = edge[i].next) &amp;#123;
            int v = edge[i].to;
            if (!dfn[v]) &amp;#123;
                Tarjan(v, u);
                low[u] = min(low[u], low[v]);
                if (low[v] &amp;gt; dfn[u]) &amp;#123;
                    if (!acnt[v] || !bcnt[v] || acnt[v] == a || bcnt[v] == b) &amp;#123;
                        // A类或B类有一个为0或全满就说明符合要求
                        flag[v] = true;
                        ++res;
                    &amp;#125;
                &amp;#125;
                acnt[u] += acnt[v]; bcnt[u] += bcnt[v];
                // 从下向上递归统计子树情况
            &amp;#125;
            else if (dfn[v] &amp;lt; dfn[u] &amp;amp;&amp;amp; fa != v) &amp;#123;
                low[u] = min(low[u], dfn[v]);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    int work()
    &amp;#123;
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        for (int i = 1, x; i &amp;lt;= a; ++i) &amp;#123; cin &amp;gt;&amp;gt; x; acnt[x] = 1; &amp;#125;
        for (int i = 1, x; i &amp;lt;= b; ++i) &amp;#123; cin &amp;gt;&amp;gt; x; bcnt[x] = 1; &amp;#125;
        // 最开始每个点的子树就是自己
        for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
            cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            add(x, y); add(y, x);
        &amp;#125;
        Tarjan(1, 0);
        cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &#39;\n&#39;;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (flag[i]) &amp;#123;
                cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; par[i] &amp;lt;&amp;lt; &#39;\n&#39;;
            &amp;#125;
        &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;

signed int main() &amp;#123;
    ios :: sync_with_stdio(false);
    cin.tie(nullptr);
    return SHAWN :: work();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;operatorname-Tarjan-求强连通分量&#34;&gt;$\operatorname{Tarjan}$ 求强连通分量&lt;/h2&gt;
&lt;h3 id=&#34;前置芝士-3&#34;&gt;前置芝士&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;强连通&lt;/strong&gt;：在有向图 $G$ 中，如果两个顶点 $u_i,u_j$ 间 $(u_i \ne u_j)$ 有一条从 $u_i$ 到 $u_j$ 的有向路径，同时还有一条从 $u_j$ 到 $u_i$ 的有向路径，则称两个顶点&lt;strong&gt;强连通(Strongly Connected, SC)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强连通图&lt;/strong&gt;：有向图 $G$ 中，若任意两点强连通，则称 $G$ 是一个强连通图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强连通分量(Strongly Connected Components, SCC)&lt;/strong&gt;：极大的强连通子图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/24/pPY6O54.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图是一个强连通图，图上的强连通分量有三个：$a-b-c-d,e,f$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缩点&lt;/strong&gt;：因为强连通图中任意两点连通，所以在不考虑路径长度只考虑连通性的情况下，可以将一个强连通分量压缩成一个点来进行处理，这样就可以缩小图的规模。&lt;/p&gt;
&lt;h3 id=&#34;实现过程-2&#34;&gt;实现过程&lt;/h3&gt;
&lt;p&gt;我们算法的主要过程与步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从根开始向下搜索，实时更新 $dfn$ 和 $low$，每搜到一个点就入栈；&lt;/li&gt;
&lt;li&gt;当 $v$ 未被访问过，我们继续深搜，在回溯过程中，用 $low_v$ 更新 $low_u$，当回溯到某一个点 $u$ 使得 $dfn_u=low_u$ 时，弹栈直到把自己也弹出来，这些弹出来的元素就是一个强连通分量；&lt;/li&gt;
&lt;li&gt;当 $v$ 被访问过且已经在栈中，就像前面一样用 $dfn_v$ 更新 $low_u$；&lt;/li&gt;
&lt;li&gt;当 $v$ 被访问过且不在栈中，不操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面给出一个例子来帮助读者理解这一过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/08/24/pPYRldK.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如图 (a)，从 $1$ 开始搜，$1$ 入栈，$dfn_1=low_1=1$；&lt;/li&gt;
&lt;li&gt;如图 (b)，搜到 $2$，$2$ 入栈，搜到 $3$，$3$ 入栈，搜到 $4$，$4$ 入栈，接下来通过返祖边搜到了 $2$，$low_4=2$；&lt;/li&gt;
&lt;li&gt;如图 ©，返回 $3$，$low_3=2$，返回 $2$，$low_2=2$，此时 $low_2=dfn_2=2$，所以找到了一个强连通分量，弹栈直到自己得到连通分量 $\{2,3,4\}$；&lt;/li&gt;
&lt;li&gt;如图 (d)，返回 $1$，搜到 $5$ 入栈，搜到 $6$ 入栈，连向 $3$ 有一条横向边，但 $3$ 不在栈里，所以不管，搜到 $7$ 入栈，然后搜不下去了，$low_7=dfn_7=7$，弹栈直到自己得到连通分量 $\{7\}$；&lt;/li&gt;
&lt;li&gt;如图 (e)，返回 $6$，$low_6=dfn_6=6$，弹栈知直到自己得到连通分量 $\{6\}$，回到 $5$，访问过了但是 $dfn$ 和 $low$ 更新后没变，搜到 $8$，接下来通过返祖边搜到了 $1$，$low_8=1$；&lt;/li&gt;
&lt;li&gt;如图 (f)，返回 $5$，$low_5=1$，返回 $1$，前向边搜到 $8$，更新后没变所以不管，返回 $1$，$low_1=dfn_1=1$，弹栈直到自己得到连通分量 $\{1,5,8\}$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码大概就长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace SHAWN &amp;#123;
    const int N = 1e5 + 10;
    int head[N], cnt;
    struct edge &amp;#123; int to, next; &amp;#125;edge[N];
    int n, m, tim, top, idx;
    int dfn[N], low[N], st[N], size[N], scc[N];
    bool chkin[N];

    inline void add(int u, int v) &amp;#123;
        edge[++cnt].next = head[u];
        edge[cnt].to = v;
        head[u] = cnt;
    &amp;#125;

    void Tarjan(int u) &amp;#123;
        low[u] = dfn[u] = ++tim;
        st[++top] = u;// 搜到就入栈
        chkin[u] = true;
        for (int i = head[u]; i; i = edge[i].next) &amp;#123;
            int v = edge[i].to;
            if (!dfn[v]) &amp;#123;
                Tarjan(v);
                low[u] = min(low[u], low[v]);
            &amp;#125;
            else if (chkin[v]) &amp;#123;
                low[u] = min(low[u], dfn[v]);
            &amp;#125;
        &amp;#125; 
        if (low[u] == dfn[u]) &amp;#123;
            //low[u]=dfn[u]时弹栈直到自己
            int v; ++idx;
            do &amp;#123;
                v = st[top--];
                scc[v] = idx;
                chkin[v] = false;
                ++size[idx];
            &amp;#125; while (v != u);
        &amp;#125;
    &amp;#125;
    int work()
    &amp;#123;
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
            cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            add(x, y);
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (!dfn[i]) &amp;#123;
                Tarjan(i);
            &amp;#125;
        &amp;#125;
        int ans = 0;
        for (int i = 1; i &amp;lt;= idx; ++i) &amp;#123;
            ans += (size[i] &amp;gt; 1);
        &amp;#125;
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\n&#39;;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            cout &amp;lt;&amp;lt; scc[i] &amp;lt;&amp;lt; &#39; &#39;;
        &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;例题-3&#34;&gt;例题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2341&#34;&gt;1、P2341 USACO03FALL / HAOI2006 受欢迎的牛 G&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们考虑如何建模。一只奶牛喜欢另一只奶牛可以表示为有向图上的一条有向边，因为爱慕关系具有传递性，所以能和其余所有点都连通的结点就是一个可行答案。我们如何去优化这个问题呢？考虑在强连通分量中，因为所有点都互相连通，所以我们可以进行缩点。缩点后如果只有一个出度为 $0$ 的点，那么答案就是这个强连通分量中包含的结点个数。如果有多个出度为 $0$ 的点或根本没有出度为 $0$ 的点，就没有明星牛。这怎么理解呢？缩点以后点内奶牛不再互相爱慕，对于整个图，只有不爱慕别的牛的牛才能成为明星奶牛~~（看看，多不好）~~，但如果大家都不爱慕别的牛了显然也不符合要求，所以我们有了这样的判断。那么代码就是上面的题小改了一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;

namespace SHAWN &amp;#123;
    const int N = 5e4 + 7;
    int head[N], cnt;
    struct edge &amp;#123; int to, next; &amp;#125;edge[N];
    int n, m, tim, top, idx, cont, ans;
    int dfn[N], low[N], size[N], sta[N], scc[N], diag[N];
    bool chkin[N];

    inline void add(int u, int v) &amp;#123;
        edge[++cnt].next = head[u];
        edge[cnt].to = v;
        head[u] = cnt;
    &amp;#125;

    void Tarjan(int u) &amp;#123;
        low[u] = dfn[u] = ++tim;
        sta[++top] = u;
        chkin[u] = true;
        for (int i = head[u]; i; i = edge[i].next) &amp;#123;
            int v = edge[i].to;
            if (!dfn[v]) &amp;#123;
                Tarjan(v);
                low[u] = min(low[u], low[v]);
            &amp;#125;
            else if (chkin[v]) &amp;#123;
                low[u] = min(low[u], dfn[v]);
            &amp;#125;
        &amp;#125;
        if (low[u] == dfn[u]) &amp;#123;
            int v; ++idx;
            do &amp;#123;
                v = sta[top--];
                scc[v] = idx;
                chkin[v] = false;
                ++size[idx];
            &amp;#125; while (v != u);
        &amp;#125;
    &amp;#125;

    int work()
    &amp;#123;
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
            cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            add(x, y);
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (!dfn[i]) &amp;#123;
                Tarjan(i);
            &amp;#125;
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            for (int j = head[i]; j; j = edge[j].next) &amp;#123;
                int v = edge[j].to;
                if (scc[i] != scc[v]) &amp;#123;
                    ++diag[scc[i]];
                &amp;#125;
            &amp;#125;
        &amp;#125;
        for (int i = 1; i &amp;lt;= idx; ++i) &amp;#123;
            if (!diag[i]) &amp;#123;
                ++cont;
                ans += size[i];  
            &amp;#125;
        &amp;#125;
        if (cont == 1) &amp;#123; cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\n&#39;; &amp;#125;
        else &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;0\n&amp;quot;; &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;

signed int main() &amp;#123;
    ios :: sync_with_stdio(false);
    cin.tie(nullptr);
    return SHAWN :: work();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们总共总结了 $\operatorname{Tarjan}$ 算法的三种主要用法，其实与其说它是一种算法，不如说它是一种 $\operatorname{DFS}$ 时的思想，也就是通过对于图上点先后访问关系来形成一棵 $\operatorname{DFS}$ 生成树，用回溯的方法在树上对点对之间的关系进行操作和处理，最终得到我们想要的最近公共祖先，割点，割边或者强连通分量。而我们在运用这些方法的时候也要做到灵活变通，仔细考虑题目中给定的点边关系，然后再将统计答案的步骤加入到搜索的过程中来通过递归和筛选得到我们想要的答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上内容如有错误或不严谨的地方，请各位巨佬指正，orz&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;汪星明 Tarjan相关算法及其应用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://oi-wiki.org/graph/lca/&#34;&gt;OI-Wiki 最近公共祖先&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/jsawz/p/6723221.html&#34;&gt;江屿 tarjan算法求LCA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://oi-wiki.org/graph/cut/&#34;&gt;OI-Wiki 割点和桥&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://oi-wiki.org/graph/scc/&#34;&gt;OI-Wiki 强连通分量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;洛谷网校《深入浅出程序设计竞赛进阶篇》&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
