{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"构造\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/09/26/AT_arc129_b%20[ARC129B]%20Range%20Point%20Distance/",
            "url": "http://example.com/2023/09/26/AT_arc129_b%20[ARC129B]%20Range%20Point%20Distance/",
            "title": "题解 AT_arc129_b Range Point Distance",
            "date_published": "2023-09-26T06:57:00.000Z",
            "content_html": "<h1>AT_arc129_b Range Point Distance</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定 $N$ 对 $L_i, R_i$，然后在每次给出后都要选一个 $x$ 使得 $x$ 到之前给出的所有区间的距离 $dist$ 的最大值最小。一个 $x$ 到区间 $l,r$ 的距离定义为 $dist=\\max(0, l - x, x - r)$。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>既然我们每次都要输出答案，那我们不妨从 $dist$ 的定义入手，我们发现在这个定义中，当其结果不为 $0$ 时只有两种情况，要么 $l$ 在 $x$ 右边，要么 $r$ 在 $x$ 左边。那么我们考虑现在有一堆区间，因为我们求的是 $x$ 到所有区间距离的最大值，所以其实我们需要关心的，能够对我们答案造成影响的值就是最靠右的 $L$ 和最靠左的 $R$。得到这个结论后剩下的就比较简单了，我们只需要每次输入一个区间都更新一下这个关键的 $L$ 和 $R$ 即可。</p>\n<p>我们现在知道了能够对我们答案造成影响的两个关键点，那么答案如何求解呢，我们进行分类讨论。</p>\n<ul>\n<li>当 $L \\le R$ 时，意味着之前输入的所有区间都有一个共同的交集 $[L,R]$，这个结论直接从 $L,R$ 的定义得出，那么我们随便在 $L,R$ 里怎么选都是 $0$，所以要找的最小值就是 $0$。</li>\n<li>当 $L &gt;R$ 时，以 $L$ 为左端点的区间和以 $R$ 为右端点的区间一定是之前输入的所有区间里距离最远的一组，只有这一对区间才会产生到 $x$ 的最大值。那么这个最大值最小当且仅当 $x$ 取在 $L,R$ 正中间，又因为要去最大值所以此时 $dist = \\left \\lceil \\frac{L + R}{2}  \\right \\rceil$。</li>\n</ul>\n<p>分析出这两条以后直接在线做就好了，时间复杂度是线性的。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const LL INF = 1e9 + 7;\n    LL n, sl = -INF, sr = INF;\n    signed work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            LL l, r; cin &gt;&gt; l &gt;&gt; r;\n            sl = max(sl, l), sr = min(sr, r);\n            // 更新两个关键点\n            if (sr &gt;= sl) &#123; cout &lt;&lt; &quot;0\\n&quot;; &#125;\n            else cout &lt;&lt; ((sl - sr + 1) &gt;&gt; 1) &lt;&lt; '\\n';\n            // 按照刚刚的分类讨论进行输出\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/20/CF1204D1%20Kirk%20and%20a%20Binary%20String%20(easy%20version)/",
            "url": "http://example.com/2023/09/20/CF1204D1%20Kirk%20and%20a%20Binary%20String%20(easy%20version)/",
            "title": "题解 CF1204D1 Kirk and a Binary String (easy version)",
            "date_published": "2023-09-20T07:41:00.000Z",
            "content_html": "<h1>CF1204D1 Kirk and a Binary String (easy version)</h1>\n<h2 id=\"形式化题意\">形式化题意</h2>\n<p>给你一个长为 $n$ 的仅包含 $0$ 和 $1$ 的串，要求尽可能多地将里面的 $1$ 改成 $0$ 使得在得到的新串中，对于 $\\forall l,r\\in [1,n](l \\le r)$，两个串的 $[l,r]$ 区间内的最长不降子序列等长。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>题中给的数据范围完全可以 $O(n^2)$ 搜过，但这是 CF 的题，所以我们坚信这一定是一道人类智慧题。所以我们充分发扬人类智慧，$O(n)$ 来构造这个题。</p>\n<p>对于只有 $0,1$ 的串来讲，一个序列想要不降其实只需要满足两个条件：</p>\n<ul>\n<li>如果当前位为 $0$，那么后面无论 $0,1$ 都是不降的；</li>\n<li>如果当前位为 $1$，那么后面为 $1$ 才是不降的。</li>\n</ul>\n<p>那么我们是不是很容易发现本题的构造原则：一个 $1$ 能够被替换成 $0$ <strong>当且仅当这个 $1$ 后面的 $1$ 的个数大于等于 $0$ 的个数</strong>。这个结论说出来很抽象，我们用一个例子来理解。</p>\n<pre><code>0 1 1 1 1 1 0 0 0\n1 2 3 4 5 6 7 8 9 \n</code></pre>\n<p>为了方便读者观看，这个串下面的数字是其下标。我们以下标为 $2$ 的这个下标的位置为例，$[2,9]$ 区间内的最长不降子序列是 <code>1 1 1 1 1</code>，这一位改成 $0$ 后变成 <code>0 1 1 1 1</code>，不管怎么变长度都不会变，因为其后 $1$ 比 $0$ 多，最长不降子序列一定是连着一坨 $1$。然而对于下标为 $4$ 这个位置的 $1$ 来讲，这一位后面的 $0$ 比 $1$ 多，我们将这一位换成 $0$ 后，$[4,9]$ 区间内的最长不降子序列从 <code>1 1 1</code> 变成了 <code>0 0 0 0</code>，不符合我们的构造条件。</p>\n<p>出现这种情况的原因是，对于当前位来讲，它的最长不降子序列只能是一堆 $1$，这是我们刚刚提到过的结论，改成 $0$ 后就有了三种选择，而我们必须让它别无选择，这就要求更改的这一位只能继续选后面连一堆 $1$，那么我们发现这种别无选择的情况就必须让当前位后的 $1$ 的数量比 $0$ 的数量多，这就证明了我们刚刚得出的结论，这道题也就做完了。</p>\n<p>在写代码的时候，我们可以把维护个数改成维护 $0$ 与 $1$ 的个数的差值，这样可以简化代码难度，当 $0$ 的个数减去 $1$ 的个数非正时就把这一位的 $1$ 换掉。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    string s;\n    int cnt;\n    int work()\n    &#123;\n        cin &gt;&gt; s;\n        for (int i = s.size() - 1; i &gt;= 0; --i) &#123;\n            if (s[i] == '0') &#123; ++cnt; &#125;\n            else if (s[i] == '1' &amp;&amp; cnt &lt;= 0) &#123; s[i] = '0'; &#125;\n            else &#123; --cnt; &#125;\n        &#125;\n        cout &lt;&lt; s &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/20/CF1204D2%20Kirk%20and%20a%20Binary%20String%20(hard%20version)/",
            "url": "http://example.com/2023/09/20/CF1204D2%20Kirk%20and%20a%20Binary%20String%20(hard%20version)/",
            "title": "题解 CF1204D2 Kirk and a Binary String (hard version)",
            "date_published": "2023-09-20T07:41:00.000Z",
            "content_html": "<h1>CF1204D2 Kirk and a Binary String (hard version)</h1>\n<h2 id=\"形式化题意\">形式化题意</h2>\n<p>给你一个长为 $n$ 的仅包含 $0$ 和 $1$ 的串，要求尽可能多地将里面的 $1$ 改成 $0$ 使得在得到的新串中，对于 $\\forall l,r\\in [1,n](l \\le r)$，两个串的 $[l,r]$ 区间内的最长不降子序列等长。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>题中给的数据范围是 $10^5$，我们很容易去思考一些 $O(n \\log n)$ 的做法，从而去找数据结构来维护，但这是 CF 的题，所以我们坚信这一定是一道人类智慧题。所以我们充分发扬人类智慧，$O(n)$ 来构造这个题。</p>\n<p>对于只有 $0,1$ 的串来讲，一个序列想要不降其实只需要满足两个条件：</p>\n<ul>\n<li>如果当前位为 $0$，那么后面无论 $0,1$ 都是不降的；</li>\n<li>如果当前位为 $1$，那么后面为 $1$ 才是不降的。</li>\n</ul>\n<p>那么我们是不是很容易发现本题的构造原则：一个 $1$ 能够被替换成 $0$ <strong>当且仅当这个 $1$ 后面的 $1$ 的个数大于等于 $0$ 的个数</strong>。这个结论说出来很抽象，我们用一个例子来理解。</p>\n<pre><code>0 1 1 1 1 1 0 0 0\n1 2 3 4 5 6 7 8 9 \n</code></pre>\n<p>为了方便读者观看，这个串下面的数字是其下标。我们以下标为 $2$ 的这个下标的位置为例，$[2,9]$ 区间内的最长不降子序列是 <code>1 1 1 1 1</code>，这一位改成 $0$ 后变成 <code>0 1 1 1 1</code>，不管怎么变长度都不会变，因为其后 $1$ 比 $0$ 多，最长不降子序列一定是连着一坨 $1$。然而对于下标为 $4$ 这个位置的 $1$ 来讲，这一位后面的 $0$ 比 $1$ 多，我们将这一位换成 $0$ 后，$[4,9]$ 区间内的最长不降子序列从 <code>1 1 1</code> 变成了 <code>0 0 0 0</code>，不符合我们的构造条件。</p>\n<p>出现这种情况的原因是，对于当前位来讲，它的最长不降子序列只能是一堆 $1$，这是我们刚刚提到过的结论，改成 $0$ 后就有了三种选择，而我们必须让它别无选择，这就要求更改的这一位只能继续选后面连一堆 $1$，那么我们发现这种别无选择的情况就必须让当前位后的 $1$ 的数量比 $0$ 的数量多，这就证明了我们刚刚得出的结论，这道题也就做完了。</p>\n<p>在写代码的时候，我们可以把维护个数改成维护 $0$ 与 $1$ 的个数的差值，这样可以简化代码难度，当 $0$ 的个数减去 $1$ 的个数非正时就把这一位的 $1$ 换掉。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    string s;\n    int cnt;\n    int work()\n    &#123;\n        cin &gt;&gt; s;\n        for (int i = s.size() - 1; i &gt;= 0; --i) &#123;\n            if (s[i] == '0') &#123; ++cnt; &#125;\n            else if (s[i] == '1' &amp;&amp; cnt &lt;= 0) &#123; s[i] = '0'; &#125;\n            else &#123; --cnt; &#125;\n        &#125;\n        cout &lt;&lt; s &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/13/CF1537E2%20Erase%20and%20Extend%20(Hard%20Version)/",
            "url": "http://example.com/2023/09/13/CF1537E2%20Erase%20and%20Extend%20(Hard%20Version)/",
            "title": "题解 CF1537E2 Erase and Extend (Hard Version)",
            "date_published": "2023-09-13T12:28:00.000Z",
            "content_html": "<h1>CF1537E2 Erase and Extend (Hard Version)</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一个字符串，找到该字符串的一个前缀并不断复制，可以删除末尾元素，最终要使得得到的字符串长度为 $k$ 且字典序最小。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>对于此类构造题，我们一般需要运用逆向思维，也就是说我们要从前往后扫而不是从后往前删。为什么这样想呢？我们可以发现，字典序最小当且仅当我们要找的前缀的第 $i$ 位比第 $i \\bmod len$ 位的字典序小，这样拼接起来才能够使得字典序最小，这个结论是显然的，证明可以使用反证法。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    int n, k, l = 1;\n    string s;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            if (s[i] &lt; s[i % l]) &#123; l = i + 1; &#125;\n            else if (s[i] &gt; s[i % l]) &#123; break; &#125;\n        &#125;\n        for (int i = 0; i &lt; k; ++i) &#123;\n            cout &lt;&lt; s[i % l];\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/13/CF1537E1%20Erase%20and%20Extend%20(Easy%20Version)/",
            "url": "http://example.com/2023/09/13/CF1537E1%20Erase%20and%20Extend%20(Easy%20Version)/",
            "title": "题解 CF1537E1 Erase and Extend (Easy Version)",
            "date_published": "2023-09-13T03:42:00.000Z",
            "content_html": "<h1>CF1537E1 Erase and Extend (Easy Version)</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一个字符串，找到该字符串的一个前缀并不断复制，可以删除末尾元素，最终要使得得到的字符串长度为 $k$ 且字典序最小。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>对于此类构造题，我们一般需要运用逆向思维，也就是说我们要从前往后扫而不是从后往前删。为什么这样想呢？我们可以发现，字典序最小当且仅当我们要找的前缀的第 $i$ 位比第 $i \\bmod len$ 位的字典序小 ，这样拼接起来才能够使得字典序最小，这个结论是显然的，证明可以使用反证法。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    int n, k, l = 1;\n    string s;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            if (s[i] &lt; s[i % l]) &#123; l = i + 1; &#125;\n            else if (s[i] &gt; s[i % l]) &#123; break; &#125;\n        &#125;\n        for (int i = 0; i &lt; k; ++i) &#123;\n            cout &lt;&lt; s[i % l];\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/31/CF1863C%20MEX%20Repetition/",
            "url": "http://example.com/2023/08/31/CF1863C%20MEX%20Repetition/",
            "title": "题解 CF1863C MEX Repetition",
            "date_published": "2023-08-31T01:18:00.000Z",
            "content_html": "<h1>CF1863C MEX Repetition</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个 $n$ 个元素的序列 $a$，其中的元素由小于等于 $n$ 的自然数构成且元素之间两两不同。现在定义一种操作，该操作会将第 $i$ 个位置的元素 $a_i$ 替换为该序列中当前没有的最小自然 数。每一轮操作都会从 $1$ 位置一直替换到 $n$。给定整数 $n,k$ 和序列 $a$，其中 $k$ 表示要进行 $k$ 轮操作，要求输出操作后的序列。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>题目中其实有一个诈骗条件。因为序列中的 $n$ 个元素包含小于等于 $n$ 的自然数且两两相同，所以我们可以发现，如果把原序列增加 $1$ 个元素，那么这个序列就变成了 $0 \\sim n$ 的一个排列。而我们要替换用的那个数其实就是原序列中没有出现的那个数。我们发现，每当我们替换了一个数字，那么我们必然要用替换下来的这个数字去替换下一个数字，因为被替换下来的这个数字变成了当前序列中缺少的那个数。我们将最开始序列中缺少的那个数放在第 $n + 1$ 个位置。然后我们就可以显然地发现，每次操作实质上就是用第 $i$ 个位置的元素去替换第 $i+1$ 个位置的元素，推广到递推形式就是：</p>\n$$\\displaylines{a_{(i+1) \\operatorname{mod} (n+1)}= a_{i \\operatorname{mod}(n+1)}\n}$$<p>现在我们就知道了替换的方法，但是如果我们按照这个递推式进行模拟显然是行不通的，所以我们需要对这个做法进行优化。我们发现，每一轮操作结束后，都相当于把这个序列滚动一次，我们以下面的输入为例：</p>\n<pre><code>5 5\n1 2 3 4 5\n</code></pre>\n<p>我们把没有出现的元素放在第 $n+1$ 个位置，然后我们每次进行一轮操作并记下来：</p>\n<pre><code>1 2 3 4 5 0\n0 1 2 3 4 5\n5 0 1 2 3 4\n4 5 0 1 2 3\n3 4 5 0 1 2 \n2 3 4 5 0 1\n1 2 3 4 5 0\n</code></pre>\n<p>于是我们就发现了，这种操作具有循环节，每一轮循环次数等于 $n+1$。原序列的元素顺序也没有太大的改变，所以我们就可以先确认没有第一次操作前没有出现的那个元素的位置，不难发现这个元素的位置等于 $k \\operatorname{mod} (n+1)$。那么我们就可以直接做了。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e5 + 7;\n    int a[N];\n    bool chk[N];\n    int T, n, k;\n    int work()\n    &#123;\n        cin &gt;&gt; T;\n        while (T--) &#123;\n            cin &gt;&gt; n &gt;&gt; k;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                cin &gt;&gt; a[i];    \n                chk[a[i]] = true;\n            &#125;\n            int fir;\n            for (int i = 0; i &lt;= n; ++i) &#123;\n            // 不想写二分了所以直接 O(n) 查\n                if (!chk[i]) &#123;\n                    fir = i;\n                    break;\n                &#125;\n            &#125;\n            a[++n] = fir;\n            int xh = k % n, cnt = n - 1;\n            int idx = n - xh + 1;\n            while (cnt--) &#123;\n                if (idx &gt; n) &#123; idx = 1; &#125;\n                cout &lt;&lt; a[idx++] &lt;&lt; ' ';\n            &#125;\n            cout &lt;&lt; '\\n';\n            memset(chk, 0, sizeof(chk));\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/21/P9570%20%E3%80%8CNnOI%20R2-T2%E3%80%8DGlaciaxion/",
            "url": "http://example.com/2023/08/21/P9570%20%E3%80%8CNnOI%20R2-T2%E3%80%8DGlaciaxion/",
            "title": "题解 洛谷 P9570 「NnOI R2-T2」Glaciaxion",
            "date_published": "2023-08-21T02:23:00.000Z",
            "content_html": "<h1>洛谷 P9570 「NnOI R2-T2」Glaciaxion</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个数 $n$ 和 $m$ 表示有从 $1$ ~ $n$ 的正整数和 $m$ 次操作。每次操作给出一个字母 <code>N</code> 或 <code>Y</code>，如果给出 <code>N</code> 说明有一个数字第一次被选中并输出，如果给出 <code>Y</code> 就要从刚刚选出来的数里再选一个输出出来。现在要求若干输出里字典序最小的序列，如果无解输出 <code>No solution</code>。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<h3 id=\"无解情况\">无解情况</h3>\n<ul>\n<li>当给出 <code>N</code> 的次数超过 $n$ 时不合法，因为每个数第一次出现的次数总和至多为 $n$。</li>\n<li>当还没有给出 <code>N</code> 就给出 <code>Y</code> 时不合法，因为 <code>Y</code> 不能选出以前没有选出来的数。</li>\n<li>$n$ 或 $m$ 等于 $0$ 的时候不合法</li>\n</ul>\n<h3 id=\"构造\">构造</h3>\n<p>下面的分析基于所有合法条件。我们要求最后输出序列字典序最小，所以我们考虑建立一个从 $1$ 开始的指针，当出现 <code>N</code> 时输出指针，然后指针移动到下一个数。给出 <code>Y</code> 前一定给出了 <code>N</code>，而第一次给出 <code>N</code> 时我们选出的数一定是 $1$，因为它的字典序最小。而既然已经选出来了，后面每一次 <code>Y</code> 我们都要在已经选出的数里选一个最小的，那么我们选出来的数必然是 $1$。所以我们只需要在输入 <code>N</code> 的时候输出递增的那个指针并将其自增，输入 <code>Y</code> 的时候输出 $1$ 就可以了。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    int n, m, idx, ncnt, ycnt;\n    // ncnt用来记录N的数量，ycnt记录Y的数量\n    string s;\n    vector&lt;int&gt; ans;// 用来记录答案\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        cin &gt;&gt; s;\n        if (!n || !m) &#123; cout &lt;&lt; &quot;No solution\\n&quot;; return 0; &#125;\n        // n或m为0无解\n        for (int i = 0; i &lt; m; ++i) &#123;\n            if (s[i] == 'N') &#123;\n                ++idx;// 指针自增\n                ++ncnt;\n                ans.emplace_back(idx);// 将指针放入答案序列\n            &#125;\n            else if (s[i] == 'Y') &#123;\n                ++ycnt;\n                ans.emplace_back(1);// 输入Y一定输出1\n            &#125;\n            if (ncnt == 0 &amp;&amp; ycnt) &#123; cout &lt;&lt; &quot;No solution\\n&quot;; return 0; &#125;\n            // 还没输入N就输入了Y无解\n        &#125;\n        if (ncnt &gt; n) &#123; cout &lt;&lt; &quot;No solution\\n&quot;; return 0; &#125;\n        // 输入N的数量大于n无解\n        for (auto it : ans) &#123; cout &lt;&lt; it &lt;&lt; ' '; &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/19/CF1413C%20Perform%20Easily/",
            "url": "http://example.com/2023/08/19/CF1413C%20Perform%20Easily/",
            "title": "题解 CF1413C Perform Easily",
            "date_published": "2023-08-19T15:18:00.000Z",
            "content_html": "<h1>题解 CF1413C Perform Easily</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个含有 $6$ 个元素的可重集 $a$，一个数 $n$ 和一个含有 $n$ 个数的可重集 $b$，现在要求 $b$ 中每个数和 $a$ 中任意一个数作差使得作差后得到的新的集合 $b$ 中最大的数和最小的数的差最小。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>首先考虑暴力，每个数最后的值都有 $6$ 种可能，所以总可能数有 $6^n$ 种，显然不行。题目中 $n$ 的大小为 $10^5$，所以我们期待一个 $O(n\\log n)$ 的做法。我们发现，所有数也只有 $6$ 种可能，想要枚举答案不可能，但我们可以枚举结果。于是我们想到把 $b$ 中每个元素都和 $a$ 中所有元素作差，最后得到 $6n$ 个数放入一个新的数组 $cp$。因为我们要考虑最大和最小的差最小，所以我们需要使 $cp$ 数组中的值变得有序，于是我们对其进行排序。排序后为了查找的时候保证查找的区间内的数必须包含原来 $b$ 中每个数的至少一种差（显然其每个数都有 $6$ 种差），我们要在插入 $cp$ 前给每个数打好标记，标记它来自于哪个数。</p>\n<p>预处理做完后，我们考虑如何查找答案。因为我们需要一个区间最大值，还需要一个区间最小值，所以我们想到了用双指针来进行查找。我们设左指针为 $lidx$，右指针为 $ridx$。$ridx$ 先走，一直走到与 $lidx$ 间包含了的数包含了原来 $b$ 中每个数的至少一个结果为止。现在开始移动左指针，每移动一次就 $ridx$ 与 $lidx$ 所指的两数之差更新答案。当两指针之间包含的数不能包含原来 $b$ 中每个数的至少一个结果时，就回到第一步重新开始移动 $ridx$，循环一轮即可得到答案。</p>\n<p>枚举复杂度为 $O(n)$，排序复杂度为 $O(n\\log n)$，最后搜索的复杂度为 $O(n)$，所以整个算法的时间复杂度为 $O(n\\log n)$，于是我们做完了，下面是代码。</p>\n<h3 id=\"参考代码\">参考代码</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7, INF = 1e9;\n    struct node &#123; int val, id; &#125;cp[N];\n    int n, idx, ans = INF;\n    int a[7], b[N], cnt[N];\n    bool cmp(node x, node y) &#123; return x.val &lt; y.val; &#125;\n    int work()\n    &#123;\n        for (int i = 1; i &lt;= 6; ++i) &#123; cin &gt;&gt; a[i]; &#125;\n        cin &gt;&gt; n;\n        if (n == 1) &#123; cout &lt;&lt; &quot;0\\n&quot;; return 0; &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            cin &gt;&gt; b[i];\n            for (int j = 1; j &lt;= 6; ++j) &#123;\n                cp[++idx] = &#123;b[i] - a[j], i&#125;;\n            &#125;\n            cnt[i] = 0;\n        &#125;// 加标记\n        sort(cp + 1, cp + idx + 1, cmp);\n        int lidx = 1, ridx = 0, ncnt = 0;\n        // cnt数组和ncnt用来维护当前区间包含原来b数组中的数的结果的个数\n        while (ridx &lt; idx) &#123;\n            // 双指针搜索\n            if (!cnt[cp[++ridx].id]) &#123; ++ncnt; &#125;\n            ++cnt[cp[ridx].id];\n            while (lidx &lt; ridx &amp;&amp; cp[ridx].val - cp[lidx].val &gt;= ans) &#123;\n                if (cnt[cp[lidx].id] == 1) &#123; --ncnt; &#125;\n                --cnt[cp[lidx].id];\n                ++lidx;\n            &#125;\n            // 移动左指针到可行方案处\n            while (lidx &lt; ridx &amp;&amp; ncnt == n) &#123;\n                ans = min(ans, cp[ridx].val - cp[lidx].val);\n                if (cnt[cp[lidx].id] == 1) &#123; --ncnt; &#125;\n                --cnt[cp[lidx].id];\n                ++lidx;\n            &#125; \n            // 移动左指针并不断更新答案\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/AT_arc132_a%20Permutation%20Grid/",
            "url": "http://example.com/2023/08/18/AT_arc132_a%20Permutation%20Grid/",
            "title": "题解 AT_arc132_a Permutation Grid",
            "date_published": "2023-08-18T09:03:00.000Z",
            "content_html": "<h1>题解  AT_arc132_a Permutation Grid</h1>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>给定两个数列 $R$ 和 $C$ ，$R$ 和 $C$ 内均有 $n$ 个元素，要求根据 $R$ 和 $C$ 对一个 $n\\times n$ 的矩阵进行染色，使得第 $i$ 行有 $R_i$ 个黑色块，第 $j$ 列有 $C_j$ 个黑色块。<strong>最后，$R$ 和 $C$ 均为 $1-n$ 的一个排列。</strong></p>\n<h4 id=\"反思分析：\"><s>反思</s>分析：</h4>\n<p><s>有个伸臂和一个神犇在赛时没有看到最后一个条件导致两个人想出了各种各样复杂又奇葩的做法，我不说是谁</s></p>\n<p>有了排列那这不成水题了，我们以样例为例（这什么话）把它按顺序重新排列一下，就会变成这样（我们用$W$表示白色，$B$表示黑色）：</p>\n<p>$R=5,2,3,4,1\\Rightarrow R=1,2,3,4,5$</p>\n<p>$C=4,2,3,1,5\\Rightarrow C=1,2,3,4,5$</p>\n<p>$\n\\begin{matrix}\n   &amp; 1&amp;  2&amp;  3&amp;  4&amp; 5&amp;\\\\\n  1&amp;  W&amp;  W&amp;  W&amp;  W&amp; B\\\\\n  2&amp;  W&amp;  W&amp;  W&amp;  B&amp; B\\\\\n  3&amp;  W&amp;  W&amp;  B&amp;  B&amp; B\\\\\n  4&amp;  W&amp;  B&amp;  B&amp;  B&amp; B\\\\\n  5&amp;  B&amp;  B&amp;  B&amp;  B&amp; B\n\\end{matrix}\n$</p>\n<p>我们稍加观察，然后<strong>惊奇地</strong>发现，坐标为$x,y$的块是黑色当且仅当$R_x+C_y&gt;n$，然后我们恢复原序列<br>\n$\n\\begin{matrix}\n   &amp; 4&amp;  2&amp;  3&amp;  1&amp; 5&amp;\\\\\n  5&amp;  B&amp;  B&amp;  B&amp;  B&amp; B\\\\\n  2&amp;  B&amp;  W&amp;  W&amp;  W&amp; B\\\\\n  3&amp;  B&amp;  W&amp;  B&amp;  W&amp; B\\\\\n  4&amp;  B&amp;  B&amp;  B&amp;  W&amp; B\\\\\n  1&amp;  W&amp;  W&amp;  W&amp;  W&amp; B\n\\end{matrix}\n$<br>\n发现这个性质仍然存在！</p>\n<p>我们可以通过简单地平移来证明这种做法的正确性，而代码也就相应的非常好写了：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e5 + 7;\n    int r[N],c[N];\n    int n, q;\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; r[i]; &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; c[i]; &#125;\n        cin &gt;&gt; q;\n        for (int i = 1, x, y; i &lt;= q; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            if (r[x] + c[y] &gt; n) &#123; cout &lt;&lt; '#'; &#125;\n            else &#123; cout &lt;&lt; '.'; &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/CF1413D%20Shurikens/",
            "url": "http://example.com/2023/08/18/CF1413D%20Shurikens/",
            "title": "题解 CF1413D Shurikens",
            "date_published": "2023-08-18T03:15:00.000Z",
            "content_html": "<h1>题解 CF1413D Shurikens</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个 $n$ 和 $2n$ 个操作，第一种操作 “+” 表示从 $1$ ~ $n$ 中选择一个数插入序列，第二种操作 &quot; - $x$&quot; 表示从当前序列中删除 $x$ 且 $x$ 为当前序列里的最小值，根据给出的操作来推断将数插入序列的合法顺序。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<h3 id=\"不合法情况\">不合法情况</h3>\n<p>不合法的情况有两种。第一种是当在连续取出的两个值中，后取出的值比前取出的值小，因为每次必须取出序列里最小的值，所以这种情况显然是不符合要求的。第二种情况是取出的操作数比放入的操作数多，这样显然也是不合法的。</p>\n<h3 id=\"如何处理合法情况\">如何处理合法情况</h3>\n<p>我们看到这种有进有出的结构能够想到什么，怎么才能反转操作呢？我们很自然地想到可以用栈来实现。我们倒着进行操作，遇到取数操作就把取出来的数压入栈 $s$，遇到插入操作就把 $s$ 栈顶元素弹出来塞进另一个栈 $ans$ 里，最后把 $ans$ 里的元素依次弹出就是答案所要的序列了。按照刚刚讨论过的不合法情况，当 $s$ 中入栈元素比栈顶元素大则不合法，如果需要弹出时栈 $s$ 为空则不合法。</p>\n<h3 id=\"正确性证明\">正确性证明</h3>\n<p>因为每次都要取序列中的最小值，所以后出来的元素一定是更大的，我们就默认它插入得更早。而倒序插入的时候保证了小的元素一定后进栈，所以也不会出现弹出一个数时它还没插入的情况。当 $s$ 入栈元素大于栈顶元素，就相当于操作时取出的值不是最小值；而当弹栈时栈空了，就说明插入的数量少于取出的数量，刚好就对应上了上面分析的不合法情况。由此就可以判断出其正确性。</p>\n<h2 id=\"实现\">实现</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    stack&lt;int&gt; s;\n    stack&lt;int&gt; ans;\n    vector&lt;int&gt; opt;// 记录操作\n    int n;\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n            char op; int x;\n            cin &gt;&gt; op;\n            if (op == '+') &#123; opt.emplace_back(0); &#125;\n            else if(op == '-') &#123; cin &gt;&gt; x; opt.emplace_back(x); &#125;\n        &#125;\n        for (int i = opt.size() - 1; i &gt;= 0; --i) &#123;\n            // 倒着复现操作\n            if (!opt[i]) &#123;\n                if (s.empty()) &#123; cout &lt;&lt; &quot;NO\\n&quot;; return 0; &#125;\n                // 插入的数量少于取出的数量\n                else &#123; ans.push(s.top()); s.pop(); &#125;\n            &#125;\n            else &#123;\n                if (s.size() &amp;&amp; opt[i] &gt; s.top()) &#123; cout &lt;&lt; &quot;NO\\n&quot;; return 0; &#125;\n                // 操作时取出的值不是最小值\n                else &#123; s.push(opt[i]); &#125;\n            &#125;\n        &#125;\n        cout &lt;&lt; &quot;YES\\n&quot;; \n        while (!ans.empty()) &#123; cout &lt;&lt; ans.top() &lt;&lt; ' '; ans.pop(); &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/P3514%20[POI2011]%20LIZ-Lollipop/",
            "url": "http://example.com/2023/08/18/P3514%20[POI2011]%20LIZ-Lollipop/",
            "title": "题解 洛谷 P3514 [POI2011] LIZ-Lollipop",
            "date_published": "2023-08-18T03:15:00.000Z",
            "content_html": "<h1>P3514 [POI2011] LIZ-Lollipop</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个只有 $1$ 和 $2$ 的序列，给出 $m$ 次询问，每次询问给出一个数 $k$，查询序列中有没有一个子串和为 $k$，如果有则输出区间两端点，如果没有输出 <code>NIE</code>。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>本题最重要的条件就是该序列中只含有 $1$ 和 $2$，因为这个条件，我们就可以得到下面这个性质：<strong>若 $k$ 可以被表示，则 $k-2$ 也一定可以被表示</strong>。这个性质很容易被证明。我们很容易发现，一个区间的两端点有三种情况，全为 $1$，全为 $2$ 以及一边 $1$ 一边 $2$。那么当两边存在 $2$ 时，只需要减掉这个 $2$ 即可；如果是两个 $1$，那么把这两个 $1$ 一起减掉即可。</p>\n<p>现在我们知道了上面这个性质，开始考虑非法情况。既然 $k-2$ 可以被表示，那么我们只需要找到最大的 $k$ 就可以了。如果给出的 $k$ 比我们能找到的最大的数还大，那么这个数是不合法的。</p>\n<p>考虑完非法情况以后，我们来考虑如何求解。我们发现，一个数减去 $2$ 后奇偶性不变，也就是说如果 $k$ 是奇数，那么我们将永远无法得到偶数，反之亦然，所以这要求我们分类讨论，分别求出最大的奇数和最大的偶数。因为题目告诉我们序列长度 $n \\le 10^6$，也就是说能够被表示出来的数最多有 $2 \\times 10^6$ 种。我们可以提前将这些数的左右区间都预处理出来，然后 $O(1)$ 查询即可。处理这些数的方法是将最大的奇数和偶数分别缩减，每次缩减 $2$ 并记下左右区间，按照最开始分析的性质来移动左右指针，知道两指针相遇为止。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    int a[N];\n    int n, m, jmax, omax, sum;\n    struct node &#123; int l, r; &#125;b[N &lt;&lt; 1];\n    \n    inline void _init() &#123;\n        int jlidx, jridx, olidx, oridx, tmp1, tmp2, tag1, tag2;\n        jlidx = olidx = 1; jridx = oridx = n; tmp1 = tmp2 = 0;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            tmp1 += a[i];\n            if (a[i] == 1) &#123; tag1 = i + 1; break; &#125;\n        &#125;\n        for (int  i = n; i &gt;= 1; --i) &#123;\n            tmp2 += a[i];\n            if (a[i] == 1) &#123; tag2 = i - 1; break; &#125;\n        &#125;\n        if (sum % 2) &#123;\n            jmax = sum;\n            if (tmp1 &lt; tmp2) &#123;\n                omax = sum - tmp1;\n                olidx = tag1;\n            &#125;\n            else &#123;\n                omax = sum - tmp2;\n                oridx = tag2;\n            &#125;\n        &#125;\n        else &#123;\n            omax = sum;\n            if (tmp1 &lt; tmp2) &#123;\n                jmax = sum - tmp1;\n                jlidx = tag1; \n            &#125;\n            else &#123;\n                jmax = sum - tmp2;\n                jridx = tag2;\n            &#125;\n        &#125;\n        \n        //----以上处理最大的奇数和偶数以及其左右端点----\n        //----以下分别缩减奇偶数得到所有数的左右端点----\n        \n        int otmp = omax, jtmp = jmax;\n        b[omax] = &#123;olidx, oridx&#125;;\n        b[jmax] = &#123;jlidx, jridx&#125;; \n        while (olidx &lt; oridx &amp;&amp; otmp &gt; 0) &#123;\n            otmp -= 2;\n            if (a[olidx] == 1) &#123;\n                if (a[oridx] == 1) &#123; b[otmp] = &#123;++olidx, --oridx&#125;; &#125;\n                else if (a[oridx] == 2) &#123; b[otmp] = &#123;olidx, --oridx&#125;; &#125;\n            &#125;\n            else if (a[olidx] == 2) &#123; b[otmp] = &#123;++olidx, oridx&#125;; &#125;\n        &#125;\n        while (jlidx &lt; jridx &amp;&amp; jtmp &gt; 0) &#123;\n            jtmp -= 2;\n            if (a[jlidx] == 1) &#123;\n                if (a[jridx] == 1) &#123; b[jtmp] = &#123;++jlidx, --jridx&#125;; &#125;\n                else if (a[jridx] == 2) &#123; b[jtmp] = &#123;jlidx, --jridx&#125;; &#125;\n            &#125;\n            else if (a[jlidx] == 2) &#123; b[jtmp] = &#123;++jlidx, jridx&#125;; &#125;\n        &#125;\n        return;\n    &#125;\n    \n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char c; cin &gt;&gt; c;\n            if (c == 'T') &#123; a[i] = 2; &#125;\n            else if (c == 'W') &#123; a[i] = 1; &#125;\n            sum += a[i];\n        &#125;\n        _init();\n        while (m--) &#123;\n            int sar; cin &gt;&gt; sar;\n            if (sar % 2 &amp;&amp; sar &gt; jmax) &#123; cout &lt;&lt; &quot;NIE\\n&quot;; continue; &#125;\n            else if (!(sar % 2) &amp;&amp; sar &gt; omax) &#123; cout &lt;&lt; &quot;NIE\\n&quot;; continue; &#125;\n            cout &lt;&lt; b[sar].l &lt;&lt; ' ' &lt;&lt; b[sar].r &lt;&lt; '\\n';\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        }
    ]
}