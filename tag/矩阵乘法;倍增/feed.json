{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"矩阵乘法;倍增\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/18/UVA11149%20Power%20of%20Matrix/",
            "url": "http://example.com/2023/08/18/UVA11149%20Power%20of%20Matrix/",
            "title": "题解 UVA11149 Power of Matrix",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>题解 UVA11149 Power of Matrix</h1>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>给定一个 $n \\times n$ 的矩阵 $A$ 和一个数 $k$，求 $\\sum_{i = 1}^{k}A^i $。</p>\n<h3 id=\"法一：暴力求解，单次时间复杂度-O-n-3k\">法一：暴力求解，单次时间复杂度 $O(n^3k)$</h3>\n<h3 id=\"法二：分治，单次时间复杂度-O-n-3log-2k\">法二：分治，单次时间复杂度 $O(n^3log^2k)$</h3>\n<p>我们可以按照分治的定义照猫画虎，将原式变成这样：</p>\n$$\\displaylines{A+A^2+A^3+A^4+\\ldots+A^K = (A+A^2+A^3+\\ldots+A^{\\frac{k}{2}})+A^{\\frac{k}{2}}(A+A^2+A^3+\\ldots+A^{\\frac{k}{2}})\n}$$<p>然后递归处理即可，分治部分的代码大概长这样：</p>\n<pre><code class=\"language-cpp\">mat solve(mat bas, LL pos) &#123; \\\\bas是原矩阵，pos代表当前k的大小\n    if (pos == 1) &#123; return bas; &#125;\n    mat s; clear(s);\n    for (int i = 0; i &lt; n; ++i) &#123; s.m[i][i] = 1; &#125;\n    s = (s + qpow(bas, pos &gt;&gt; 1)) * solve(bas, pos &gt;&gt; 1);\n    if (pos &amp; 1) &#123; s = s + qpow(bas, pos); &#125;\n    return s;\n&#125;\n</code></pre>\n<p>于是我们惊喜的发现，这种做法又慢又不稳定，所以我们考虑法三。</p>\n<h3 id=\"法三：倍增，单次时间复杂度-O-n-3logk\">法三：倍增，单次时间复杂度 $O(n^3logk)$</h3>\n<p>我们观察要求的这个式子，发现 $i$ 要枚举到 $k$ 非常慢，那么我们就想办法优化这个枚举的过程，也就是对 $i$ 进行倍增，则有：</p>\n$$\\displaylines{\\sum_{i=0}^{log_2k} A^{2^i}(\\sum_{j=1}^{2^i} A^j)\n}$$<p>我们显然不能每次都从头到尾加一遍，所以我们用两个数组 $f$ 和 $s$对这个式子进行递推。</p>\n$$\\displaylines{f_i=A^{2^i},s_i=\\sum_{j=1}^{2^i}A^j\n}$$<p>不难发现在递推 $f_i$ 时只要每次把 $f_{i-1}$ 平方就可以了，而 $s_i$ 略微复杂一些，求它其实很像刚刚分治的做法，即 $s_i=s_{i-1}+f_{i-1} \\times s_{i-1}$。</p>\n<p>如果题目高速我们 $k$ 保证是 2 的若干次幂，那么这个题已经做完了，但很遗憾我们没有这个条件，所以还要想办法处理剩余的部分。<strong>本过程较为复杂，建议多看几遍。</strong> 我们知道整数的一个重要性质就是可以将其拆解为若干 2 的幂之和，假设我们的 $i$ 最后枚举到了 $m$ 使得 $2^m &gt; k$ 且 $2^{m-1} &lt; k$，那么此时我们就想要拆解 $k-2^{m-1}$ 这一部分，那么显然我们最简单的方法是从 $m-1$ 开始向下枚举，设循环变量为 $i$，当枚举到一个 $i$ 使得 $2^{m-1}+2^i&lt;k$ 的时候，就从刚刚处理出来的两个数组中取出第 $i$ 项加到答案里就可以了。这样枚举到 $s^{m-1}+2^i=k$ 时说明我们已经完成对答案的处理，输出答案就可以了。</p>\n<p>下面是参考代码（倍增过程在 $\\operatorname{solve}$ 函数部分）：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#define clear(q) memset(q.m, 0, sizeof(q.m))\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    LL n, k;\n    const int N = 41, M = 64, mod = 10;\n    struct mat &#123; LL m[N][N]; &#125;;\n    mat f[M], s[M];\n    mat operator* (const mat &amp;x, const mat &amp;y) &#123;\n        mat ans;\n        clear(ans);\n        for (int i = 0; i &lt; n; ++i) &#123;\n            for (int k = 0; k &lt; n; ++k) &#123;\n                if (x.m[i][k]) &#123;\n                    for (int j = 0; j &lt; n; ++j) &#123;\n                        ans.m[i][j] = (ans.m[i][j] % mod + (x.m[i][k] * y.m[k][j]) % mod) % mod;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n    mat operator+ (const mat &amp;x, const mat &amp;y) &#123;\n        mat ans;\n        clear(ans);\n        for (int i = 0; i &lt; n; ++i) &#123;\n            for (int j = 0; j &lt; n; ++j) &#123;\n                ans.m[i][j] = (x.m[i][j] + y.m[i][j]) % mod;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n    mat qpow(mat a, LL b) &#123;\n        mat z;\n        clear(z);\n        for (int i = 0; i &lt; n; ++i) &#123; z.m[i][i] = 1; &#125;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            if (b &amp; 1) &#123; z = z * a; &#125;\n            a = a * a; b &gt;&gt;= 1;\n        &#125;\n        return z;\n    &#125;\n    void output(mat o) &#123;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            for (int j = 0; j &lt; n; ++j) &#123;\n                cout &lt;&lt; o.m[i][j] % mod;\n                if (j != n - 1) &#123; cout &lt;&lt; ' '; &#125;\n            &#125;\n            cout &lt;&lt; '\\n'; \n        &#125; \n        cout &lt;&lt; '\\n';\n    &#125;\n    void solve() &#123;\n        LL pos = 2, p = 1; // pos用来枚举2的次幂，p用来枚举2的幂次，pos的指数即为p，二者同加同减\n        while (pos &lt;= k) &#123;\n            f[p] = f[p - 1] * f[p - 1];\n            s[p] = s[p - 1] + s[p - 1] * f[p - 1];\n            pos &lt;&lt;= 1; ++p;\n        &#125;\n        pos &gt;&gt;= 1; --p; // 第一次枚举完后肯定会超出k的范围，所以取上一次枚举到的幂\n        LL posback = pos; // posback表示拆分剩余的数时需要用到的2的次幂\n        mat po = f[p], ans = s[p]; // po表示当前已经枚举到的幂次，ans为答案，初始值为第一次枚举时枚举到最大的值\n        for (int i = p; i &gt;= 0; --i) &#123;\n            if (pos + posback &lt;= k) &#123; \n                ans = ans + po * s[i]; // 加到答案里\n                posback += pos;\n                po = po * f[i];\n            &#125;\n            pos &gt;&gt;= 1; // pos的幂次要和p同步减一\n        &#125;\n        output(ans); // 处理完输出\n    &#125;\n    int work()\n    &#123;\n        while (cin &gt;&gt; n &gt;&gt; k &amp;&amp; n &amp;&amp; k) &#123;\n            for (int i = 0; i &lt; n; ++i) &#123;\n                for (int j = 0; j &lt; n; ++j) &#123;\n                    cin &gt;&gt; s[0].m[i][j];\n                    f[0].m[i][j] = s[0].m[i][j] = s[0].m[i][j] % mod; \n                &#125;\n            &#125;\n            solve();\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n<p><strong>ps. 特别提醒，UVa要注意输入和输出格式</strong></p>\n",
            "tags": [
                "矩阵乘法;倍增"
            ]
        }
    ]
}