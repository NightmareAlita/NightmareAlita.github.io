{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"对顶堆;数据结构\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/18/P1168%20%E4%B8%AD%E4%BD%8D%E6%95%B0/",
            "url": "http://example.com/2023/08/18/P1168%20%E4%B8%AD%E4%BD%8D%E6%95%B0/",
            "title": "题解 洛谷 P1168 中位数",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>题解 洛谷 P1168 中位数</h1>\n<p>由于这道题目比较水，所以机房中诞生了四种做法，分别是权值线段树、堆、二分以及 $\\operatorname{multiset}$。</p>\n<h3 id=\"这里主要介绍本题的堆解法\">这里主要介绍本题的堆解法</h3>\n<p>通过读题我们可以轻易发现，每两次插入数据就需要进行一次访问，且期间必须维护当前访问过的所有元素组成的数列具有单调性 。</p>\n<h4 id=\"问题一：如何维护数列的单调性\">问题一：如何维护数列的单调性</h4>\n<p>于是我们很容易想到可以使用优先队列对其插入的数字进行动态排序来维护其单调性。如果你不知道什么是优先队列，那么不妨先通过下面的传送门去看一看优先队列的用法：<br>\n<a href=\"https://blog.csdn.net/weixin_36888577/article/details/79937886?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167776821716800184138808%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167776821716800184138808&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79937886-null-null.142%5Ev73%5Epc_search_v2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&amp;spm=1018.2226.3001.4187\">点我</a></p>\n<p>于是你现在明白了什么是优先队列，我们只需要在维护好的单调队列里取出中位数就可以了。所以此时你发现，由于单调队列是一个队列，想要访问中间的元素，就只能把它前面的元素全部弹出来，这样弹出一遍插入一遍甚至不如每次 sort 时间效率高，于是问题来了。</p>\n<h4 id=\"问题二：如何快速地在每次访问中提取中位数\">问题二：如何快速地在每次访问中提取中位数</h4>\n<p>既然我们一定需要把队列分成两段，那么我们直接定义两个优先队列就可以完美地解决问题。我们将前奇数个（这里假设为前 $\\mathit{K}$  个）数列切分后扔进左队列、右队列和中位数三种位置，那么左边的队列维护第 $ 1 $ ~ $\\left[\\frac{K}{2}\\right]$ 个元素，右边的队列维护第 $(\\left[\\frac{K}{2}\\right]+2)$ ~ $K$ 个元素，第$(\\left[\\frac{K}{2}\\right]+1)$ 个元素也就是剩下的那个元素就是中位数，将其定义为 mid 。左边的队列从大到小，使用大根堆，右边的队列从小到大，使用小根堆，定义如下：</p>\n<pre><code class=\"language-cpp\">typedef long long LL;\npriority_queue&lt;LL,vector&lt;LL&gt;,greater&lt;LL&gt; &gt; Right;\npriority_queue&lt;LL,vector&lt;LL&gt;,less&lt;LL&gt; &gt; Left;\nLL mid;\n</code></pre>\n<p>接下来在每个奇数次插入时，如果插入的数比 mid 小，就塞进左队列，如果比 mid 大，就塞进右队列。<strong>需要注意的是：为了确保 mid 就是中位数，必须在每次访问时对两个队列内的元素个数进行平衡！</strong> 所以这是最后一个问题。</p>\n<h4 id=\"问题三：平衡两个队列内的元素个数\">问题三：平衡两个队列内的元素个数</h4>\n<p>我们不妨设其中一个队列元素个数为 $x$ ，另一个队列元素个数为 $y$，设 $x&gt;y$ ，则从 $x$ 队列中转移到 $y$ 队列中的元素个数为 $(\\frac{x-y}{2}-1)$ 个，最后只需要把 mid 插入到 $y$ 中，再将 $x$ 的队头元素弹出来更新为新的 mid 即可。<strong>注意：这一步操作必须先进行当前步骤的插入再进行元素个数平衡</strong>。</p>\n<p>至此，我们已经解决了这个题目的所有小问题，下面是AC代码：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\nusing namespace std;\n\nnamespace SHAWN&#123;\n    //定义部分不解释\n\ttypedef long long LL;\n\tpriority_queue&lt;LL,vector&lt;LL&gt;,greater&lt;LL&gt; &gt; Right;\n\tpriority_queue&lt;LL,vector&lt;LL&gt;,less&lt;LL&gt; &gt; Left;\n\tLL n,mid=0;\n\n\tint main()\n\t&#123;\n\t\tcin&gt;&gt;n;//读入n并进行n次插入\n\t\tfor(LL i=1,x;i&lt;=n;i++)&#123;\n\t\t\tcin&gt;&gt;x;\n\t\t\tif(i==1)&#123;//i=1的情况边界易出错，所以做一个特判\n\t\t\t\tmid=x;\n\t\t\t\tcout&lt;&lt;mid&lt;&lt;&quot;\\n&quot;;\n\t\t\t\tcontinue;\n\t\t\t&#125;\n\t\t\tif(x&lt;=mid) Left.push(x);\n\t\t\telse if(x&gt;mid) Right.push(x);\n\t\t\tif(i&amp;1)&#123;//当插入次数为奇数时进行一次平衡和查询\n                //定义左右队列的大小\n\t\t\t\tLL llen=Left.size(),rlen=Right.size();\n\t\t\t\tif(llen&lt;rlen)&#123;//如果左队列个数比右队列个数少\n\t\t\t\t\tLeft.push(mid);//将中位数进行转移\n\t\t\t\t\tLL cha=(rlen-llen)/2;//计算转移数量\n\t\t\t\t\tfor(int j=1;i&lt;cha;j++)&#123;//循环进行转移\n\t\t\t\t\t\tLL tmp=Right.top();\n\t\t\t\t\t\tLeft.push(tmp);\n\t\t\t\t\t\tRight.pop();\n\t\t\t\t\t&#125;\n\t\t\t\t\tmid=Right.top();//更新中位数\n\t\t\t\t\tRight.pop();\n\t\t\t\t&#125;\n\t\t\t\telse if(llen&gt;rlen)&#123;//如果右队列个数比左队列个数少\n\t\t\t\t\tRight.push(mid);//将中位数进行转移\n\t\t\t\t\tLL cha=(llen-rlen)/2;//计算转移数量\n\t\t\t\t\tfor(int j=1;i&lt;cha;j++)&#123;//循环进行转移\n\t\t\t\t\t\tLL tmp=Left.top();\n\t\t\t\t\t\tRight.push(tmp);\n\t\t\t\t\t\tLeft.pop();\n\t\t\t\t\t&#125;\n\t\t\t\t\tmid=Left.top();//更新中位数\n\t\t\t\t\tLeft.pop();\n\t\t\t\t&#125;\n\t\t\t\tcout&lt;&lt;mid&lt;&lt;&quot;\\n&quot;;//操作完成后输出中位数\n\t\t\t&#125;\n\t\t\telse continue;//插入次数为偶数次时直接跳过平衡过程\n\t\t&#125;\n\t\treturn 0;\n\t&#125;\n&#125;\n\nint main()&#123;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\treturn SHAWN::main();\n&#125;\n</code></pre>\n<p>以上，如果有不对的地方，还请各位大佬指正！</p>\n",
            "tags": [
                "对顶堆;数据结构"
            ]
        }
    ]
}