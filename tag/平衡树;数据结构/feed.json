{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"平衡树;数据结构\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/09/26/P1486%20[NOI2004]%20%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98/",
            "url": "http://example.com/2023/09/26/P1486%20[NOI2004]%20%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98/",
            "title": "题解 洛谷 P1486 [NOI2004] 郁闷的出纳员",
            "date_published": "2023-09-26T02:18:00.000Z",
            "content_html": "<h1>P1486 [NOI2004] 郁闷的出纳员</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定 $n$ 次操作和一个阈值 $min$，每次操作包含一个字符 $opt$ 和一个整数 $k$，操作可以是一下四种之一：</p>\n<ul>\n<li><code>I k</code> 如果 $k$ 小于 $min$ 不操作，否则将 $k$ 扔进一个集合 $s$ 中。</li>\n<li><code>A K</code> 把 $s$ 里所有元素值加上 $k$。</li>\n<li><code>S k</code> 把 $s$ 里所有元素值减去 $k$。</li>\n<li><code>F k</code> 查询 $s$ 里第 $k$ 大的值，如果 $k &gt; \\left | s \\right | $ 输出 <code>-1</code>。</li>\n</ul>\n<p>在每次操作中，一旦 $s$ 中有元素的值低于阈值 $min$，就要删除这个元素，程序最后要输出删除的元素总数（插入时就因为小于阈值没有插入进来的不算）</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>我们看到插入，删除，查询排名理所当然地想到了平衡树；看到全加上，全减去，理所当然地想到了线段树。但是很显然，这题肯定不是树套树。我们考虑，既然是全部加，单点查，我们其实并不用关心每个元素的更改，因为集体的更改不会导致排名的变化，只会影响我们后查询值，所以我们可以把这种更改用一个变量 $tag$ 记下来。</p>\n<h3 id=\"插入\">插入</h3>\n<p>在新插入元素的时候，我们要先对插入的元素减去 $tag$，这样做是为了消除其对插入的值的排名的影响。当我们输出的时候，因为这一部分的值刚好被抵消，所以加上的就是插入它以后对它操作的值，满足题目的要求。与此同时我们要拿一个 $sum$ 来记一共插入了多少次，拿一个 $cnt$ 来记当前集合中的元素个数。</p>\n<h3 id=\"元素加减\">元素加减</h3>\n<p>增加元素必然是直接加到 $tag$ 上就好了，但是为了维护集合内小于阈值的数的个数并成功把他们删除，我们必须要同步更改 $min$，如果集体增加就要下调 $min$，集体减少就要上调 $min$。每次减少的时候我们要进行删除操作，我们在平衡树上不断寻找 $min$ 的前驱并删除（一个数的前驱定义为小于它的最大的数），直到删完为止。</p>\n<h3 id=\"查询\">查询</h3>\n<p>查询直接查就好了，需要注意的是平衡树查排名的时候查的是第 $k$ 小，而我们查的是第 $k$ 大，所以查的时候要传的参数是 $cnt - k + 1$。在这里我们不建议更改平衡树的代码，因为平衡树细节较多码量较大，如果在考场上改写可能会导致不必要的错误以及浪费更多时间，除非万不得已，否则建议只在传参上调整。最后只需要输出总的插入次数减去当前集合的大小就是被删掉的元素个数。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;random&gt;\n#include &lt;ctime&gt;\n#include &lt;limits.h&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 2e5 + 7;\n    mt19937 rd(time(nullptr));\n    namespace Treap &#123;\n        #define ls son[ro][1]\n        #define rs son[ro][0]\n        int cont, root;\n        int son[N][2], pre[N], size[N], cnt[N]; LL val[N];\n        void update(int ro) &#123;\n            if (!ro) &#123; return; &#125;\n            size[ro] = cnt[ro];\n            if (ls) &#123; size[ro] += size[ls]; &#125;\n            if (rs) &#123; size[ro] += size[rs]; &#125; \n        &#125;\n        void rotate(int ro, int fa, int opt) &#123;\n            int s = son[ro][opt];\n            son[ro][opt] = son[s][!opt];\n            son[s][!opt] = ro;\n            if (!fa) &#123; root = s; &#125;\n            else &#123; son[fa][son[fa][1] == ro] = s; &#125; \n            update(ro); update(s);\n        &#125;\n        void insert(int ro, int fa, LL x) &#123;\n            if (!ro) &#123;\n                ro = ++cont;\n                cnt[ro] = 1; val[ro] = x;\n                pre[ro] = rd() % INT_MAX;\n                update(ro);\n                if (!fa) &#123; root = ro; &#125;\n                else &#123; son[fa][x &lt; val[fa]] = ro; &#125;\n            &#125;\n            else &#123;\n                if (x == val[ro]) &#123; ++cnt[ro]; update(ro); &#125;\n                else if (x &lt; val[ro]) &#123;\n                    insert(ls, ro, x); update(ro);\n                    if (pre[ls] &lt; pre[ro]) &#123; rotate(ro, fa, 1); &#125;\n                &#125;\n                else &#123;\n                    insert(rs, ro, x); update(ro);\n                    if (pre[rs] &lt; pre[ro]) &#123; rotate(ro, fa, 0); &#125;\n                &#125;\n            &#125;\n        &#125;\n        void del(int ro, int fa, LL x) &#123;\n            if (!ro) &#123; return; &#125;\n            if (x == val[ro]) &#123;\n                --cnt[ro];\n                if (!cnt[ro]) &#123;\n                    int f = fa, s;\n                    update(ro);\n                    while(ls &amp;&amp; rs) &#123;\n                        if (pre[ls] &lt; pre[rs]) &#123; s = ls; rotate(ro, f, 1); f = s; &#125;\n                        else &#123; s = rs; rotate(ro, f, 0); f = s; &#125;\n                    &#125;\n                    while (ls) &#123; s = ls; rotate(ro, f, 1); f = s; &#125;\n                    while (rs) &#123; s = rs; rotate(ro, f, 0); f = s; &#125;\n                    if (root == ro) &#123; root = 0; &#125;\n                    else &#123; son[f][son[f][1] == ro] = 0; &#125;\n                &#125;\n                update(ro);\n            &#125;\n            else &#123;\n                if (x &lt; val[ro]) &#123; del(ls, ro, x); update(ro); &#125;\n                else &#123; del(rs, ro, x); update(ro); &#125;\n            &#125;\n        &#125;\n        LL find_pre(int ro, LL x) &#123;\n            if (!ro) &#123; return LONG_LONG_MIN; &#125;\n            else if (x &gt; val[ro]) &#123; return max(val[ro], find_pre(rs, x)); &#125;\n            else &#123; return find_pre(ls, x); &#125;\n        &#125;\n        LL get_num(int ro, int x) &#123;\n            if (x &lt;= size[ls]) &#123; return get_num(ls, x); &#125;\n            else if (x &lt;= size[ls] + cnt[ro]) &#123; return val[ro]; &#125;\n            else &#123; return get_num(rs, x - size[ls] - cnt[ro]); &#125;\n        &#125;\n        void insert(LL x) &#123; insert(root, 0, x); &#125;\n        void del(LL x) &#123; del(root, 0, x); &#125;\n        LL findpre(LL x) &#123; return find_pre(root, x); &#125;\n        LL getnum(int x) &#123; return get_num(root, x); &#125;\n        #undef ls\n        #undef rs\n    &#125;\n\n    int n; LL _min, tag, cnt, sum;\n    signed work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; _min;\n        for (int i = 1; i &lt;= n; ++i) &#123; \n            char opt; LL k; cin &gt;&gt; opt &gt;&gt; k;\n            if (opt == 'I') &#123;\n                if (k - tag &gt;= _min) &#123;\n                    Treap :: insert(k - tag);\n                    ++cnt; ++sum;\n                &#125;\n            &#125;\n            else if (opt == 'A') &#123; _min -= k; tag += k; &#125;\n            else if (opt == 'S') &#123;\n                _min += k; tag -= k;\n                LL tmp;\n                while ((tmp = Treap :: findpre(_min)) != LONG_LONG_MIN) &#123;\n                    Treap :: del(tmp);\n                    --cnt;\n                &#125;\n            &#125;\n            else if (opt == 'F') &#123;\n                if (cnt &lt; k) &#123; cout &lt;&lt; &quot;-1\\n&quot;; &#125;\n                else &#123; cout &lt;&lt; Treap :: getnum(cnt - k + 1) + tag &lt;&lt; '\\n'; &#125;\n            &#125;\n        &#125;\n        cout &lt;&lt; sum - cnt &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "平衡树;数据结构"
            ]
        }
    ]
}