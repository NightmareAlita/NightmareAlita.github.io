{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"线段树;数据结构\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/18/P1438%20%E6%97%A0%E8%81%8A%E7%9A%84%E6%95%B0%E5%88%97/",
            "url": "http://example.com/2023/08/18/P1438%20%E6%97%A0%E8%81%8A%E7%9A%84%E6%95%B0%E5%88%97/",
            "title": "题解 洛谷 P1438 无聊的数列",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>P1438 无聊的数列</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个序列 $a$，要求进行两种操作。</p>\n<ul>\n<li>对于区间 $[l,r]$ 对应加上一个长为 $r - l +1$，首项为 $K$，公差为 $D$ 的等差数列；</li>\n<li>查询第 $p$ 个数的值。</li>\n</ul>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>题目要求将一段等差数列加到一段区间上去。我们一眼丁真想到了线段树，但是对于加的不是同一个值的情况，朴素的做法只能进行单点修改，如果这样单点改下去再单点查，和直接在数组上模拟没有任何区别，我们写线段树不光要多递归几层还很废空间。</p>\n<p>遇到这种一眼就是线段树却不知道如何维护的题，我们就需要重新再回去审题来寻找操作的<strong>特殊性质</strong>。我们发现这道题的特殊性质就是等差数列。那么等差数列有什么性质呢？<s>等差数列等差</s>。虽然说这是一句废话，但是却恰恰揭示了这道题的关键，<strong>等差数列的差分序列中的值除了开头结尾以外完全相同</strong>。我们发现，对于一个从 $l$ 位置开始到 $r$ 位置结束的公差为 $d$ 的等差数列的差分序列有如下性质：</p>\n<ul>\n<li>对于位置 $l$ ，它的值一定等于等差数列的首项；</li>\n<li>对于位置区间 $[l + 1, r]$ 内的每个位置，它的值一定等于公差 $d$；</li>\n<li>对于位置 $r + 1$，它的值一定等于等差数列的末项。</li>\n</ul>\n<p>有了这三个性质后，我们就可以把题目变成对原序列的差分序列进行一次区间加和两次单点修改，时间复杂度就大大缩减了。而单点求值其实就是求差分序列的前缀和，这样我们就可以做了，但是有如下细节需要注意：</p>\n<ul>\n<li>由于差分序列要修改 $r + 1$ 位置，所以不难发现我们建树的区间不是 $[1,n]$ 而是 $[1, n + 1]$；</li>\n<li>题目给的数据范围很有迷惑性，容易给人造成不用开 <code>long long</code> 的假象，然而如果不开就会 <code>WA on 1st</code>；</li>\n<li>题目给的修改区间存在数据使得 $l=r$，此时我们 <code>update(1, l + 1, r, d);</code> 这句就会 RE，需要特判。</li>\n</ul>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define LL long long\n#define ls ro &lt;&lt; 1\n#define rs ro &lt;&lt; 1 | 1\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e5 + 7;\n    struct tree &#123; int l, r; LL sum, tag; &#125;tree[N &lt;&lt; 2];\n    int n, m;\n    LL a[N];\n    void pushup(int ro) &#123; tree[ro].sum = tree[ls].sum + tree[rs].sum; &#125;\n    void build(int ro, int l, int r) &#123;\n        tree[ro].l = l; tree[ro].r = r;\n        tree[ro].tag = 0;\n        if (l &gt;= r) &#123;\n            tree[ro].sum = a[l] - a[l - 1];\n            return;\n        &#125;\n        int mid = l + ((r - l) &gt;&gt; 1);\n        build(ls, l, mid); build(rs, mid + 1, r);\n        pushup(ro);\n    &#125;\n    void pushdown(int ro) &#123;\n        if (tree[ro].tag) &#123;\n            tree[ls].sum += (tree[ls].r - tree[ls].l + 1) * tree[ro].tag;\n            tree[rs].sum += (tree[rs].r - tree[rs].l + 1) * tree[ro].tag;\n            tree[ls].tag += tree[ro].tag;\n            tree[rs].tag += tree[ro].tag;\n            tree[ro].tag = 0;\n        &#125;\n    &#125;\n    void update(int ro, int l, int r, LL x) &#123;\n        int lt = tree[ro].l, rt = tree[ro].r;\n        if (l &lt;= lt &amp;&amp; r &gt;= rt) &#123;\n            tree[ro].sum += (rt - lt + 1) * x;\n            tree[ro].tag += x;\n            return;\n        &#125;\n        pushdown(ro);\n        int mid = lt + ((rt - lt) &gt;&gt; 1);\n        if (l &lt;= mid) &#123; update(ls, l, r, x); &#125;\n        if (r &gt; mid) &#123; update(rs, l, r, x); &#125;\n        pushup(ro);\n    &#125;\n    LL getsum(int ro, int l, int r) &#123;\n        int lt = tree[ro].l, rt = tree[ro].r;\n        if (l &lt;= lt &amp;&amp; r &gt;= rt) &#123; return tree[ro].sum; &#125;\n        pushdown(ro);\n        int mid = lt + ((rt - lt) &gt;&gt; 1); LL res = 0;\n        if (l &lt;= mid) &#123; res += getsum(ls, l, r); &#125;\n        if (r &gt; mid) &#123; res += getsum(rs, l, r); &#125;\n        return res;\n    &#125;\n    signed work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125;\n        build(1, 1, n + 1);\n        while (m--) &#123;\n            int opt; cin &gt;&gt; opt;\n            if (opt == 1) &#123; \n                int l, r; LL k, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k &gt;&gt; d;\n                if (l != r) &#123;\n                    update(1, l, l, k);\n                    update(1, l + 1, r, d);\n                    update(1, r + 1, r + 1, -((r - l) * d + k));\n                &#125;\n                else &#123; \n                    update(1, l, l, k); \n                    update(1, r + 1, r + 1, -k);\n                &#125;\n            &#125;\n            else if (opt == 2) &#123;\n                int p; cin &gt;&gt; p;\n                cout &lt;&lt; getsum(1, 1, p) &lt;&lt; '\\n';\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "线段树;数据结构"
            ]
        }
    ]
}