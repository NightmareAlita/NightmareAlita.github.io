{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"割边;tarjan\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/24/P7687%20[CEOI2005]%20Critical%20Network%20Lines/",
            "url": "http://example.com/2023/08/24/P7687%20[CEOI2005]%20Critical%20Network%20Lines/",
            "title": "题解 洛谷 P7687 [CEOI2005] Critical Network Lines",
            "date_published": "2023-08-24T01:16:00.000Z",
            "content_html": "<h1>P7687 [CEOI2005] Critical Network Lines</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一张图，图上有两类点 $A$ 和 $B$，现在要求你找到满足下面条件的边：删除这条边后该图变为两个块，且至少有一个块中只包含 $A$ 类点或只包含 $B$ 类点。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p><a href=\"https://oi-wiki.org/graph/cut/#%E5%89%B2%E8%BE%B9\">前置芝士：割边（桥）</a></p>\n<p>我们不难看出题目想让我们求的边是图中的割边，但并非所有的割边都满足题目的条件。如下图（图中边上的数字是编号不是边权）：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/24/pPYBlad.png\" alt=\"\"></p>\n<p>这幅图中的割边有 $1,4,5,6,8$ 五条，而符合题目条件的只有 $1,6,8$ 这三条。仔细考虑我们在深搜的时候形成的深度优先生成树的性质，我们发现，<strong>当一个割边满足条件当且仅当它连接的一个节点在深度优先生成树中的子树内只包含一类点</strong>（如果后面看不懂建议反复阅读体会这句话）。求割边的时候，每找到一条割边 $(u,v)$，我们就检查一下以 $v$ 为根结点的子树内 $A$ 和 $B$ 类结点各自的数量，当其中一个个数为 $0$ 或者全满，就是要求的边，打上标记并给计数的答案加一就可以了。求数量的过程，可以在 $\\operatorname{dfs}$ 的时候递归计算。</p>\n<h2 id=\"实现\">实现</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 2e6 + 7;\n    // 请注意这里一定要开二倍空间，要不然会寄\n    int head[N], cnt;\n    struct edge &#123; int to, next; &#125;edge[N];\n    int n, m, a, b, tim, res;\n    int dfn[N], low[N], acnt[N], bcnt[N], par[N];\n    // acnt[i]表示i结点子树中A类点数量，bcnt同理\n    // par用来记每个结点在dfs生成树中的父亲\n    bool flag[N];\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u, int fa) &#123;\n        low[u] = dfn[u] = ++tim;\n        par[u] = fa;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!dfn[v]) &#123;\n                Tarjan(v, u);\n                low[u] = min(low[u], low[v]);\n                if (low[v] &gt; dfn[u]) &#123;\n                    if (!acnt[v] || !bcnt[v] || acnt[v] == a || bcnt[v] == b) &#123;\n                        // A类或B类有一个为0或全满就说明符合要求\n                        flag[v] = true;\n                        ++res;\n                        // 后来看大家的做法这里用vector套一个pair存也非常方便\n                    &#125;\n                &#125;\n                acnt[u] += acnt[v]; bcnt[u] += bcnt[v];\n                // 从下向上递归统计子树情况\n            &#125;\n            else if (dfn[v] &lt; dfn[u] &amp;&amp; fa != v) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;\n        for (int i = 1, x; i &lt;= a; ++i) &#123; cin &gt;&gt; x; acnt[x] = 1; &#125;\n        for (int i = 1, x; i &lt;= b; ++i) &#123; cin &gt;&gt; x; bcnt[x] = 1; &#125;\n        // 最开始每个点的子树就是自己\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            add(x, y); add(y, x);\n        &#125;\n        Tarjan(1, 0);\n        cout &lt;&lt; res &lt;&lt; '\\n';\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (flag[i]) &#123;\n                cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; par[i] &lt;&lt; '\\n';\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "割边;Tarjan"
            ]
        }
    ]
}