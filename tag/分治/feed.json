{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"分治\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/18/P1257,P1429,P7883%20%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/",
            "url": "http://example.com/2023/08/18/P1257,P1429,P7883%20%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/",
            "title": "题解 洛谷 P1257/P1429/P7883 平面最近点对",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>题解 洛谷 P1257/P1429/P7883 平面最近点对</h1>\n<h2 id=\"本文主要介绍分治法\">本文主要介绍分治法</h2>\n<h3 id=\"P1257\">P1257</h3>\n<p>因为数据范围太小从而可以$n^2$水过，所以只评了个橙，那么直接$n^2$做就可以了</p>\n<h3 id=\"P1429-P7883\">P1429/P7883</h3>\n<p>这两道题的数据范围都在$10^5$，所以我们期望的时间复杂度是$O(nlogn)$，这时候我们就不要充分发扬人类智慧了（，果断使用分治</p>\n<h3 id=\"分治策略\">分治策略</h3>\n<p>考虑将这些点划分成若干区间进行比较，因为点是乱序的，所以我们先对所有点按照$x$坐标从小到大进行排序，排好序以后从中间序号的点来二分整个$xOy$系，递归二分若干次后，我们只需要对三种情况的点进行比较就可以了</p>\n<p>1.两个点都在$mid$左边</p>\n<p>2.两个点都在$mid$右边</p>\n<p>3.一个在左边，一个在右边</p>\n<p>诶！我们发现这种对比方式是不是在哪里见过呀，没错，就是逆序对！<s>那么这个题可以说和逆序对没有什么关系</s>。但是我们在分治的时候采取的策略是有相似之处的，前两种情况只需要用最普通的递归就可以轻松解决，像这样：</p>\n<pre><code class=\"language-cpp\">dis = min(solve(l,mid), solve(mid + 1, r));\n</code></pre>\n<p>在实现的时候我们可以发现我们先处理出来了在各自一边的最近点对的距离$dis$,那么接下来我们其实就是要把跨区间的点对的$dis$和当前的$dis$比较然后取$min$，所以我们把距离中线$mid$水平距离小于$dis$的点都取出来扔进一个容器里（你看这个数组它就很好用），很容易证明水平距离大于$dis$的点不可能满足条件（直角三角形斜边长大于直角边总会用吧）</p>\n<p>$Well $ $Done!$ 我们离成功只剩一步之遥</p>\n<p>将这些点取出来以后，我们先对这些点按照$y$进行排序，然后枚举这些点，分别以每个点为圆心，半径为$dis$画圆，然后把圆内的点与圆心的距离和$dis$比较取较小的即可。请注意：这里的$dis$是实时更新的，所以圆的半径在不断缩小或者不变。</p>\n<p>于是这道题就做完了，下面是$P1429$的$AC$代码，$P7883$只要在它的基础上把$long$ $double$改成$long$ $long$即可</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;iomanip&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n#define LD long double\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 2e5 + 7;\n    const LD INF = 1e18;\n    struct node &#123; LD x, y; &#125;pt[N];\n    int que[N];\n    int n;\n    bool cmp1 (node a, node b) &#123; return a.x &lt; b.x; &#125;\n    bool cmp2 (int a, int b) &#123; return pt[a].y &lt; pt[b].y; &#125;\n    LD getlen(node a, node b) &#123; return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y); &#125;\n    LD solve(int l, int r)  &#123;\n        if (l == r) &#123; return INF; &#125;\n        if (l == r - 1) &#123; return getlen(pt[l], pt[r]); &#125;\n        int mid = l + ((r - l) &gt;&gt; 1);\n        LD dis = min(solve(l, mid), solve(mid + 1, r));\n        int idx = 0;\n        for (int i = l; i &lt;= r; ++i) &#123;\n            if ((pt[mid].x - pt[i].x) * (pt[mid].x - pt[i].x) &lt; dis) &#123;\n                que[++idx] = i;\n            &#125;\n        &#125;\n        sort(que + 1, que + idx + 1, cmp2);\n        for (int i = 1; i &lt;= idx; ++i) &#123;\n            for (int j = i + 1; j &lt;= idx &amp;&amp; ((pt[que[i]].y - pt[que[j]].y) * (pt[que[i]].y - pt[que[j]].y)) &lt; dis; ++j) &#123;\n                dis = min(dis, getlen(pt[que[i]], pt[que[j]]));\n            &#125;\n        &#125;\n        return dis;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; pt[i].x &gt;&gt; pt[i].y; &#125;\n        sort(pt + 1, pt + n + 1, cmp1);\n        cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; sqrt(solve(1, n)) &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "分治"
            ]
        }
    ]
}