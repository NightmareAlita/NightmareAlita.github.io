{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"哈夫曼树;哈夫曼编码\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/18/BNDSOJ%201575%20%E5%93%88%E5%A4%AB%E6%9B%BC/",
            "url": "http://example.com/2023/08/18/BNDSOJ%201575%20%E5%93%88%E5%A4%AB%E6%9B%BC/",
            "title": "题解 BNDS OJ 1575 哈夫曼",
            "date_published": "2023-08-18T08:57:00.000Z",
            "content_html": "<h1>题解 BNDS OJ 1575 哈夫曼</h1>\n<h4 id=\"前置芝士：\">前置芝士：</h4>\n<p><a href=\"https://oi-wiki.org/ds/huffman-tree/\">哈夫曼树</a></p>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>给定一个仅包含小写字母的字符序列，要求输出这个序列的哈夫曼编码</p>\n<h4 id=\"分析-求解：\">分析/求解：</h4>\n<p>哈夫曼建树时要求每次配对权值最小的两个儿子，它们配对所产生的父亲也要重新与其它的树进行比较，所以我们很容易可以想到通过优先队列来维护当前所有的树，具体细节见代码</p>\n<h4 id=\"AC代码：\">AC代码：</h4>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    struct node &#123; int ma,val,fa,l,r,pos; &#125;;\n    // ma,val,fa,l,r,pos分别表示当前节点对应的字母，出现的数量，父节点编号，左右儿子编号，当前节点编号\n    struct cmp&#123;\n        bool operator()(const node&amp;a, const node&amp;b)const&#123;\n            if(a.val != b.val) &#123; return a.val &gt; b.val; &#125;\n            else &#123; return a.ma &gt; b.ma; &#125;\n        &#125;\n    &#125;;// 重载函数调用运算符\n    priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; q; \n    // 用优先队列来维护森林\n    string s;\n    node tree[N];\n    // tree[]维护整棵哈夫曼树\n    vector&lt;int&gt; haff[30];\n    // haff[]维护每个字母对应的哈夫曼编码\n    int used[30];\n    // used[]维护每个字母出现的次数\n    int n, m, idx;\n    void build() &#123;\n        while (q.size() &gt;= 2) &#123; // 森林中还有元素时持续配对\n            node x = q.top(); q.pop();\n            node y = q.top(); q.pop();\n            // 取出堆顶两个元素配对\n            if (!x.pos) &#123; tree[++idx] = x; tree[idx].pos = x.pos = idx; &#125;\n            if (!y.pos) &#123; tree[++idx] = y; tree[idx].pos = y.pos = idx; &#125;\n            // 如果取出的点没有在树中则新建一个树上节点\n            node z = &#123;-1,(x.val+y.val), -1, x.pos, y.pos, ++idx&#125;;\n            tree[x.pos].fa = tree[y.pos].fa = idx;\n            q.push(z); tree[idx] = z;\n            // 建立这两个节点的父亲并扔进森林\n        &#125;\n    &#125;\n    void solve() &#123;\n        for (int i = 1; i &lt;= idx; ++i) &#123;\n            // 遍历树上节点找到最原始的代表单独字符的节点\n            if (tree[i].ma != -1) &#123;\n                int now = i;\n                while (tree[now].fa != -1) &#123;\n                    if (now == tree[tree[now].fa].l) &#123; haff[tree[i].ma].push_back(0); &#125;\n                    else &#123; haff[tree[i].ma].push_back(1); &#125;\n                    now = tree[now].fa;\n                    // 向上搜索找根来获取编码\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= 27; ++i) &#123;\n            if (haff[i].size()) &#123;\n                for(int j = haff[i].size()-1; j &gt;= 0; --j) &#123; cout &lt;&lt; haff[i][j]; &#125;\n                // 由于获取编码时是反向获取的，所以倒序输出\n                cout &lt;&lt; '\\n';\n            &#125;\n        &#125;\n        for (int i = 0; i &lt;= n; ++i) &#123;\n            int a = s[i] - 'a' + 1;\n            for(int j = haff[a].size()-1; j &gt;= 0; --j) &#123; cout &lt;&lt; haff[a][j]; &#125;\n            // 查询并输出整个字符串的哈夫曼编码\n        &#125;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n        for (int i = 0; i &lt; n; ++i) &#123; used[s[i] - 'a' + 1]++; &#125;\n        // 统计每个字母出现的次数\n        for (int i = 1; i &lt;=26; ++i) &#123; \n            if (used[i]) &#123; // 如果存在当前字母\n                q.push(&#123;i,used[i],0,-1,-1,0&#125;); \n                // 将该节点作为一个子树插入森林\n            &#125;\n        &#125;\n        build(); // 建树\n        solve(); // 求霍夫曼编码\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "哈夫曼树;哈夫曼编码"
            ]
        }
    ]
}