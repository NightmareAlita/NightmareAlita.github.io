{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN • All posts by \"矩阵加速;动态规划\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/18/U327217%20%E5%AF%BB%E6%89%BE%E5%8D%83%E6%B3%B7%E3%81%AE%E5%B0%8F%E7%BF%BC%E9%BE%99/",
            "url": "http://example.com/2023/08/18/U327217%20%E5%AF%BB%E6%89%BE%E5%8D%83%E6%B3%B7%E3%81%AE%E5%B0%8F%E7%BF%BC%E9%BE%99/",
            "title": "题解 洛谷 U327217 寻找千泷の小翼龙",
            "date_published": "2023-08-18T09:04:00.000Z",
            "content_html": "<h1>题解 洛谷 U327217 寻找千泷の小翼龙</h1>\n<p><a href=\"https://www.luogu.com.cn/problem/U327217\">本题题面</a></p>\n<h4 id=\"原题（本题由该题数据加强而来）：\">原题（本题由该题数据加强而来）：</h4>\n<h3 id=\"USACO-Training-6-1-1-Postal-Vans\">USACO Training 6.1.1 Postal Vans</h3>\n<p>Tiring of their idyllic fields, the cows have moved to a new suburb. The suburb is a rectangular grid of streets with a post office at its Northwest corner. It has four avenues running East-West and $n(1\\le n\\le 10^{18})$ streets running North-South.</p>\n<p>For example, the following diagram shows such a suburb with $n=5$ streets, with the avenues depicted as horizontal lines, and the post office as a dark blob at the top-left corner:</p>\n<p><img src=\"https://img1.imgtp.com/2023/08/14/HuR5aj47.png\" alt=\"\"></p>\n<p>Each day the postal van leaves the post office, drives around the suburb and returns to the post office, passing exactly once through every intersection (including those on borders or corners). The executives from the post company want to know how many distinct routes can be established for the postal van (of course, the route direction is significant in this count).</p>\n<p>For example, the following diagrams show two such routes for the above suburb:</p>\n<p><img src=\"https://img1.imgtp.com/2023/08/14/cqJ1rEzT.png\" alt=\"\"></p>\n<p>As another example, the following diagrams show all the four possible routes for a suburb with $n=3$ streets:</p>\n<p><img src=\"https://img1.imgtp.com/2023/08/14/tUwsNA4a.png\" alt=\"\"></p>\n<p>Write a program that will determine the number of such distinct routes given the number of streets.</p>\n<p>INPUT FORMAT</p>\n<p>Line 1: Two integers, n, p</p>\n<p>SAMPLE INPUT：</p>\n<pre><code>4 32767\n</code></pre>\n<p>OUTPUT FORMAT</p>\n<p>Line 1: A single integer that tells how many possible distinct routes corresponding to the number of streets given in the input, mod p;</p>\n<p>SAMPLE OUTPUT:</p>\n<pre><code>12\n</code></pre>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>给定一个$4\\times n$的格子（按照格点计数），从左上角出发沿格子遍历所有格点后再返回起点，要求每个点只遍历一次，计算合法方案的总数 $mod$ $p$ 的值</p>\n<h4 id=\"策略分析：\">策略分析：</h4>\n<p>看到方案数，我们合理地想到了动态规划，而看到数据范围和动态规划，我们合理地想到了矩阵加速。设 $f_i$ 为前 $i$ 列中第 $i$ 列中总的方案数。大家小时候应该都玩过拼管子吧，就那种各种各样形状的管子可以组合成不同的形状，那么本题就是要用类似的方法。</p>\n<p>到达南北方向 $1,2$ 路口的方案只有 $2$ 种，我们将管子如下摆放：</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/eu2m5la4.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/0c03xatj.png\" alt=\"\"></p>\n<p>到达南北方向 $1,4$ 路口方案有 $7$ 种，但最后两种等价算作一种：</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/ien5q644.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/zdtegbg0.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/w7t6gcu7.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/8i80emnk.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/qu3xspnd.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/2e98lwsj.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/r44dhsqm.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/cidfxurb.png\" alt=\"\"></p>\n<p>由此我们可以推出状态转移方程，即：</p>\n$$\\displaylines{f_i=2f_{i-1}+2f_{i-2}-2f_{i-3}+f_{i-4}\n}$$<p>对于这种方法和递推方程正确性的证明参见<a href=\"http://blog.csdn.net/jiangshibiao/article/details/21446033\">阿蒋大佬的blog</a></p>\n<p>得到了状态转移方程我们就可以得到转移矩阵 $M$ 了,</p>\n$$\\displaylines{M=\\begin{vmatrix}\n  2&amp;  2&amp;  -2&amp; 1\\\\\n  1&amp;  0&amp;  0&amp; 0\\\\\n  0&amp;  1&amp;  0&amp; 0\\\\\n  0&amp;  0&amp;  1&amp; 0\n\\end{vmatrix}}$$<p>我们充分发扬人类智慧，通过大脑和手求得 $f_1=0,f_2=2,f_3=4,f_4=12$</p>\n<p>剩余部分显然没有难度了，直接矩阵加速就可以了，于是我们做完了，下面是 $AC$ 代码</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#define clear(q) memset(q.m, 0, sizeof(q.m))\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    LL n, p;\n    struct mat &#123; LL m[4][4]; &#125;;\n    mat operator* (const mat &amp;x, const mat &amp;y) &#123;\n        mat ans;\n        clear(ans);\n        for (int i = 0; i &lt; 4; ++i) &#123;\n            for (int k = 0; k &lt; 4; ++k) &#123;\n                if (x.m[i][k]) &#123;\n                    for (int j = 0; j &lt; 4; ++j) &#123;\n                        ans.m[i][j] = ((ans.m[i][j] + (x.m[i][k] * y.m[k][j])) % p + p) % p; \n                    &#125;\n                &#125;\n            &#125;\n        &#125; \n        return ans;\n    &#125;\n    mat qpow(mat a, LL b) &#123;\n        mat z;\n        clear(z);\n        for (int i = 0; i &lt; 4; ++i) &#123; z.m[i][i] = 1; &#125;\n        while (b) &#123;\n            if (b &amp; 1) &#123; z = z * a; &#125;\n            a = a * a; b &gt;&gt;= 1;\n        &#125;\n        return z;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; p;\n        if (n &lt;= 4) &#123;\n            switch (n) &#123;\n                case 1 : cout &lt;&lt; &quot;0\\n&quot;; break;\n                case 2 : cout &lt;&lt; &quot;2\\n&quot;; break;\n                case 3 : cout &lt;&lt; &quot;4\\n&quot;; break;\n                case 4 : cout &lt;&lt; &quot;12\\n&quot;; break;\n                default : break;\n            &#125;\n            return 0;\n        &#125;\n        mat a;\n        clear(a);\n        a.m[0][0] = 2; a.m[0][1] = 2; a.m[0][2] = -2; a.m[0][3] = 1;\n        a.m[1][0] = 1; a.m[2][1] = 1; a.m[3][2] = 1;\n        mat z = qpow(a, n - 4);\n        LL ans = ((z.m[0][0] * 12 + z.m[0][1] * 4 + z.m[0][2] * 2) % p + p) % p;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "矩阵加速;动态规划"
            ]
        }
    ]
}