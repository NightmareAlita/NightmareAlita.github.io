{
    "version": "https://jsonfeed.org/version/1",
    "title": "NERV - SN",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/10/25/CF1809D%20Binary%20String%20Sorting/",
            "url": "http://example.com/2023/10/25/CF1809D%20Binary%20String%20Sorting/",
            "title": "题解 洛谷 CF1809D Binary String Sorting",
            "date_published": "2023-10-25T09:17:00.000Z",
            "content_html": "<h1>CF1809D Binary String Sorting</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个 $01$ 串，要求你交换相邻两个数或删掉一个数，使得该串单调不降。其中交换相邻两个数的代价是 $10^{12}$，删除的代价是 $10^{12} + 1$，求最小代价。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>本题需要我们发现一个重要的性质，因为我们需要把数列变成形如 <code>00000...11111</code> 的形式，所以必然存在一个分界点，这个分解点的两边的数可能是 $10$ 或 $01$。现在假设我们知道这个分界点在哪里了，那么我们就要把分界点左边的 $1$ 想办法弄到右边，或者直接扔掉。我们发现，除非是 $10$ 情况下的分界点左边的那个 $1$，其余的 $1$ 删掉的代价一定比一次一次交换过来少，因为删除只需要一次，而交换至少需要两次，显然 $2 \\times 10^{12} &gt; 10^{12} + 1$，处理分界点右边的 $0$ 同理。那么我们只需要枚举这个分界点在哪里，并判断分界点两边的数是 $10$ 还是 $01$ 即可，如果是 $10$ 还要额外判断一下转更优还是不转更优，顺序枚举一遍即可得解。</p>\n<p>具体来讲，我们对于每个位置，预处理出其前面（包括自己在内）有多少个 $1$，后面有多少个 $0$，枚举到每一个位置的时候用预处理出的值乘以代价即可，注意预处理的前后缀数组要多组数据清空。</p>\n<p>时间复杂度 $O(Tn)$。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const LL N = 3e5 + 7, C = 1e12 + 1;\n    LL q[N], h[N];\n    int T;\n    signed work()\n    &#123;\n        cin &gt;&gt; T;\n        while (T--) &#123;\n            string s; cin &gt;&gt; s;\n            int len = s.length();\n            s = ' ' + s;\n            LL ans = 1e18;\n            for (int i = 1; i &lt;= len; ++i) &#123;\n                q[i] = q[i - 1];\n                if (s[i] == '1') &#123; ++q[i]; &#125;\n            &#125;\n            for (int i = len; i &gt;= 1; --i) &#123;\n                h[i] = h[i + 1];\n                if (s[i] == '0') &#123; ++h[i]; &#125;\n            &#125;\n            for (int i = 0; i &lt;= len; ++i) &#123;\n                if (s[i] == '1' &amp;&amp; s[i + 1] == '0') &#123;\n                    ans = min(ans, q[i - 1] * C + h[i + 2] * C + C - 1);\n                &#125;\n                ans = min(ans, q[i] * C + h[i + 1] * C);\n            &#125;\n            cout &lt;&lt; ans &lt;&lt; '\\n';\n            for (int i = 0; i &lt;= len; ++i) &#123; q[i] = h[i] = 0; &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造;二进制;枚举"
            ]
        },
        {
            "id": "http://example.com/2023/10/24/SP6285%20NGM2%20-%20Another%20Game%20With%20Numbers/",
            "url": "http://example.com/2023/10/24/SP6285%20NGM2%20-%20Another%20Game%20With%20Numbers/",
            "title": "题解 SP6285 NGM2 - Another Game With Numbers",
            "date_published": "2023-10-24T03:48:00.000Z",
            "content_html": "<h1>SP6285 NGM2 - Another Game With Numbers</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个长为 $K$ 的数组 $a$，其中 $1 \\le K \\le 15$ 且 $a_i \\le 100$，再给定一个数 $N$，其中 $1 \\le N \\le 10^9$，要求求出 $[1, N]$ 中有多少数不能被 $a$ 中任意一个数整除。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>显然满足我们要求的数不能被 $a_i$ 整除，同时也不能被 $a$ 中任意 $p(2 \\le p \\le K)$ 个元素的最小公倍数整除。所以最朴素的想法是通过筛选出能够被整除的数的个数，再用 $N$ 减去它。如果你想到这里了，那么恭喜你这道题已经做完了。由于本题的 $K$ 非常非常小，所以我们可以直接暴力枚举出 $K$ 个数的所有组合的最大公约数，$O(1)$ 求出 $[1, N]$ 中能整除一个数 $x$ 的数有多少，然后做容斥就能得出答案了。</p>\n<p>具体来讲，我们可以用状态压缩来对所有组合进行枚举，即对于 $K$，我们从 $1$ 枚举到 $2^{K} - 1$，枚举到的第 $i$ 个数的第 $j$ 位为 $1$ 则表示本次选取这位，否则不选，然后每次对所有选取的位置上的数求最小公倍数 $x$，然后用 $N$ 除以 $x$ 就能得出 $N$ 中能整除 $x$ 的数的个数 $y$。根据容斥原理，如果当前选取了奇数个数，就要把 $y$ 加入到答案中，否则将答案减去 $y$。注意这样算出的结果是 $[1, N]$ 中能整除 $a$ 中某个数的数的个数，所以最后要用 $N$ 减去它才能得到答案。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 107;\n    LL a[N];\n    LL n, k, ans;\n    inline LL gcd(LL x, LL y) &#123; return !y ? x : gcd(y, x % y); &#125;\n    inline LL lcm(LL x, LL y) &#123; return x * y / gcd(x, y); &#125;\n    signed work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k;\n        for (int i = 1; i &lt;= k; ++i) &#123; cin &gt;&gt; a[i]; &#125;\n        for (int i = 1; i &lt; (1 &lt;&lt; k); ++i) &#123;\n            LL lrc = 1, cnt = 0;\n            for (int j = 1; j &lt;= k; ++j) &#123;\n                if (i &amp; (1 &lt;&lt; (j - 1))) &#123;\n                    lrc = lcm(lrc, a[j]);\n                    ++cnt;\n                &#125;\n            &#125;\n            if (cnt &amp; 1) &#123; ans += n / lrc; &#125;\n            else &#123; ans -= n / lrc; &#125;\n        &#125;\n        ans = n - ans;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "状态压缩;容斥"
            ]
        },
        {
            "id": "http://example.com/2023/10/03/JZOJ5952.%20%E3%80%90NOIP2018%E6%A8%A1%E6%8B%9F11.5A%E7%BB%84%E3%80%91%E5%87%AF%E6%97%8B%E8%80%8C%E5%BD%92/",
            "url": "http://example.com/2023/10/03/JZOJ5952.%20%E3%80%90NOIP2018%E6%A8%A1%E6%8B%9F11.5A%E7%BB%84%E3%80%91%E5%87%AF%E6%97%8B%E8%80%8C%E5%BD%92/",
            "title": "题解 JZOJ5952. 【NOIP2018模拟11.5A组】凯旋而归",
            "date_published": "2023-10-03T10:16:00.000Z",
            "content_html": "<h1>JZOJ5952. 【NOIP2018模拟11.5A组】凯旋而归</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>对于一个数列 $num$，一个函数 $f$ 定义如下：</p>\n$$\\displaylines{f(num) = \\max\\{(a_1 \\oplus a_2 \\oplus \\dots a_i) + (a_{i+1} \\oplus a_{i+2} \\oplus\\dots a_n) | i \\in [0, n] \\}\n}$$<p>现在给你一个数列，依次求出其所有前缀的 $f$ 的值。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>首先我们需要一些前置知识，我们在求一个数列的子段异或和的时候，可以像其普通加法求和一样处理出前缀和并 $O(1)$ 求解。那么对于异或前缀和数组 $a$ 来讲，区间 $[l,r]$ 的异或和就等于 $a_{l-1} \\oplus a_r$。</p>\n<p>知道了这个性质以后，我们就可以做出本题 50 分的做法，即对于每个位置 $i$ 都去暴力枚举 $[1,i]$ 或 $[0,i]$ 区间（枚举这两个区间得到的答案是等价的）的最大答案。假设我们枚举到了位置 $j$，那么我们要求的就是答案 $ans$ 就等于 $max(ans,a_j+(a_j \\oplus a_i))$。也就是说，想让答案尽可能大，就要让 $a_j+(a_j \\oplus a_i)$ 尽可能大。于是我们自然而然地想到拆位来考虑。对于第 $k$ 位（下标从 $0$ 开始），这一位能够让整个数增加当且仅当这一位为 $0$ 且能够被更改为 $1$。也就是说如果第 $k$ 位为 $0$，那么它变成 $1$ 就可以对整个数造成 $2^k$ 的贡献。那么对于一个形如 $x + (x \\oplus y)$ 的式子来说，我们设 $x$ 和 $y$ 都只有一位（高位情况不过是拆开考虑），那么当 $y=1$ 时，无论 $x$ 为何值，最终得到的结果都是 $1$，不会对结果产生任何影响。但当 $y=0$ 时，我们就要想办法让它变成 $1$ 从而使得答案增加。那么我们的目的就变成了，找到一个 $a_j$ 能够使其跟当前的 $a_i$ 运算的结果尽可能的大。</p>\n<p>那么我们就要考虑能不能往这一位填 $1$，这要求我们去判断在前缀数组的第 $i$ 位之前有没有一个数可以和这个数运算使得我们期望的 $0$ 位变成 $1$ 且不去影响已经填好的，我们知道，只要我们把高位的一个 $0$ 变成 $1$，那么低位的甭管怎么变都不可能比现在大，那么我们直接贪心地从高位往低位讨论就好了。问题就在于怎么去让高位已经填好的不变。这里我们定义一种二进制下的集合关系，即 $x \\subseteq y := x \\&amp; y$，也就是说 $y$ 中为 $1$ 的位置在 $x$ 中也必须为 $1$。这样很抽象不好理解，我们举个例子。</p>\n<pre><code>a = 111000101010\nb = 110000101010\nc = 100000101010\n</code></pre>\n<p>上面的三个二进制数中，$b \\subseteq a, c \\subseteq b$。</p>\n<p>定义了这个以后，我们定义一个数组 $f$，其中 $f_i=j$ 表示包含 $i$ 的数出现的位置的最小下标为 $j$，也就是存在一个数包含 $i$ 且这个数在 $a_i$ 里（当然也有可能不存在）最早出现的那个下标为 $j$。如果这个下标不存在那么显然值就是无穷大。我们在处理异或前缀和的时候就要初始化这个数组，初始化的过程非常显然但不便于用语言描述所以直接给出：</p>\n<pre><code class=\"language-cpp\">f[a[i]] = min(f[a[i]], i);\n</code></pre>\n<p>接下来我们要预处理这个数组，处理的时候从大的数向小的处理，这样可以一遍就找到我们想要的最小位置。因为本题数据范围是 $10^6$，所以我们大概从 $2^{21}-1$ 开始枚举即可，每次判断一下，如果 $f_i &lt; \\infty $ 那么我们就可以用 $f_i$ 去更新 $i$ 的子集（这里的子集和前面的包含关系定义是一样的）内的所有元素，更新的方法就是逐位枚举，如果是 $1$ 变成 $0$ 就是它的子集内的元素，那么更新就好了，但是更新完了要记得把改成 $0$ 的这一位再变回来更新下一位，实现过程如下：</p>\n<pre><code class=\"language-cpp\">for (int i = (1 &lt;&lt; 20) - 1;i &gt;= 0; --i) &#123;\n    if(f[i] &lt; INF) &#123;\n        for (int j = 0; j &lt; 20; ++j) &#123;\n            if(i &amp; p[j]) &#123;\n                f[i ^ p[j]] = min(f[i ^ p[j]], f[i]);\n            &#125;\n        &#125;\t\t\t\n    &#125;\n&#125;\n</code></pre>\n<p>注：这里的 $p_i$ 即表示 $2^i$ 次方的值，这个值在我们这道题中用其另一性质，即其二进制表示下第 $i$ 位为 $1$，其余均为 $0$，用一个数和 $p_i$ 做与运算可以判断这个数第 $i$ 位为 $1$ 还是 $0$。</p>\n<p>预处理结束以后，我们就可以开始做了，逐个枚举前缀和，对于当前枚举到的 $a_i$，我们用一个 $s$ 来代表前面一半异或前缀和的值，那么我们仍然是从高位往低位枚举（基于贪心思想，高位为 $1$ 的贡献高于低位为 $1$ 的贡献。如果当前这一位是 $1$，那么我们就不用管它了，因为它不会再产生贡献。如果这一位为 $0$，那么我们就看能不能找到一个小于 $i$ 的位置上的元素使得其是 $s$ 这一位变成 $1$ 后的数的子集，只有这样才能保证操作完后以前操作的位上的值不会被改变，如果找到了就把 $s$ 这位变成 $1$，相反的，如果没找到就变回 $0$，再去枚举下一位。枚举完后按照 $a_j+(a_j \\oplus a_i)$ 这个式子的形式算一下输出就好了，这个式子在这里变成了 $s + (s \\oplus a_i)$，实现过程如下：</p>\n<pre><code class=\"language-cpp\">for (int i = 1; i &lt;= n; ++i) &#123;\n    int s = 0;\n    for (int j = 19; j &gt;= 0; --j) &#123;\n        if (!(a[i] &amp; p[j]) &amp;&amp; f[s | p[j]] &lt;= i) &#123;\n            s |= p[j];\n        &#125;\n    &#125;\n    cout &lt;&lt; s + (a[i] ^ s) &lt;&lt; '\\n';\n&#125;\n</code></pre>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n \nnamespace SHAWN &#123;\n\tconst int N=5e5 + 7, M = 2e6 + 7, INF = 1e9;\n\tint a[N], f[M], p[32];\n\tint n;\n\tsigned work()\n\t&#123;\n\t\tcin &gt;&gt; n;\n        memset(f, 0x7f, sizeof(f));\n\t\tfor (int i = 1; i &lt;= n; ++i) &#123; \n            cin &gt;&gt; a[i];  a[i] ^= a[i - 1]; \n            f[a[i]] = min(f[a[i]], i);\n        &#125;\n\t\tp[0] = 1;\n\t\tfor (int i = 1; i &lt; 20; ++i) &#123; p[i] = p[i - 1] &lt;&lt; 1; &#125;\n\t\tfor (int i = (1 &lt;&lt; 20) - 1;i &gt;= 0; --i) &#123;\n\t\t\tif(f[i] &lt; INF) &#123;\n\t\t\t\tfor (int j = 0; j &lt; 20; ++j) &#123;\n\t\t\t\t\tif(i &amp; p[j]) &#123;\n\t\t\t\t\t\tf[i ^ p[j]] = min(f[i ^ p[j]], f[i]);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\t\t\t\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor (int i = 1; i &lt;= n; ++i) &#123;\n\t\t\tint s = 0;\n\t\t\tfor (int j = 19; j &gt;= 0; --j) &#123;\n\t\t\t\tif (!(a[i] &amp; p[j]) &amp;&amp; f[s | p[j]] &lt;= i) &#123;\n\t\t\t\t\ts |= p[j];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tcout &lt;&lt; s + (a[i] ^ s) &lt;&lt; '\\n';\n\t\t&#125;\n\t\treturn 0;\n\t&#125;\n&#125;\n \nsigned main() &#123;\n\tios :: sync_with_stdio(false);\n\tcin.tie(nullptr);\n\treturn SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "二进制"
            ]
        },
        {
            "id": "http://example.com/2023/09/26/AT_arc129_b%20[ARC129B]%20Range%20Point%20Distance/",
            "url": "http://example.com/2023/09/26/AT_arc129_b%20[ARC129B]%20Range%20Point%20Distance/",
            "title": "题解 AT_arc129_b Range Point Distance",
            "date_published": "2023-09-26T06:57:00.000Z",
            "content_html": "<h1>AT_arc129_b Range Point Distance</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定 $N$ 对 $L_i, R_i$，然后在每次给出后都要选一个 $x$ 使得 $x$ 到之前给出的所有区间的距离 $dist$ 的最大值最小。一个 $x$ 到区间 $l,r$ 的距离定义为 $dist=\\max(0, l - x, x - r)$。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>既然我们每次都要输出答案，那我们不妨从 $dist$ 的定义入手，我们发现在这个定义中，当其结果不为 $0$ 时只有两种情况，要么 $l$ 在 $x$ 右边，要么 $r$ 在 $x$ 左边。那么我们考虑现在有一堆区间，因为我们求的是 $x$ 到所有区间距离的最大值，所以其实我们需要关心的，能够对我们答案造成影响的值就是最靠右的 $L$ 和最靠左的 $R$。得到这个结论后剩下的就比较简单了，我们只需要每次输入一个区间都更新一下这个关键的 $L$ 和 $R$ 即可。</p>\n<p>我们现在知道了能够对我们答案造成影响的两个关键点，那么答案如何求解呢，我们进行分类讨论。</p>\n<ul>\n<li>当 $L \\le R$ 时，意味着之前输入的所有区间都有一个共同的交集 $[L,R]$，这个结论直接从 $L,R$ 的定义得出，那么我们随便在 $L,R$ 里怎么选都是 $0$，所以要找的最小值就是 $0$。</li>\n<li>当 $L &gt;R$ 时，以 $L$ 为左端点的区间和以 $R$ 为右端点的区间一定是之前输入的所有区间里距离最远的一组，只有这一对区间才会产生到 $x$ 的最大值。那么这个最大值最小当且仅当 $x$ 取在 $L,R$ 正中间，又因为要去最大值所以此时 $dist = \\left \\lceil \\frac{L + R}{2}  \\right \\rceil$。</li>\n</ul>\n<p>分析出这两条以后直接在线做就好了，时间复杂度是线性的。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const LL INF = 1e9 + 7;\n    LL n, sl = -INF, sr = INF;\n    signed work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            LL l, r; cin &gt;&gt; l &gt;&gt; r;\n            sl = max(sl, l), sr = min(sr, r);\n            // 更新两个关键点\n            if (sr &gt;= sl) &#123; cout &lt;&lt; &quot;0\\n&quot;; &#125;\n            else cout &lt;&lt; ((sl - sr + 1) &gt;&gt; 1) &lt;&lt; '\\n';\n            // 按照刚刚的分类讨论进行输出\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/26/P1486%20[NOI2004]%20%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98/",
            "url": "http://example.com/2023/09/26/P1486%20[NOI2004]%20%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98/",
            "title": "题解 洛谷 P1486 [NOI2004] 郁闷的出纳员",
            "date_published": "2023-09-26T02:18:00.000Z",
            "content_html": "<h1>P1486 [NOI2004] 郁闷的出纳员</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定 $n$ 次操作和一个阈值 $min$，每次操作包含一个字符 $opt$ 和一个整数 $k$，操作可以是一下四种之一：</p>\n<ul>\n<li><code>I k</code> 如果 $k$ 小于 $min$ 不操作，否则将 $k$ 扔进一个集合 $s$ 中。</li>\n<li><code>A K</code> 把 $s$ 里所有元素值加上 $k$。</li>\n<li><code>S k</code> 把 $s$ 里所有元素值减去 $k$。</li>\n<li><code>F k</code> 查询 $s$ 里第 $k$ 大的值，如果 $k &gt; \\left | s \\right | $ 输出 <code>-1</code>。</li>\n</ul>\n<p>在每次操作中，一旦 $s$ 中有元素的值低于阈值 $min$，就要删除这个元素，程序最后要输出删除的元素总数（插入时就因为小于阈值没有插入进来的不算）</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>我们看到插入，删除，查询排名理所当然地想到了平衡树；看到全加上，全减去，理所当然地想到了线段树。但是很显然，这题肯定不是树套树。我们考虑，既然是全部加，单点查，我们其实并不用关心每个元素的更改，因为集体的更改不会导致排名的变化，只会影响我们后查询值，所以我们可以把这种更改用一个变量 $tag$ 记下来。</p>\n<h3 id=\"插入\">插入</h3>\n<p>在新插入元素的时候，我们要先对插入的元素减去 $tag$，这样做是为了消除其对插入的值的排名的影响。当我们输出的时候，因为这一部分的值刚好被抵消，所以加上的就是插入它以后对它操作的值，满足题目的要求。与此同时我们要拿一个 $sum$ 来记一共插入了多少次，拿一个 $cnt$ 来记当前集合中的元素个数。</p>\n<h3 id=\"元素加减\">元素加减</h3>\n<p>增加元素必然是直接加到 $tag$ 上就好了，但是为了维护集合内小于阈值的数的个数并成功把他们删除，我们必须要同步更改 $min$，如果集体增加就要下调 $min$，集体减少就要上调 $min$。每次减少的时候我们要进行删除操作，我们在平衡树上不断寻找 $min$ 的前驱并删除（一个数的前驱定义为小于它的最大的数），直到删完为止。</p>\n<h3 id=\"查询\">查询</h3>\n<p>查询直接查就好了，需要注意的是平衡树查排名的时候查的是第 $k$ 小，而我们查的是第 $k$ 大，所以查的时候要传的参数是 $cnt - k + 1$。在这里我们不建议更改平衡树的代码，因为平衡树细节较多码量较大，如果在考场上改写可能会导致不必要的错误以及浪费更多时间，除非万不得已，否则建议只在传参上调整。最后只需要输出总的插入次数减去当前集合的大小就是被删掉的元素个数。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;random&gt;\n#include &lt;ctime&gt;\n#include &lt;limits.h&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 2e5 + 7;\n    mt19937 rd(time(nullptr));\n    namespace Treap &#123;\n        #define ls son[ro][1]\n        #define rs son[ro][0]\n        int cont, root;\n        int son[N][2], pre[N], size[N], cnt[N]; LL val[N];\n        void update(int ro) &#123;\n            if (!ro) &#123; return; &#125;\n            size[ro] = cnt[ro];\n            if (ls) &#123; size[ro] += size[ls]; &#125;\n            if (rs) &#123; size[ro] += size[rs]; &#125; \n        &#125;\n        void rotate(int ro, int fa, int opt) &#123;\n            int s = son[ro][opt];\n            son[ro][opt] = son[s][!opt];\n            son[s][!opt] = ro;\n            if (!fa) &#123; root = s; &#125;\n            else &#123; son[fa][son[fa][1] == ro] = s; &#125; \n            update(ro); update(s);\n        &#125;\n        void insert(int ro, int fa, LL x) &#123;\n            if (!ro) &#123;\n                ro = ++cont;\n                cnt[ro] = 1; val[ro] = x;\n                pre[ro] = rd() % INT_MAX;\n                update(ro);\n                if (!fa) &#123; root = ro; &#125;\n                else &#123; son[fa][x &lt; val[fa]] = ro; &#125;\n            &#125;\n            else &#123;\n                if (x == val[ro]) &#123; ++cnt[ro]; update(ro); &#125;\n                else if (x &lt; val[ro]) &#123;\n                    insert(ls, ro, x); update(ro);\n                    if (pre[ls] &lt; pre[ro]) &#123; rotate(ro, fa, 1); &#125;\n                &#125;\n                else &#123;\n                    insert(rs, ro, x); update(ro);\n                    if (pre[rs] &lt; pre[ro]) &#123; rotate(ro, fa, 0); &#125;\n                &#125;\n            &#125;\n        &#125;\n        void del(int ro, int fa, LL x) &#123;\n            if (!ro) &#123; return; &#125;\n            if (x == val[ro]) &#123;\n                --cnt[ro];\n                if (!cnt[ro]) &#123;\n                    int f = fa, s;\n                    update(ro);\n                    while(ls &amp;&amp; rs) &#123;\n                        if (pre[ls] &lt; pre[rs]) &#123; s = ls; rotate(ro, f, 1); f = s; &#125;\n                        else &#123; s = rs; rotate(ro, f, 0); f = s; &#125;\n                    &#125;\n                    while (ls) &#123; s = ls; rotate(ro, f, 1); f = s; &#125;\n                    while (rs) &#123; s = rs; rotate(ro, f, 0); f = s; &#125;\n                    if (root == ro) &#123; root = 0; &#125;\n                    else &#123; son[f][son[f][1] == ro] = 0; &#125;\n                &#125;\n                update(ro);\n            &#125;\n            else &#123;\n                if (x &lt; val[ro]) &#123; del(ls, ro, x); update(ro); &#125;\n                else &#123; del(rs, ro, x); update(ro); &#125;\n            &#125;\n        &#125;\n        LL find_pre(int ro, LL x) &#123;\n            if (!ro) &#123; return LONG_LONG_MIN; &#125;\n            else if (x &gt; val[ro]) &#123; return max(val[ro], find_pre(rs, x)); &#125;\n            else &#123; return find_pre(ls, x); &#125;\n        &#125;\n        LL get_num(int ro, int x) &#123;\n            if (x &lt;= size[ls]) &#123; return get_num(ls, x); &#125;\n            else if (x &lt;= size[ls] + cnt[ro]) &#123; return val[ro]; &#125;\n            else &#123; return get_num(rs, x - size[ls] - cnt[ro]); &#125;\n        &#125;\n        void insert(LL x) &#123; insert(root, 0, x); &#125;\n        void del(LL x) &#123; del(root, 0, x); &#125;\n        LL findpre(LL x) &#123; return find_pre(root, x); &#125;\n        LL getnum(int x) &#123; return get_num(root, x); &#125;\n        #undef ls\n        #undef rs\n    &#125;\n\n    int n; LL _min, tag, cnt, sum;\n    signed work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; _min;\n        for (int i = 1; i &lt;= n; ++i) &#123; \n            char opt; LL k; cin &gt;&gt; opt &gt;&gt; k;\n            if (opt == 'I') &#123;\n                if (k - tag &gt;= _min) &#123;\n                    Treap :: insert(k - tag);\n                    ++cnt; ++sum;\n                &#125;\n            &#125;\n            else if (opt == 'A') &#123; _min -= k; tag += k; &#125;\n            else if (opt == 'S') &#123;\n                _min += k; tag -= k;\n                LL tmp;\n                while ((tmp = Treap :: findpre(_min)) != LONG_LONG_MIN) &#123;\n                    Treap :: del(tmp);\n                    --cnt;\n                &#125;\n            &#125;\n            else if (opt == 'F') &#123;\n                if (cnt &lt; k) &#123; cout &lt;&lt; &quot;-1\\n&quot;; &#125;\n                else &#123; cout &lt;&lt; Treap :: getnum(cnt - k + 1) + tag &lt;&lt; '\\n'; &#125;\n            &#125;\n        &#125;\n        cout &lt;&lt; sum - cnt &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "平衡树;数据结构"
            ]
        },
        {
            "id": "http://example.com/2023/09/26/AT_arc129_a%20[ARC129A]%20Smaller%20XOR/",
            "url": "http://example.com/2023/09/26/AT_arc129_a%20[ARC129A]%20Smaller%20XOR/",
            "title": "题解 AT_arc129_a [ARC129A] Smaller XOR",
            "date_published": "2023-09-26T00:05:00.000Z",
            "content_html": "<h1>AT_arc129_a [ARC129A] Smaller XOR</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你三个数 $N, L, R$，询问满足 $x \\in [L, R]$ 且 $(x \\oplus N) &lt; N$ 的整数 $x$ 的个数。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>我们考虑异或运算的性质，当某一位为 $0$ 时，它异或一个值可能增大或者不变，当某一位为 $1$ 时，它异或一个值可能减小或不变，也就是说一个数 $k$ 想要满足异或一个 $x$ 要比自己原来小，那么 $x$ 最高位的数值要是 $1$，且刚好要能对的上 $k$ 最高位那个 $1$。只要这一位变成 $0$ 了，后面 $x$ 的其它位想怎么取就怎么取，总之不管怎么取都一定比原来的数小。那么假设 $k$ 的第 $p$ 位为最高位，根据前面的分析，$x \\in [2^p,2^{p+1}-1]$ 就可以满足条件，又因为 $x \\in [L,R]$，二者取个交集即可。</p>\n<p>上面我们讨论了能够得到 $x$ 的个数的性质，下面就把它套用在本题上。我们从 $N$ 的最低位开始扫，每当扫到一个 $1$ 就对以这一位为最高位的数计算一下 $x$ 的个数，然后累加起来就是本题的答案。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    LL n, l, r, ans; \n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;\n        for (int i = 0; (1ll &lt;&lt; i) &lt;= n; ++i) &#123;\n            LL xl = 1ll &lt;&lt; i, xr = (xl &lt;&lt; 1) - 1;\n            if (!(xl &amp; n)) &#123; continue; &#125;\n            LL edgel = max(l, xl), edger = min(r, xr);\n            ans = max(ans, ans + edger - edgel + 1);\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "二进制;位运算"
            ]
        },
        {
            "id": "http://example.com/2023/09/21/%E4%B8%80%E5%8F%AA%E5%9C%A8%E5%BD%B9%20OIer%20%E7%9A%84%E8%87%AA%E8%BF%B0/",
            "url": "http://example.com/2023/09/21/%E4%B8%80%E5%8F%AA%E5%9C%A8%E5%BD%B9%20OIer%20%E7%9A%84%E8%87%AA%E8%BF%B0/",
            "title": "一只在役 OIer 的自述",
            "date_published": "2023-09-21T15:00:00.000Z",
            "content_html": "<h1>一只在役 $OIer$ 的自述</h1>\n<p>其实，我早就想写这篇文章了，直到今天我才把它写出来，我想应该不是懈怠使然。这文章本是写给自己的，但我还是想要发出来，我想让应该看见它的人看见它，这不仅仅是一个 $OIer$ 的自白，我相信也是大部分高中生，尤其是竞赛生的自白。所以这篇文章里将以我的感受为主，说我想说的话，当然我相信也是大部分高中生想说的话。</p>\n<p>$OI$ 是一条不归路，只要踏上了这条船，就再也没有回头的机会了。无论我们是否比别人学得晚，哪怕被各种神犇学弟虐得无地自容，我们依旧坚持着 $OI$，因为热忱，因为喜爱。切掉一道题的喜悦，$AK$ 比赛那就更不用说了，甚至调不出来代码时的烦恼，一遍又一遍地静态查错，这些都是令人回味无穷的过程，$OI$ 就是这样地有魅力，有这可以征服人内心的力量。</p>\n<p>$OIer$ 们在学生之间大多是被崇拜的，但是家长们似乎并不喜欢这门竞赛。大抵是因为这门竞赛是高考外的科目，选择了它，似乎便是不务正业了，家长们不希望孩子走弯路，希望他们可以一帆风顺地度过人生。家长们的想法没错，哪个家长不希望自己的孩子能够通过正常的文化课学习裸分考上清华北大？我相信从初衷来讲，世界上没有几个家长是不好的。但是为了照顾热血青年们的任性与梦想，他们还是选择了支持，尽管心理不支持，嘴上也在支持，这是显而易见且无法隐藏的。于是，家长们克服千辛万苦说服了自己的内心，他们告诉我们：“既然选择了这条路，就要坚定地走下去，要破釜沉舟。”如果他们还把高中生尤其是竞赛生当作懵懂的学生的话，那么已经错了一半了。每个学生，尤其是竞赛生内心都有一杆秤，我们会衡量我们做出的所有选择，家长们对我们的殷勤付出，我们当然历历在目，我们都不想辜负家长的期望，更不想和家长吵架。我相信真正细心的家长是可以发现的。但是我们依旧顶着天大的压力选择了竞赛这条路，我们面对的压力其实不比一个成年人少：我们赌上了自己的高中生活以及人生，为了自己的梦想想要拼命一把；我们赌上了和家长的关系，甚至有些 $OIer$ 做好了闹翻的准备；选择了竞赛就意味着，与你并肩作战的战友在考试时全部都是你的敌人，要横着心去扼杀他们的前途，这让竞赛生心里其实很难受，但是没有办法，现实就是如此残酷；他们内心很恐惧，如果竞赛失败，迎接他们的将是炼狱。于是几乎模拟了一遍自己该怎么活后，竞赛生还是毅然决然地踏上了这条不归路，于是家长们开始想办法，给我们找到了最好的资源。</p>\n<p>原本就天大的压力其实对竞赛生来说不算什么，但是外出培训，尤其是一个人外出培训，那种痛苦与绝望是一个人很难接受的。请你想象，一个月的时间里你将不会和同龄人有任何交流，唯一的交流是冷冰冰的题目讲解，不熟悉的环境令你感到恐惧和害怕，那种与世隔绝坠入深渊的孤独感，是普通高中生，也是家长们无法想象的。于是，你受不了了，你的内心世界在逐渐崩塌，你想要调整好心情，想要回忆快乐的事，但迎接你的是第二天模拟赛的摧残，是眼前可怕的 $Wrong ~Answer$，是其它队员看你不懈的目光，是学校里其他的人对外来杂种偷来的鄙夷的眼神。试问一下家长们，你们真的能理解这种心情么？但是家长们没有必要了解，因为他们已经为你求爷爷告奶奶找到了最顶尖的资源，你理所应当认真地珍惜这些机会，然后努力拼搏，努力奋斗！然后一路逆袭，进入省队，杀出金牌，创造神话！怎么样，听着是不是很带感，我也觉得很带感。但是，请你们不要忘记了，竞赛生也是人，他们虽然比普通的学生心智和思想上成熟许多，但是他们的内心都是很脆弱的，远没有装出来的那么坚强，他们为了不让你们失望，说出来的是最坚定的志向，但是他们的内心，真的很害怕，不仅仅害怕进不了省队，还害怕孤独，害怕被嘴。他们抱怨的时候，爸爸妈妈往往会这样说：“这是你自己选的路，你要是想弄我们可以选择回去学文化课，不要一天到晚说些负能量的话，让自己开心起来。”啊，说话真是这个世界上最轻松的事了。有没有人曾想过，他们需要的只是一句安慰，只是一句鼓励，仅此而已。看到这里，你们还觉得自己理解他们吗？但我还是要感谢家长给了我追逐梦想的机会，他们是最爱你的人。</p>\n<p>上了高中以后，真正懂得我内心，给予我抚慰的是我所谓的“姑姑”，其实读者早就知道我们的关系了，读者只是出于疼爱没有拆穿我而已，这些是我知道，也是我能看出来的，无所谓啊，这不重要。交心的事也只有这层关系作为纽带才能够进行，同龄人的心只有最爱你的同龄人才能了解，互为对方的救赎是我们高中的常态，我希望以后也是。我要感谢我的姑姑，她是除了家长以外最爱我，也是最懂我的人，可以说是我活下去，努力下去和憧憬未来的动力。在 $OIer$ 中，最理解我也是对我帮助最大的非小翼龙莫属了，$OIer$ 最懂 $OIer$，我们之间的烦恼是互通的，所以情感自然也是互通的，毕竟同是天涯沦落人，倘若能和小翼龙一起拿到金牌，该是多么令人欣喜的一件事。谢谢小翼龙一直以来都无私地给我讲题，跟我分享烦恼。</p>\n<p>所以啊，这篇文章是我作为一个竞赛生，写给我的家长，写给全体高中生的家长，写给全世界最爱我，最爱你们的人，写给全中国的学生和家长的，也许我说的有点过于广泛，有点不自量力。家长们，请不要指责你的孩子不懂事，你们的一言一行他们都会记在心里；在你的孩子伤心难过时，请多鼓励鼓励他们，他们需要的是你们的支持；请你们不要低估高中生之间的各种感情，真正理解同龄人的只能是同龄人，他们心灵的港湾与艳阳也一定是同龄人；请你们不要直接否定孩子们做出的决定，他们能做出莽撞的决定，是因为他们真的很难受；请记住，对他们的付出以及将他们养大不是你控制他们人生的借口；也请你记住，有些弯路是需要自己走的，你帮他们过去的弯，会成为他们人生的绊脚石；请你们记住，孩子们也有自己的烦恼，虽然与你们的不同，在你们看起来是自己曾经有过的幼稚的烦恼，但请你不要忘记自己当时是怎么度过的；请你们记住，你们并不是一代人，请不要试图用你的理论去理解他的烦恼；最后请你们记住，他们已经是成年人了，不再是温室里的雏鹰了，是芜湖起飞的时候了。</p>\n<p>时间紧迫没有差错，有错别字请忽略，拜谢 $orz$。</p>\n",
            "tags": [
                "OIer 日记"
            ]
        },
        {
            "id": "http://example.com/2023/09/20/CF1204D2%20Kirk%20and%20a%20Binary%20String%20(hard%20version)/",
            "url": "http://example.com/2023/09/20/CF1204D2%20Kirk%20and%20a%20Binary%20String%20(hard%20version)/",
            "title": "题解 CF1204D2 Kirk and a Binary String (hard version)",
            "date_published": "2023-09-20T07:41:00.000Z",
            "content_html": "<h1>CF1204D2 Kirk and a Binary String (hard version)</h1>\n<h2 id=\"形式化题意\">形式化题意</h2>\n<p>给你一个长为 $n$ 的仅包含 $0$ 和 $1$ 的串，要求尽可能多地将里面的 $1$ 改成 $0$ 使得在得到的新串中，对于 $\\forall l,r\\in [1,n](l \\le r)$，两个串的 $[l,r]$ 区间内的最长不降子序列等长。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>题中给的数据范围是 $10^5$，我们很容易去思考一些 $O(n \\log n)$ 的做法，从而去找数据结构来维护，但这是 CF 的题，所以我们坚信这一定是一道人类智慧题。所以我们充分发扬人类智慧，$O(n)$ 来构造这个题。</p>\n<p>对于只有 $0,1$ 的串来讲，一个序列想要不降其实只需要满足两个条件：</p>\n<ul>\n<li>如果当前位为 $0$，那么后面无论 $0,1$ 都是不降的；</li>\n<li>如果当前位为 $1$，那么后面为 $1$ 才是不降的。</li>\n</ul>\n<p>那么我们是不是很容易发现本题的构造原则：一个 $1$ 能够被替换成 $0$ <strong>当且仅当这个 $1$ 后面的 $1$ 的个数大于等于 $0$ 的个数</strong>。这个结论说出来很抽象，我们用一个例子来理解。</p>\n<pre><code>0 1 1 1 1 1 0 0 0\n1 2 3 4 5 6 7 8 9 \n</code></pre>\n<p>为了方便读者观看，这个串下面的数字是其下标。我们以下标为 $2$ 的这个下标的位置为例，$[2,9]$ 区间内的最长不降子序列是 <code>1 1 1 1 1</code>，这一位改成 $0$ 后变成 <code>0 1 1 1 1</code>，不管怎么变长度都不会变，因为其后 $1$ 比 $0$ 多，最长不降子序列一定是连着一坨 $1$。然而对于下标为 $4$ 这个位置的 $1$ 来讲，这一位后面的 $0$ 比 $1$ 多，我们将这一位换成 $0$ 后，$[4,9]$ 区间内的最长不降子序列从 <code>1 1 1</code> 变成了 <code>0 0 0 0</code>，不符合我们的构造条件。</p>\n<p>出现这种情况的原因是，对于当前位来讲，它的最长不降子序列只能是一堆 $1$，这是我们刚刚提到过的结论，改成 $0$ 后就有了三种选择，而我们必须让它别无选择，这就要求更改的这一位只能继续选后面连一堆 $1$，那么我们发现这种别无选择的情况就必须让当前位后的 $1$ 的数量比 $0$ 的数量多，这就证明了我们刚刚得出的结论，这道题也就做完了。</p>\n<p>在写代码的时候，我们可以把维护个数改成维护 $0$ 与 $1$ 的个数的差值，这样可以简化代码难度，当 $0$ 的个数减去 $1$ 的个数非正时就把这一位的 $1$ 换掉。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    string s;\n    int cnt;\n    int work()\n    &#123;\n        cin &gt;&gt; s;\n        for (int i = s.size() - 1; i &gt;= 0; --i) &#123;\n            if (s[i] == '0') &#123; ++cnt; &#125;\n            else if (s[i] == '1' &amp;&amp; cnt &lt;= 0) &#123; s[i] = '0'; &#125;\n            else &#123; --cnt; &#125;\n        &#125;\n        cout &lt;&lt; s &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/20/CF1204D1%20Kirk%20and%20a%20Binary%20String%20(easy%20version)/",
            "url": "http://example.com/2023/09/20/CF1204D1%20Kirk%20and%20a%20Binary%20String%20(easy%20version)/",
            "title": "题解 CF1204D1 Kirk and a Binary String (easy version)",
            "date_published": "2023-09-20T07:41:00.000Z",
            "content_html": "<h1>CF1204D1 Kirk and a Binary String (easy version)</h1>\n<h2 id=\"形式化题意\">形式化题意</h2>\n<p>给你一个长为 $n$ 的仅包含 $0$ 和 $1$ 的串，要求尽可能多地将里面的 $1$ 改成 $0$ 使得在得到的新串中，对于 $\\forall l,r\\in [1,n](l \\le r)$，两个串的 $[l,r]$ 区间内的最长不降子序列等长。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>题中给的数据范围完全可以 $O(n^2)$ 搜过，但这是 CF 的题，所以我们坚信这一定是一道人类智慧题。所以我们充分发扬人类智慧，$O(n)$ 来构造这个题。</p>\n<p>对于只有 $0,1$ 的串来讲，一个序列想要不降其实只需要满足两个条件：</p>\n<ul>\n<li>如果当前位为 $0$，那么后面无论 $0,1$ 都是不降的；</li>\n<li>如果当前位为 $1$，那么后面为 $1$ 才是不降的。</li>\n</ul>\n<p>那么我们是不是很容易发现本题的构造原则：一个 $1$ 能够被替换成 $0$ <strong>当且仅当这个 $1$ 后面的 $1$ 的个数大于等于 $0$ 的个数</strong>。这个结论说出来很抽象，我们用一个例子来理解。</p>\n<pre><code>0 1 1 1 1 1 0 0 0\n1 2 3 4 5 6 7 8 9 \n</code></pre>\n<p>为了方便读者观看，这个串下面的数字是其下标。我们以下标为 $2$ 的这个下标的位置为例，$[2,9]$ 区间内的最长不降子序列是 <code>1 1 1 1 1</code>，这一位改成 $0$ 后变成 <code>0 1 1 1 1</code>，不管怎么变长度都不会变，因为其后 $1$ 比 $0$ 多，最长不降子序列一定是连着一坨 $1$。然而对于下标为 $4$ 这个位置的 $1$ 来讲，这一位后面的 $0$ 比 $1$ 多，我们将这一位换成 $0$ 后，$[4,9]$ 区间内的最长不降子序列从 <code>1 1 1</code> 变成了 <code>0 0 0 0</code>，不符合我们的构造条件。</p>\n<p>出现这种情况的原因是，对于当前位来讲，它的最长不降子序列只能是一堆 $1$，这是我们刚刚提到过的结论，改成 $0$ 后就有了三种选择，而我们必须让它别无选择，这就要求更改的这一位只能继续选后面连一堆 $1$，那么我们发现这种别无选择的情况就必须让当前位后的 $1$ 的数量比 $0$ 的数量多，这就证明了我们刚刚得出的结论，这道题也就做完了。</p>\n<p>在写代码的时候，我们可以把维护个数改成维护 $0$ 与 $1$ 的个数的差值，这样可以简化代码难度，当 $0$ 的个数减去 $1$ 的个数非正时就把这一位的 $1$ 换掉。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    string s;\n    int cnt;\n    int work()\n    &#123;\n        cin &gt;&gt; s;\n        for (int i = s.size() - 1; i &gt;= 0; --i) &#123;\n            if (s[i] == '0') &#123; ++cnt; &#125;\n            else if (s[i] == '1' &amp;&amp; cnt &lt;= 0) &#123; s[i] = '0'; &#125;\n            else &#123; --cnt; &#125;\n        &#125;\n        cout &lt;&lt; s &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/13/CF1537E2%20Erase%20and%20Extend%20(Hard%20Version)/",
            "url": "http://example.com/2023/09/13/CF1537E2%20Erase%20and%20Extend%20(Hard%20Version)/",
            "title": "题解 CF1537E2 Erase and Extend (Hard Version)",
            "date_published": "2023-09-13T12:28:00.000Z",
            "content_html": "<h1>CF1537E2 Erase and Extend (Hard Version)</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一个字符串，找到该字符串的一个前缀并不断复制，可以删除末尾元素，最终要使得得到的字符串长度为 $k$ 且字典序最小。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>对于此类构造题，我们一般需要运用逆向思维，也就是说我们要从前往后扫而不是从后往前删。为什么这样想呢？我们可以发现，字典序最小当且仅当我们要找的前缀的第 $i$ 位比第 $i \\bmod len$ 位的字典序小，这样拼接起来才能够使得字典序最小，这个结论是显然的，证明可以使用反证法。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    int n, k, l = 1;\n    string s;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            if (s[i] &lt; s[i % l]) &#123; l = i + 1; &#125;\n            else if (s[i] &gt; s[i % l]) &#123; break; &#125;\n        &#125;\n        for (int i = 0; i &lt; k; ++i) &#123;\n            cout &lt;&lt; s[i % l];\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/13/CF1537E1%20Erase%20and%20Extend%20(Easy%20Version)/",
            "url": "http://example.com/2023/09/13/CF1537E1%20Erase%20and%20Extend%20(Easy%20Version)/",
            "title": "题解 CF1537E1 Erase and Extend (Easy Version)",
            "date_published": "2023-09-13T03:42:00.000Z",
            "content_html": "<h1>CF1537E1 Erase and Extend (Easy Version)</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一个字符串，找到该字符串的一个前缀并不断复制，可以删除末尾元素，最终要使得得到的字符串长度为 $k$ 且字典序最小。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>对于此类构造题，我们一般需要运用逆向思维，也就是说我们要从前往后扫而不是从后往前删。为什么这样想呢？我们可以发现，字典序最小当且仅当我们要找的前缀的第 $i$ 位比第 $i \\bmod len$ 位的字典序小 ，这样拼接起来才能够使得字典序最小，这个结论是显然的，证明可以使用反证法。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    int n, k, l = 1;\n    string s;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            if (s[i] &lt; s[i % l]) &#123; l = i + 1; &#125;\n            else if (s[i] &gt; s[i % l]) &#123; break; &#125;\n        &#125;\n        for (int i = 0; i &lt; k; ++i) &#123;\n            cout &lt;&lt; s[i % l];\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/09/07/%E6%9C%80%E7%9F%AD%E8%B7%AF/",
            "url": "http://example.com/2023/09/07/%E6%9C%80%E7%9F%AD%E8%B7%AF/",
            "title": "最短路径基础总结",
            "date_published": "2023-09-07T12:34:44.000Z",
            "content_html": "<h2 id=\"operatorname-Floyd-（全源最短路）\">$\\operatorname{Floyd}$（全源最短路）</h2>\n<p>我们定义一个数组 $f_{k,x,y}$ 表示只经过节点 $1$ ~ $k$ 的情况下，$x$ 到 $y$ 的最短路长度，那么显然的，当一个图中节点个数为 $n$ 时，$f_{n,x,y}$ 就是我们所要求的答案。实现 $\\operatorname{Floyd}$ 算法需要我们从 $k=0$ 时的情况逐渐递推到 $k=n$。$k=0$ 时，$x$ 和 $y$​ 不相等的情况下不可能通过任何情况联通，而一个点到自己的距离显然为 $0$，所以我们认为：</p>\n$$\\displaylines{\\left\\{\\begin{matrix}\nf_{0,x,y}(x \\ne y)=\\infty\n \\\\\nf_{0,x,y}(x=y)=0\n\\end{matrix}\\right.\n}$$<p>于是我们就得到了递推式的第一项，我们考虑动态规划。对于每一个点，我都有两种选择：第一种是经过这个点，即 $f_{k-1,x,y}$；而第二种是不经过这个点，即 $f_{k-1,x,k}+f_{k-1,k,y}$ 。我们寻找最短路时只要判断经过当前的点的代价和不经过当前点的代价哪个更小就可以了，所以 $k,x,y$ 都从 $1$ 开始枚举一遍就可以得出答案，下面是具体实现（切勿忘记初始化）：</p>\n<pre><code class=\"language-cpp\">for (int k = 1; k &lt;= n; ++k) &#123;\n\tfor (int x = 1; x &lt;= n; ++x) &#123;\n\t\tfor (int y = 1; y &lt;= n; ++y) &#123;\n            f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k] +f[k-1][k][y]);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>因为 $f_{k-1,x,y}$ 表示的就是当 $k-1$ 这一维中所有元素的最小值，那么该维其它值对于我们来说没有贡献，我们就可以考虑把这一维去掉，将三维数组压缩成二维数组，像这样：</p>\n<pre><code class=\"language-cpp\">for (int k = 1; k &lt;= n; ++k) &#123;\n\tfor (int x = 1; x &lt;= n; ++x) &#123;\n\t\tfor (int y = 1; y &lt;= n; ++y) &#123;\n            f[x][y] = min(f[x][y], f[x][k] + f[k][y]);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>最终我们算法的时间复杂度为 $O(n^3)$，空间复杂度为 $O(n^2)$，常数很小。但是我们发现，当我们要求单源最短路时，这种方法求出的其它最短路对于我们来说就是一种浪费，但这又是无法避免的，所以我们考虑，对于单源最短路有没有其它的做法。</p>\n<h2 id=\"operatorname-Dijkstra-（非负权图单源最短路）\">$\\operatorname{Dijkstra}$（非负权图单源最短路）</h2>\n<p>$\\operatorname{Dijkstra}$ 算法将一张图内所有结点分为了两个集合，其中一个集合内放已经确定了起点到其的最短路的点，另一个放还没有确定最短路的点，我们分别记为 $S$ 和 $T$ 。为了记录源点到每个点的最短路，我们要用一个数组 $dis$。刚开始的时候所有的点都属于集合 $T$，接下来，每一次操作都从 $T$ 中取出最短路长度最小的点放入 $S$ 集合中，对其进行<strong>松弛操作</strong>，什么是松弛呢？我们进行如下定义：对于一条边$(u,v)$，设其边权为 $w$ ，则 $dis_v = min(dis(v),dis(u) + w)$。这个操作就叫做松弛，而它的含义是显而易见的，就是当我们走到一个点的时候考虑要不要去走某一条边。</p>\n<p>那么如何维护这两个集合呢？我们考虑用一个 $used$ 数组来记录当前点以前是否更新过，也就是说记录其是否在集合 $S$ 中。然后每次遍历找到 $T$ 中最小的那个点，对它所有出边进行松弛即可，下面是代码实现：</p>\n<pre><code class=\"language-cpp\">typedef long long LL;\nconst LL N = 2e5 + 7, INF = 1e18;\nstruct edge &#123; LL v, w; &#125;;\nvector&lt;edge&gt; e[N];\nLL dis[N];\nbool used[N];\nLL n, m, b;\n\ninline void Dijkstra(int s) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123; dis[i] = INF; &#125;\n    // 所有点最短路径初始时要置无穷大\n    dis[s] = 0;// 起点到自己的最短路为0\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        LL u = 0, now = LONG_LONG_MAX;\n        // now用来记录当前T中找到的最短路最小的点\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (!used[j] &amp;&amp; dis[j] &lt; now) &#123;\n            // 如果在集合T中且其最短路长比之前找到的还小就更新\n                u = j; \n                now = dis[j];\n            &#125;\n        &#125;\n        used[u] = true;// 放入S集合\n        for (auto it : e[u]) &#123;// 对出边进行松弛\n            auto v = it.v, w = it.w;\n            if (dis[v] &gt; dis[u] + w) &#123;\n                dis[v] = dis[u] + w;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\n</code></pre>\n<p>这样做的时间复杂度是 $O(n^2)$，比刚刚有了很大的提升，但当我们打开一道题，发现数据可能随随便便就超过了 $10^5$，$O(n^2)$ 显然是过不去的，所以我们考虑对其用优先队列进行堆优化。我们发现，在暴力做法中，我们每次都要遍历 $1$ ~ $n$ 去寻找集合 $T$ 中最短路最小的那个点，那么我们就想能不能每次直接从 $T$ 中拿出最短路最小的点。我们考虑每次从堆顶取出一个点，然后判断这个点是否在集合 $T$ 中，如果不在那么扔掉再取下一个，否则就进行松弛，成功松弛后 $u$ 就光荣完成了它的使命，扔进 $S$ 集合中，而 $v$ 就入队排序等待后面把它取出。这样重复直到队列为空，我们也就更新完了所有的点，下面是具体实现：</p>\n<pre><code class=\"language-cpp\">typedef long long LL;\ntypedef pair&lt;LL, LL&gt; PII;\nconst LL N = 2e5 + 7, INF = 1e18;\nstruct edge &#123; LL v, w; &#125;;\nvector&lt;edge&gt; e[N];\npriority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;\nLL n, m, b;\nLL dis[N];\nbool used[N];\n\ninline void Dijkstra(int s) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123; dis[i] = INF; &#125;\n    dis[s] = 0;\n    q.push(&#123;0, s&#125;);\n    while (!q.empty()) &#123;\n        auto t = q.top(); q.pop();\n        // 按照dis排序，每次取出堆顶的点\n        LL u = t.second;\n        if (used[u]) &#123; continue; &#125;\n        // 如果在S集合中就扔掉不管\n        used[u] = true;\n        // u完成使命放入S集合中\n        for (auto it : e[u]) &#123;\n            LL v = it.v, w = it.w;\n            if (dis[v] &gt; dis[u] + w) &#123;\n                dis[v] = dis[u] + w;\n                q.push(&#123;dis[v], v&#125;);\n                // 成功松弛就扔进队列里\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\n</code></pre>\n<p>队列中元素的个数是 $O(m)$ 个，那么维护堆的时间复杂度就是 $O(logm)$，我们对每个点都更新一次，所以优化后的时间复杂度是 $O(mlogm)$。</p>\n<p>我们发现，$\\operatorname{Dijkstra}$ 算法虽然很好用，但是在遇到负边权的时候，每次松弛都会选到负的那条边，因为这样显然更小。松弛后，开始在 $T$ 中寻找下一个点，结果我们发现最小边权的点变成了上次松弛的 $v$，我们又松弛 $v$，再下一次又找到了第一次的 $u$。结果最后我们在负边相连的两个点间反复横跳，这个算法就寄了，这就是为什么 $\\operatorname{Dijkstra}$ 处理的是非负权图单源最短路。那么遇到负权难道我们就得牺牲时间去用 $\\operatorname{Floyd}$ 了么？显然不是，我们还有其它算法。</p>\n<h2 id=\"operatorname-Bellman-Ford-（带负权单源最短路）\">$\\operatorname{Bellman-Ford}$ （带负权单源最短路）</h2>\n<p>$\\operatorname{Bellman-Ford}$ 寻找最短路的方法也是通过和刚刚一样的松弛操作，它每次对所有点都松弛一次，直到松弛到无法松弛为止。一个图内单源最短路的数量最多为 $n-1$，这个结论很平凡。所以松弛操作肯定也是最多执行 $n-1$ 次，那么如果执行多了说明什么？显然是说明有一个负权边使得那两个点开始左右横跳了，那么就判断出了负环。请注意，从 $s$ 点出发没有找到负环并不能说明图中没有负环，只能说明 $s$ 点出发抵达的点和边构成的子图中没有负环。想要判断一个图中有没有负环，需要建立一个超级源点，这个源点和图上每一个点都有一条边且边权均为 $0$，以超级源点为源点跑 $\\operatorname{Bellman-Ford}$ 就一定可以判断出有没有负环。下面是 $\\operatorname{Bellman-Ford}$ 的具体实现：</p>\n<pre><code class=\"language-cpp\">typedef long long LL;\nconst LL N = 2e5 + 7, INF = 1e18;\nstruct edge &#123; LL v, w; &#125;;\nvector&lt;edge&gt; e[N];\nLL n, m, b;\nLL dis[N];\n\ninline bool Bellman_Ford(int s) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123; dis[i] = INF; &#125;\n    dis[s] = 0;\n    bool flag; \n    // flag用来判断循环时有没有进行松弛\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        flag = false;\n        for (int u = 1; u &lt;= n; ++u) &#123;\n            for (auto it : e[u]) &#123;\n                auto v = it.v, w = it.w;\n                if (dis[v] &gt; dis[u] + w) &#123;\n                    dis[v] = dis[u] + w;\n                    flag = true;\n                    // 松弛后打上标记\n                &#125;\n            &#125;\n        &#125;\n        if (!flag) &#123; break; &#125;\n        // 如果没有松弛说明所有路径更新完毕，可以直接结束\n    &#125;\n    // n轮松弛后如果仍然能进行松弛，说明一定存在负环\n    return flag;\n&#125;\n</code></pre>\n<p>最多进行 $n$ 次松弛操作，每轮操作最多进行 $m$ 次松弛，所以 $\\operatorname{Bellman-Ford}$ 的时间复杂度为 $O(nm)$，数据大的题也是过不去的，所以需要对其进行优化，于是就有了一个人们耳熟能详的算法：$\\operatorname{SPFA}$ 算法。</p>\n<p>$\\operatorname{SPFA}$ 的主要思路就是在 $\\operatorname{Bellman-Ford}$ 的基础上，用队列进行优化。我们每次松弛的时候，真正起到实际作用的操作其实只有当 $u$ 为源点或上次被松弛过，这次的松弛操作才有意义，所以我们把每次松弛的点都扔进队列里，只从队列中取出点来松弛就可以降低时间复杂度。**但是请注意，这是一个假算法！**诶，那这很奇怪啊，为什么广为人知，受人追捧的可爱的 $\\operatorname{SPFA}$ 会是一个假算法呢？因为我们用优先队列，并不是忽略或者对哪个点不进行松弛，而是改变了松弛的顺序从而达到优化目的，那么如果遇到刻意构造的数据，就可以轻轻松松将 $\\operatorname{SPFA}$ 卡到 $O(nm)$ 从而让你的程序寄掉。这是某一年国赛带给全体 $OIer$ 的惨痛教训，所以在没有负环的情况下，尽量不要使用 $\\operatorname{SPFA}$。下面给出参考代码：</p>\n<pre><code class=\"language-cpp\">typedef long long LL;\nconst LL N = 1e6 + 7, INF = 1e18;\nstruct edge &#123; LL v, w; &#125;;\nvector&lt;edge&gt; e[N];\nqueue&lt;int&gt; q;\nLL n, m, b;\nLL dis[N], cnt[N];\nbool used[N];\n\ninline bool SPFA(int s) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123; dis[i] = INF; &#125;\n    dis[s] = 0;\n    used[s] = true;\n    q.push(s);\n    while (!q.empty()) &#123;\n        int u = q.front(); q.pop();\n        used[u] = false;\n        for (auto it : e[u]) &#123;\n            auto v = it.v, w = it.w;\n            if (dis[v] &gt; dis[u] + w) &#123;\n                dis[v] = dis[u] + w;\n                cnt[v] = cnt[u] + 1;\n                if (cnt[v] &gt;= n) &#123; return false; &#125;\n                if (!used[v]) &#123; \n                    q.push(v);\n                    used[v] = true; \n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return true;\n&#125;\n</code></pre>\n<p>说了这么多了让我们来理一理，我们最开始因为 $\\operatorname{Floyd}$ 算法求全源最短路对单源最短路的问题又浪费，所以学习了 $\\operatorname{Dijkstra}$，又因为其无法处理负权学习了 $\\operatorname{Bellman-Ford}$。那么，我们需要考虑这样一个问题：如果我们要处理全源最短路，但是数据范围又比较大该怎么办呢？我们是不是可以跑 $n$ 遍 $\\operatorname{Dijkstra}$，这样复杂度也不是很高，但碰到负权就寄了，所以就有了另外一个算法。</p>\n<h2 id=\"operatorname-Johnson-（全源最短路）\">$\\operatorname{Johnson}$（全源最短路）</h2>\n<p>$\\operatorname{Johnson}$ 可以说是前面算法的大杂烩了，$\\operatorname{Dijkstra}$ 和 $\\operatorname{Bellman-Ford}$ 揉在一起再跑。如何处理负环呢，我们首先建立一个超级源点，也就是传说中的 $0$ 号点，前面已经说过了不再赘述。建立好了以后以这个超级源点为源点跑 $SPFA$，其中 $0$ 号点到 $i$ 号点的最短路记为 $newdis_i$。接下来对于边 $(u,v)=w$，将其边权设置为 $w + newdis_u - newdis_v$，然后再跑 $n$ 遍 $\\operatorname{Dijkstra}$，每次求出的 $dis+newdis_v-newdis_u$ 就是答案了。这种做法的正确性在于从 $s$ 到 $t$ 的最短路径长度的势能是没有变的，具体证明见下面这篇博客：<a href=\"https://www.luogu.com.cn/blog/StudyingFather/johnson-algorithm\">正确性证明</a>。下面是参考代码：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#define LL long long\n#define PII pair&lt;LL, LL&gt;\n#define clear(cc) memset(cc, 0, sizeof(cc))\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const LL N = 6e3 + 7, INF = 1e9;\n    struct edge &#123; LL v, w; &#125;;\n    vector&lt;edge&gt; e[N];\n    LL n, m;\n    LL dis[N], newdis[N];\n    int cnt[N];\n    bool used[N];\n\n    inline bool SPFA(int s) &#123;\n        queue&lt;int&gt; sq;\n        for (int i = 1; i &lt;= n; ++i) &#123; newdis[i] = INF; &#125;\n        clear(used);\n        newdis[s] = 0;\n        used[s] = true;\n        sq.push(s);\n        while (!sq.empty()) &#123;\n            int u = sq.front(); sq.pop();\n            used[u] = false;\n            for (auto it : e[u]) &#123;\n                LL v = it.v, w = it.w;\n                if (newdis[v] &gt; newdis[u] + w) &#123;\n                    newdis[v] = newdis[u] + w;\n                    cnt[v] = cnt[u] + 1;\n                    if (cnt[v] &gt; n) &#123; return false; &#125;\n                    // 注意这里因为插入了超级源点，所以要多跑一轮，&gt;=要变成&gt;\n                    if (!used[v]) &#123;\n                        sq.push(v);\n                        used[v] = true;\n                    &#125; \n                &#125;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n    inline void Dijkstra(int s) &#123;\n        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;\n        for (int i = 1; i &lt;= n; ++i) &#123; dis[i] = INF; &#125;\n        clear(used);\n        dis[s] = 0;\n        q.push(&#123;0,s&#125;);\n        while (!q.empty()) &#123;\n            auto t = q.top(); q.pop();\n            int u = t.second;\n            if (used[u]) &#123; continue; &#125;\n            used[u] = true;\n            for (auto it : e[u]) &#123;\n                LL v = it.v, w = it.w;\n                if (dis[v] &gt; dis[u] + w) &#123;\n                    dis[v] = dis[u] + w;\n                    q.push(&#123;dis[v], v&#125;);\n                &#125;\n            &#125;\n        &#125;\n        return;\n    &#125;\n    \n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1, x, y, z; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n            e[x].push_back(&#123;y, z&#125;);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123; e[0].push_back(&#123;i, 0&#125;); &#125;\n        // 建立超级源点\n        if (!SPFA(0)) &#123; cout &lt;&lt; &quot;-1\\n&quot;; return 0;&#125;\n        // 先跑SPFA预处理边权\n        for (int u = 1; u &lt;= n; ++u) &#123;\n            for (int i = 0; i &lt; e[u].size(); ++i) &#123;\n                e[u][i].w += newdis[u] - newdis[e[u][i].v];\n            &#125;\n        &#125;\n        // 更改每条边的边权\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            Dijkstra(i);// 跑n遍Dijkstra就做完了\n            LL ans = 0;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (dis[j] == INF) &#123; ans += j * INF; &#125;\n                else  &#123; ans += j * (dis[j] + newdis[j] - newdis[i]); &#125;\n            &#125;\n            cout &lt;&lt; ans &lt;&lt; '\\n';\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n<p>这样的时间复杂度是 $O(nmlogm)$，相比 $\\operatorname{Floyd}$ 还是非常优化的。</p>\n<h2 id=\"总结\">总结</h2>\n<p>想要求单源最短路，可以选择 $\\operatorname{Dijkstra}$ 或 $\\operatorname{Bellman-Ford(SPFA)}$，时间复杂度分别为 $O(mlogm)$ 和 $O(nm)$，前者只能处理非负权图，而后者可以处理带负权图。想要求全源最短路，可以选择 $\\operatorname{Floyd}$ 或 $\\operatorname{Johnson}$，时间复杂度分别为 $O(n^3)$ 和 $O(nmlogm)$，二者均可以处理带负权图。也就是说除了 $\\operatorname{Dijkstra}$，其余的三个算法均可以处理带负权图以及判断负环。比赛时尽量使用 $\\operatorname{Dijkstra}$ 和 $\\operatorname{Johnson}$，不到迫不得已尽量不要用剩下两种，否则很容易被卡。</p>\n<p>以上就是全部内容，如有错误欢迎各位大佬指正。</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<p><a href=\"https://oi-wiki.org/graph/shortest-path/\">OI-Wiki 最短路</a></p>\n<p><a href=\"https://www.luogu.com.cn/blog/StudyingFather/johnson-algorithm\">[洛谷日报#242]Johnson 全源最短路径算法学习笔记</a></p>\n<p>《算法导论（第3版）》</p>\n",
            "tags": [
                "图论"
            ]
        },
        {
            "id": "http://example.com/2023/09/07/%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%A0%E4%B9%9F%E7%8E%A9%E5%8E%9F%E7%A5%9E%EF%BC%81%EF%BC%9F/",
            "url": "http://example.com/2023/09/07/%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%A0%E4%B9%9F%E7%8E%A9%E5%8E%9F%E7%A5%9E%EF%BC%81%EF%BC%9F/",
            "title": "什么？你也玩原神！？",
            "date_published": "2023-09-07T12:34:44.000Z",
            "content_html": "<h1>困至极点 故作此文 以振精神</h1>\n<h2 id=\"引言\">引言</h2>\n<p>我有一个惊为天人的特性，很多人都有，但是他们都没有发现过。然而就在今天，我，发现了！每个人都是由许许多多的原子构成的。~~这样好呀！我是由原子构成的！好耶好耶！~~咳咳，既然这样，我们就是有正电荷的生物。那么为什么我们对外不显电性呢？上过幼儿园的小朋友们应该都知道，原子核外有电子，电子带负电荷，正电荷吸引着负电荷围着它转，又或者两个原子之间有公共电子，这样整个环境就会成电中性，我们也就不带电。</p>\n<p><strong>但是！重点来了！</strong></p>\n<p>首先说一些前置芝士：</p>\n<ul>\n<li>电流是电子在导体中做定向移动产生的；</li>\n<li>石墨的导电原理是其平面六边形结构可以使得一个电子在原子之间移动，去替换本身原子周围的电子，循环往复使得电子产生定向移动；</li>\n</ul>\n<p>知道了这些以后，神奇的事情就发生了，只要我们使自己体内的电子开始做定向移动，我们不就可以产生电流了吗！我好聪明！快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我快夸我。但是，我们移动电子是需要能量的，这些能量从哪里来呢？很很很很很简单，**只要疯狂发电就可以啦！**没错，这篇文章就是教你如何发电的！你，真的会发电吗？</p>\n<hr>\n<h2 id=\"你知道吗？\">你知道吗？</h2>\n<p>哈哈嗨，小朋友，你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？你知道吗？死者在死之前居然是活着的！</p>\n<p><img src=\"https://pic.imgdb.cn/item/6521014dc458853aef2e013e.jpg\" alt=\"\"></p>\n<p>你看大家都不知道，所以你知道吗？你知道？不信，除非你知道。如果你知道，那你是一定不可能不知道的，否则你就是一定知道的，别想骗我，我知道你知道自己知不知道。而且这种规律是一通百通的，你知道了一个，就会知道很多，比方说：人在睡着之前一定是醒着的，喝水的时候水一定不会凭空消失，十八世纪去世的人一定比十九世纪去世的人去世得早等等等等。所以，我们需要有一对明亮的双眼，去探查和发现这个世界上有意思的事情，说不定你们也能像我一样发现这些让人惊叹的规律呢？</p>\n<hr>\n<h2 id=\"我好想做-mlg-小姐的狗啊！\">我好想做 $mlg$ 小姐的狗啊！</h2>\n<p>我好想做 $mlg$ 小姐的狗啊。</p>\n<p>可是 $mlg$ 小姐说她喜欢的是生物满分，我哭了。</p>\n<p>我知道既不是狗也不是生物满分的我为什么要哭的。因为我其实是一只 $OIer$。</p>\n<p>我从没奢望 $mlg$ 小姐能喜欢自己。我明白的，所有人都喜欢各科满分的年一和其它学科竞赛生，没有人会喜欢阴湿带病的 $OIer$。</p>\n<p>但我还是问了 $mlg$ 小姐:“我能不能做你的狗？”</p>\n<p>我知道我是注定做不了狗的。但如果她喜欢狗，我就可以一直在身边看着她了，哪怕她怀里抱着的永远都是狗。</p>\n<p>可是她说喜欢的是生物满分。</p>\n<p>她现在还在看着我，还在教我学习，是因为满分还没有出现，只有我这 $OIer$ 每天努力地写完代码、作业，背着生物书，远远地和她对视。</p>\n<p>等她喜欢的满分来了的时候，我就该重新滚回我的机房了吧。</p>\n<p>但我还是好喜欢她，她能在我还在她身边的时候多看我几眼吗？</p>\n<p>$mlg$ 小姐说接下来的每次大练习都要和大家一起过。我不知道大家指哪些人。好希望这个集合能够对我做一次胞吞。</p>\n<p>满分还在害怕 $mlg$ 小姐。</p>\n<p>我会去把她爱的满分引来的。</p>\n<p>我知道稍有不慎，我就会被虐得体无完肤。</p>\n<p>那时候 $mlg$ 小姐大概会责备我牺牲了生物而去学 $OI$ 吧。</p>\n<p>那我就该要 $AFO$ 了，嘻嘻。</p>\n<p>我希望她能把我扔得近一点，因为我还是好喜欢她。会一直喜欢下去的。</p>\n<p>我的灵魂透过窗户向办公室里面看去，挂着的铃铛在轻轻鸣响，$mlg$ 小姐平静地站在办公桌前，表演得非常温顺的满分坐在她的肩膀。日光灯的灯光照在她的脸庞，我冻僵的心脏在风里微微发烫。</p>\n<hr>\n<h2 id=\"什么，你也是死傲娇？\">什么，你也是死傲娇？</h2>\n<p><strong>注：本文灵感来自 Acc 怪话</strong></p>\n<p>翼竜が大嫌いです。</p>\n<p>私よりずっと背が高くて、身長だけでなく、彼のとんでもない $OI$ レベルもあって、私はどうしても追いつけなくて、大嫌いです。</p>\n<p>翼竜には $\\operatorname{240Hz}$ の高ブラシがあり、超強力なグラフィックスカードがあり、彼には妹がいて、このようなリア充は、大嫌いです。</p>\n<p>$CS：GO$ を打つ彼のレベルもいつも私を轢いて、毎回打てない、大嫌い！</p>\n<p>嫌だ嫌だ死ぬ！どうして彼はこんなに明るくて、私はそんなに暗くて光がないの！？</p>\n<p>しかし</p>\n<p>私はできないときは根気よく問題を教えてくれますし、私が楽しくないときは慰めてくれますし、暇があればゲームをしてくれますし……いろいろなことを教えてくれたり、$OI$の勉強方法を教えてくれたり……。</p>\n<p>いやだ！なんて鈍いんだ！どうして気づかないの！大好きなのに！好き、好き、大好き！</p>\n<p>中文译文：</p>\n<p>最讨厌小翼龙了。</p>\n<p>比我高那么多，不只是身高，还有他那逆天的 $OI$ 水平，我怎么都赶不上，最讨厌了。</p>\n<p>小翼龙有 $\\operatorname{240Hz}$ 的高刷屏，还有超强的显卡，他还有个妹妹，这样的现充，最讨厌了。</p>\n<p>就连打 $CS:GO$ 他的水平也总是碾压我，每次都打不过，最讨厌了！</p>\n<p>讨厌讨厌讨厌死了！为什么他这样的光鲜亮丽，而我那样的黯淡无光！？</p>\n<p>可是</p>\n<p>我不会的时候会耐心的给我讲题，我不开心的时候会安慰我，有空了就会陪我打游戏……还经常教我各种各样的东西，教我怎么学 $OI$……</p>\n<p>讨厌！怎么这么迟钝啊！怎么察觉不到啊！明明最喜欢了！suki，suki，da i suki！</p>\n<hr>\n<h2 id=\"我有显卡啦！\">我有显卡啦！</h2>\n<p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻麻！</p>\n<p><strong>我有显卡啦！</strong></p>\n<p>一个声音：扔出去！把 $zyc$ 从机房扔出去！</p>\n<p><img src=\"https://pic.imgdb.cn/item/652109d4c458853aef36172e.png\" alt=\"那个声音的手绘作品\"></p>\n<hr>\n<h2 id=\"意义\">意义</h2>\n<p>我并不知道人生的意义所在，但我知道有些事情一定是有意义的。请你记住，你身边的所有人，所有事物都会离开你，他们并非出于恶意，但是离开与分别是不可避免的。而唯一能帮助你的，唯一不会离开你的，只有原神！</p>\n<p>是的！没错！原神，不会背叛你！</p>\n<p>所以，来玩原神吧，少年！</p>\n<p><img src=\"https://pic.imgdb.cn/item/652cf1fac458853aef43a0ef.png\" alt=\"\"></p>\n<hr>\n<p>$To~~be~~continued$ ~</p>\n",
            "tags": [
                "雷电法王"
            ]
        },
        {
            "id": "http://example.com/2023/09/07/Tarjan/",
            "url": "http://example.com/2023/09/07/Tarjan/",
            "title": "Tarjan 基础用法",
            "date_published": "2023-09-07T08:18:38.000Z",
            "content_html": "<h2 id=\"operatorname-Tarjan-求最近公共祖先\">$\\operatorname{Tarjan}$ 求最近公共祖先</h2>\n<h3 id=\"前置芝士\">前置芝士</h3>\n<p><strong>最近公共祖先(Lowest Common Ancestor , LCA)</strong>：一棵树中两个结点的 公共祖先里面，离根最远的那个被称为最近公共祖先。我们记点集 $S=\\{v_1,v_2,\\dots,v_n\\}$ 的最近公共祖先为 $\\operatorname{LCA}(v_1,v_2,\\dots,v_n)$ 或 $\\operatorname{LCA}(S)$。</p>\n<p><strong>性质</strong>：</p>\n<ul>\n<li>$\\operatorname{LCA}(\\{u\\}=u)$；</li>\n<li>$u$ 是 $v$ 的祖先当且仅当 $\\operatorname{LCA}(u,v)=u$；</li>\n<li>若 $u$ 和 $v$ 互相都不是对方的祖先，则 $u,v$ 分别处于 $\\operatorname{LCA}(u,v)$ 的两棵不同子树中；</li>\n<li>前序遍历，$\\operatorname{LCA}(S)$ 出现在所有 $S$ 中元素之前，后序遍历，$\\operatorname{LCA}(S)$ 出现在所有 $S$ 中元素之后；</li>\n<li>两点集的并的最近公共祖先为两点集各自最近公共祖先的最近公共祖先，即$\\operatorname{LCA}(A \\cup B)=\\operatorname{LCA}(\\operatorname{LCA}(A),\\operatorname{LCA}(B))$；</li>\n<li>两结点的最近公共祖先一定在其这两点最短路上</li>\n<li>设 $d$ 为树上两点间的距离，$h$ 为一个点到树根的距离，则 $d_{uv}=h_u+h_v-2h(\\operatorname{LCA}(u,v))$</li>\n</ul>\n<h3 id=\"实现过程\">实现过程</h3>\n<p>请注意啦，$\\operatorname{Tarjan}$ 是一个离线算法，所以只能处理离线的 $\\operatorname{LCA}$ 询问，在线需要使用其它方法。但是 $\\operatorname{Tarjan}$ 可以在一次搜索后求出所有点对的 $\\operatorname{LCA}$，所以仍然具有研究价值。</p>\n<ol>\n<li>首先我们要建立两个链表，$edge$ 用来存树，而 $qedge$ 用来存储一种查询关系，即对于一个点 $u$，$qedge$ 要记录点 $u$ 都与哪些其它点存在询问；</li>\n<li>接下来我们对整棵树开始 $\\operatorname{DFS}$，用 $vis$ 记录是否访问过，用 $fa_i$ 表示 $i$ 的父亲，由于 $\\operatorname{DFS}$ 的基本思想是每次只关心当前这一级，所以我们认为当前搜到的点 $u$ 就是以 $u$ 为根的子树的根，<s>这句话看似是废话其实也是废话</s>，这么写是为了提醒读者在搜索开始时要把这个点的父亲设置为自己，也就是非常容易遗忘的初始化操作；</li>\n<li>回溯的时候将 $fa_v$ 设置为 $u$，也就是逐级递归找爸爸；</li>\n<li>在回溯期间，如果包含当前节点的查询的另一个结点也访问过了，就可以更新这两个点的 $\\operatorname{LCA}$ 了；</li>\n<li>最后统计输出答案的时候，不要忘记使用刚刚我们学到的最后一个性质来辅助我们。</li>\n</ol>\n<p>核心代码就长这样：</p>\n<pre><code class=\"language-cpp\">void Tarjan(int u) &#123;// 递归每一层都处理当前节点的子树\n    fa[u] = u;// 初始化\n    vis[u] = true;\n    for (int i = head[u]; i; i = edge[i].next) &#123;// 向下搜索\n        int v = edge[i].to;\n        if (!vis[v]) &#123;\n            Tarjan(v);\n            fa[v] = u;\n        &#125;\n    &#125;\n    for (int i = qhead[u]; i; i = qedge[i].next) &#123;\n        // 搜索并标记含有 u 结点的所有询问\n        int v = qedge[i].to;\n        if (vis[v]) &#123;// 两个结点必须都被标记过\n            qedge[i].lca = find(v);// 标记 LCA\n            // 2n-1与2n的结果相同\n            if (i % 2) &#123; qedge[i + 1].lca = qedge[i].lca; &#125;\n            else &#123; qedge[i - 1].lca = qedge[i].lca; &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"例题\">例题</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3379\">模板 最近公共祖先（LCA）</a></p>\n<p>这就是个模板题，把上面那段代码套上去补完剩下的建图部分就可以了，所以不必过多赘述。</p>\n<p>参考代码：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    int head[N], cnt;\n    int qhead[N], qcnt;\n    struct node &#123; int to, next, lca; &#125;;\n    node edge[N], qedge[N]; \n    int n, m, s;\n    int fa[N];\n    bool vis[N];\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n    inline void qadd(int u, int v) &#123;\n        qedge[++qcnt].next = qhead[u];\n        qedge[qcnt].to = v;\n        qhead[u] = qcnt;\n    &#125;\n    int find(int x) &#123;\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    &#125;\n\n    void Tarjan(int u) &#123;\n        fa[u] = u;\n        vis[u] = true;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!vis[v]) &#123;\n                Tarjan(v);\n                fa[v] = u;\n            &#125;\n        &#125;\n        for (int i = qhead[u]; i; i = qedge[i].next) &#123;\n            int v = qedge[i].to;\n            if (vis[v]) &#123;\n                qedge[i].lca = find(v);\n                if (i % 2) &#123; qedge[i + 1].lca = qedge[i].lca; &#125;\n                else &#123; qedge[i - 1].lca = qedge[i].lca; &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n        for (int i = 1, x, y; i &lt; n; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            add(x, y); add(y, x);\n        &#125;\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            qadd(x, y); qadd(y, x);\n        &#125;\n        Tarjan(s);\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            cout &lt;&lt; qedge[i &lt;&lt; 1].lca &lt;&lt; '\\n';\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n<h2 id=\"operatorname-Tarjan-求割点、割边\">$\\operatorname{Tarjan}$ 求割点、割边</h2>\n<h3 id=\"前置芝士-2\">前置芝士</h3>\n<p><strong>割点</strong>：在一个无向连通图 $G(V,E)$ 中，删去结点 $u$ 和与它相连的边后，若该图变为非连通图，则称结点 $u$ 为该图的<strong>割点（关节点）</strong>。</p>\n<p><strong>割边</strong>：在一个无向连通图 $G(V,E)$ 中，删去边 $e$ 后，若该图变为非连通图，则称边 $e$ 为该图的<strong>割边（桥）</strong>。</p>\n<p>如下图中的 $2$ 点和 $6$ 点为割点，边 $(1,2)$ 和边 $(6,7)$ 为割边：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/22/pPJeMZj.png\" alt=\"\"></p>\n<p><strong>重连通图</strong>：一个不含割点的连通图称为<strong>重连通图（双连通图）</strong>。重连通无向图重每对顶点之间至少存在两条路径，下图就是一个重连通图：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/22/pPJelon.png\" alt=\"\"></p>\n<p><strong>一些性质</strong>：</p>\n<ul>\n<li>两个割点之间的边不一定是割边</li>\n<li>割边的两个端点不一定都是割点，但一定有一个是割点</li>\n</ul>\n<h3 id=\"operatorname-Tarjan-求割点\">$\\operatorname{Tarjan}$ 求割点</h3>\n<p>比方说我们对刚刚这个图求割点：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/22/pPJeMZj.png\" alt=\"\"></p>\n<p>我们从结点 $2$ 开始深度优先遍历，可以得到如下深度优先生成树，实线边构成树边，虚线边构成回边：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/22/pPJeQds.png\" alt=\"\"></p>\n<p>设原图为 $G(V,E)$，其深度优先生成树为 $T(V,E)$ ，则 $G$ 和 $T$ 具有如下的性质：</p>\n<ul>\n<li>$\\forall u \\in V(T)$ ，要么是根，要么不是根</li>\n<li>$u$ 为根时，$u$ 是割点 $\\Leftrightarrow $ $u$ 有 $2$ 棵或 $2$ 棵以上的子树</li>\n<li>$u$ 不为根时，$u$ 是割点 $\\Leftrightarrow $ $u$ 存在儿子 $v$ 使得 $low_v \\ge dfn_u$</li>\n</ul>\n<p>我们发现性质里有一些陌生的东西，$dfn$ 和 $low$，这两个东西分别叫做<strong>深度优先数</strong>和<strong>最低深度优先数</strong>。我们在刚刚 $\\operatorname{DFS}$ 遍历的时候按照 $\\operatorname{DFS}$ 序给每个结点打上时间戳，这些时间戳就是深度优先数，我们用 $dfn$ 数组来存储它。如上图生成树中，$dfn_2=1$，$dfn_1=2$，$dfn_3=3$，$dfn_4=5$，$dfn_5=6$，$dfn_6=4$，$dfn_7=7$。而最低深度优先数 $low$ 则表示从结点 $u$ 出发能到达的点的最小深度优先数，其决定式如下：</p>\n$$\\displaylines{low_u=min\\left\\{\\begin{matrix}\n dfn_u\\\\\n low_v(u,v\\in V(T),v是u的孩子)\\\\\n dfn_v(u,v\\in V(T),(u,v)是一条回边)\n\\end{matrix}\\right.\n}$$<p>那么知道了这些我们再回过头去看刚刚第三个性质，当 $v$ 是 $u$ 的儿子且 $low_v&lt;dfn_u$ 时，以 $v$ 为根节点的子树中必然有节点与 $u$ 的祖先有回边，如果 $u$ 的任意儿子都满足这个特点时，$u$ 显然不是割点。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3388\">模板 P3388 【模板】割点（割顶）</a></p>\n<p>参考代码：</p>\n<pre><code class=\"language-cpp\">namespace SHAWN &#123;\n    const int N = 2e5 + 7;// 双向边开二倍空间\n    int head[N], cnt;\n    struct edge&#123; int to, next; &#125;edge[N];\n    int dfn[N], low[N];\n    bool used[N], flag[N];\n    int n, m, res, tim; \n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u, int fa) &#123;\n        used[u] = true;\n        low[u] = dfn[u] = ++tim;\n        int child = 0;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!used[v]) &#123;\n                if (fa == u) &#123; ++child; &#125;\n                Tarjan(v, u);\n                // 如果v是u的孩子\n                low[u] = min(low[u], low[v]);\n                // 如果u不是根且low[u] &gt;= dfn[u]就是割点 \n                if (fa != u &amp;&amp; low[v] &gt;= dfn[u] &amp;&amp; !flag[u]) &#123;\n                    flag[u] = true;\n                    ++res;\n                &#125; \n            &#125;\n            // 如果(u,v)是一条回边\n            else if (fa != v) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125;\n        // 如果u是根且有两个或两个以上子树就是割点\n        if (fa == u &amp;&amp; child &gt;= 2 &amp;&amp; !flag[u]) &#123;\n            flag[u] = true;\n            ++res;\n        &#125;\n    &#125;\n\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            add(x, y); add(y, x);\n        &#125;\n        // 不保证连通所以要多次跑\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (!used[i]) &#123;\n                tim = 0;\n                Tarjan(i, i);\n            &#125;\n        &#125;\n        cout &lt;&lt; res &lt;&lt; '\\n';\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (flag[i]) &#123; cout &lt;&lt; i &lt;&lt; ' '; &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"operatorname-Tarjan-求割边\">$\\operatorname{Tarjan}$ 求割边</h3>\n<p>设原图为 $G(V,E)$，其深度优先生成树为 $T(V,E)$ ，则 $G$ 和 $T$ 满足如下定理：</p>\n<p>$\\exists u,v \\in T$，$u$ 是 $v$ 的双亲，$u,v$ 之间的边不是有重边，则 $(u,v)$ 是割边 $\\Leftrightarrow $ $u$ 到 $v$ 的边不是重边且 $v$ 或 $v$ 的子孙结点中没有指向 $u$ 或着 $u$ 的祖先的回边。即 $(u,v)$ 是割边 $\\Leftrightarrow$ $dfn_u&lt;low_v$。</p>\n<p>然后我们把刚刚代码稍微改一改就出来了，像这样：</p>\n<pre><code class=\"language-cpp\">void Tarjan(int u, int fa) &#123;\n    par[u] = fa;\n    low[u] = dfn[u] = ++tim;\n    for (int i = head[u]; i; i = edge[i].next) &#123;\n        int v = edge[i].to;\n        if (!dfn(v)) &#123;\n            Tarjan(v, u);\n            low[u] = min(low[u], low[v]);\n            if (low[v] &gt; dfn[u]) &#123;\n                flag[v] = true;\n                ++res;\n            &#125;\n        &#125;\n        else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) &#125;&#123;\n            low[u] = min(low[u], dfn[v]);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>最后当 $flag_u$ 为真时，边 $(u,par_u)$ 就是割边。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1656\">模板 P1656 炸铁路</a></p>\n<p>参考代码：</p>\n<pre><code class=\"language-cpp\">namespace SHAWN &#123;\n    const int N = 1e4 + 7;\n    int head[N], cnt;\n    struct edge &#123; int to, next; &#125;edge[N];\n    struct node &#123; int a, b; &#125;;\n    int dfn[N], low[N];\n    int n, m, tim;\n    struct cmp&#123; \n        bool operator() (const node &amp;x, const node &amp;y) const &#123;\n            if (x.a != y.a) &#123; return x.a &gt; y.a; &#125;\n            else &#123; return x.b &gt; y.b; &#125;\n        &#125;\n    &#125;;\n    priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; q;\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u, int fa) &#123;\n        low[u] = dfn[u] = ++tim;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!dfn[v]) &#123;\n                Tarjan(v, u);\n                low[u] = min(low[u], low[v]);\n                if (low[v] &gt; dfn[u]) &#123;\n                    q.push(&#123;u,v&#125;);\n                &#125;\n            &#125;\n            else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125;\n    &#125;\n\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            add(x, y); add(y, x);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (!dfn[i]) &#123;\n                Tarjan(i, i);\n            &#125;\n        &#125;\n        while (!q.empty()) &#123;\n            auto it = q.top(); q.pop();\n            cout &lt;&lt; it.a &lt;&lt; ' ' &lt;&lt; it.b &lt;&lt; '\\n';\n        &#125;\n        return 0;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"例题-2\">例题</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5058\">1、割点 [ZJOI2004] 嗅探器</a></p>\n<p><strong>题目分析</strong></p>\n<p>题目要求我们删掉一个点使得给定的两个点不连通，那么其实我们就是要找一个满足要求的割点，如下图标黑的点就是题目给定的两个点：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/23/pPJqc80.png\" alt=\"\"></p>\n<p>点 $1$ 是一个割点，我们删除点 $1$ 即可使得 $2,4$ 两点不连通，但是并非任意割点都满足要求，比方说下面这张图：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/23/pPJqg2V.png\" alt=\"\"></p>\n<p>点 $3$ 和点 $4$ 都是图中的割点，但是删去 $4$ 并不能使得目标点 $1,7$ 不连通，所以只有点 $3$ 是符合条件的点，那么我们就要去筛选割点中符合要求的点。</p>\n<p>怎么筛呢？其实我们想一想建立 $\\operatorname{DFS}$ 树的过程，我们从题中给定的一个点开始搜，那么对于一个符合条件的割点来讲，题中给定的另一个点一定在这个符合条件的割点的子树中。所以在搜的时候加个判断条件就好了。本题因为不能删去根，所以不用考虑根是割点的情况，那么代码也就非常简单：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    int head[N], cnt;\n    struct edge &#123; int to, next; &#125;edge[N];\n    int n, tim, x, y;\n    int dfn[N], low[N];\n    bool vis[N], flag[N];\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u, int fa) &#123;\n        low[u] = dfn[u] = ++tim;\n        vis[u] = true;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!vis[v]) &#123;\n                Tarjan(v, u);\n                low[u] = min(low[u], low[v]);\n                // 这里多加一个u!=x和dfn[y]&gt;=dfn[v]的特判就OK了\n                if (fa != u &amp;&amp; low[v] &gt;= dfn[u] &amp;&amp; u != x &amp;&amp; dfn[y] &gt;= dfn[v]) &#123;\n                    flag[u] = true;\n                &#125;\n            &#125;\n            else if (fa != v) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125;\n    &#125;\n\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        while (cin &gt;&gt; x &gt;&gt; y &amp;&amp; x &amp;&amp; y) &#123;\n            add(x, y); add(y, x);\n        &#125;\n        cin &gt;&gt; x &gt;&gt; y;\n        Tarjan(x, x);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (flag[i]) &#123;\n                cout &lt;&lt; i &lt;&lt; '\\n';\n                return 0;\n            &#125;\n        &#125;\n        cout &lt;&lt; &quot;No solution\\n&quot;;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n<p><a href=\"https://www.luogu.com.cn/problem/P7687\">2、割边 [CEOI2005] Critical Network Lines</a></p>\n<p><strong>题目分析</strong></p>\n<p>与上一道题一样，我们显然可以看出来题目想让我们求出满足下面条件的割边——删掉这条边后剩下的两个连通块中至少一个块只包含 $A$ 类点或 $B$ 类点。比如下图（图中边上的数字是编号不是边权）：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/24/pPYBlad.png\" alt=\"\"></p>\n<p>这幅图中的割边有 $1,4,5,6,8$ 五条，而符合题目条件的只有 $1,6,8$ 这三条。我们发现，当一个割边满足条件当且仅当它连接的一个节点在深度优先生成树中的子树内只包含一类点。所以我们在 $\\operatorname{Tarjan}$ 求割边的时候，每找到一条割边 $(u,v)$，我们就检查一下以 $v$ 为根结点的子树内 $A$ 和 $B$ 类结点各自的数量，当其中一个个数为 $0$ 或者全满，就是要求的边，打上标记并给计数的答案加一就可以了。求数量的过程，可以在 $\\operatorname{DFS}$ 的时候递归计算。下面是 AC 代码：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 2e6 + 7;\n    // 请注意这里一定要开二倍空间，要不然会寄\n    int head[N], cnt;\n    struct edge &#123; int to, next; &#125;edge[N];\n    int n, m, a, b, tim, res;\n    int dfn[N], low[N], acnt[N], bcnt[N], par[N];\n    // acnt[i]表示i结点子树中A类点数量，bcnt同理\n    // par用来记每个结点在dfs生成树中的父亲\n    bool flag[N];\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u, int fa) &#123;\n        low[u] = dfn[u] = ++tim;\n        par[u] = fa;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!dfn[v]) &#123;\n                Tarjan(v, u);\n                low[u] = min(low[u], low[v]);\n                if (low[v] &gt; dfn[u]) &#123;\n                    if (!acnt[v] || !bcnt[v] || acnt[v] == a || bcnt[v] == b) &#123;\n                        // A类或B类有一个为0或全满就说明符合要求\n                        flag[v] = true;\n                        ++res;\n                    &#125;\n                &#125;\n                acnt[u] += acnt[v]; bcnt[u] += bcnt[v];\n                // 从下向上递归统计子树情况\n            &#125;\n            else if (dfn[v] &lt; dfn[u] &amp;&amp; fa != v) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;\n        for (int i = 1, x; i &lt;= a; ++i) &#123; cin &gt;&gt; x; acnt[x] = 1; &#125;\n        for (int i = 1, x; i &lt;= b; ++i) &#123; cin &gt;&gt; x; bcnt[x] = 1; &#125;\n        // 最开始每个点的子树就是自己\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            add(x, y); add(y, x);\n        &#125;\n        Tarjan(1, 0);\n        cout &lt;&lt; res &lt;&lt; '\\n';\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (flag[i]) &#123;\n                cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; par[i] &lt;&lt; '\\n';\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n<h2 id=\"operatorname-Tarjan-求强连通分量\">$\\operatorname{Tarjan}$ 求强连通分量</h2>\n<h3 id=\"前置芝士-3\">前置芝士</h3>\n<p><strong>强连通</strong>：在有向图 $G$ 中，如果两个顶点 $u_i,u_j$ 间 $(u_i \\ne u_j)$ 有一条从 $u_i$ 到 $u_j$ 的有向路径，同时还有一条从 $u_j$ 到 $u_i$ 的有向路径，则称两个顶点<strong>强连通(Strongly Connected, SC)</strong>。</p>\n<p><strong>强连通图</strong>：有向图 $G$ 中，若任意两点强连通，则称 $G$ 是一个强连通图。</p>\n<p><strong>强连通分量(Strongly Connected Components, SCC)</strong>：极大的强连通子图。</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/24/pPY6O54.png\" alt=\"\"></p>\n<p>如图是一个强连通图，图上的强连通分量有三个：$a-b-c-d,e,f$。</p>\n<p><strong>缩点</strong>：因为强连通图中任意两点连通，所以在不考虑路径长度只考虑连通性的情况下，可以将一个强连通分量压缩成一个点来进行处理，这样就可以缩小图的规模。</p>\n<h3 id=\"实现过程-2\">实现过程</h3>\n<p>我们算法的主要过程与步骤如下：</p>\n<ol>\n<li>从根开始向下搜索，实时更新 $dfn$ 和 $low$，每搜到一个点就入栈；</li>\n<li>当 $v$ 未被访问过，我们继续深搜，在回溯过程中，用 $low_v$ 更新 $low_u$，当回溯到某一个点 $u$ 使得 $dfn_u=low_u$ 时，弹栈直到把自己也弹出来，这些弹出来的元素就是一个强连通分量；</li>\n<li>当 $v$ 被访问过且已经在栈中，就像前面一样用 $dfn_v$ 更新 $low_u$；</li>\n<li>当 $v$ 被访问过且不在栈中，不操作。</li>\n</ol>\n<p>下面给出一个例子来帮助读者理解这一过程：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/24/pPYRldK.png\" alt=\"\"></p>\n<ol>\n<li>如图 (a)，从 $1$ 开始搜，$1$ 入栈，$dfn_1=low_1=1$；</li>\n<li>如图 (b)，搜到 $2$，$2$ 入栈，搜到 $3$，$3$ 入栈，搜到 $4$，$4$ 入栈，接下来通过返祖边搜到了 $2$，$low_4=2$；</li>\n<li>如图 ©，返回 $3$，$low_3=2$，返回 $2$，$low_2=2$，此时 $low_2=dfn_2=2$，所以找到了一个强连通分量，弹栈直到自己得到连通分量 $\\{2,3,4\\}$；</li>\n<li>如图 (d)，返回 $1$，搜到 $5$ 入栈，搜到 $6$ 入栈，连向 $3$ 有一条横向边，但 $3$ 不在栈里，所以不管，搜到 $7$ 入栈，然后搜不下去了，$low_7=dfn_7=7$，弹栈直到自己得到连通分量 $\\{7\\}$；</li>\n<li>如图 (e)，返回 $6$，$low_6=dfn_6=6$，弹栈知直到自己得到连通分量 $\\{6\\}$，回到 $5$，访问过了但是 $dfn$ 和 $low$ 更新后没变，搜到 $8$，接下来通过返祖边搜到了 $1$，$low_8=1$；</li>\n<li>如图 (f)，返回 $5$，$low_5=1$，返回 $1$，前向边搜到 $8$，更新后没变所以不管，返回 $1$，$low_1=dfn_1=1$，弹栈直到自己得到连通分量 $\\{1,5,8\\}$。</li>\n</ol>\n<p>代码大概就长这样：</p>\n<pre><code class=\"language-cpp\">namespace SHAWN &#123;\n    const int N = 1e5 + 10;\n    int head[N], cnt;\n    struct edge &#123; int to, next; &#125;edge[N];\n    int n, m, tim, top, idx;\n    int dfn[N], low[N], st[N], size[N], scc[N];\n    bool chkin[N];\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u) &#123;\n        low[u] = dfn[u] = ++tim;\n        st[++top] = u;// 搜到就入栈\n        chkin[u] = true;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!dfn[v]) &#123;\n                Tarjan(v);\n                low[u] = min(low[u], low[v]);\n            &#125;\n            else if (chkin[v]) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125; \n        if (low[u] == dfn[u]) &#123;\n            //low[u]=dfn[u]时弹栈直到自己\n            int v; ++idx;\n            do &#123;\n                v = st[top--];\n                scc[v] = idx;\n                chkin[v] = false;\n                ++size[idx];\n            &#125; while (v != u);\n        &#125;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            add(x, y);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (!dfn[i]) &#123;\n                Tarjan(i);\n            &#125;\n        &#125;\n        int ans = 0;\n        for (int i = 1; i &lt;= idx; ++i) &#123;\n            ans += (size[i] &gt; 1);\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            cout &lt;&lt; scc[i] &lt;&lt; ' ';\n        &#125;\n        return 0;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"例题-3\">例题</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2341\">1、P2341 USACO03FALL / HAOI2006 受欢迎的牛 G</a></p>\n<p>我们考虑如何建模。一只奶牛喜欢另一只奶牛可以表示为有向图上的一条有向边，因为爱慕关系具有传递性，所以能和其余所有点都连通的结点就是一个可行答案。我们如何去优化这个问题呢？考虑在强连通分量中，因为所有点都互相连通，所以我们可以进行缩点。缩点后如果只有一个出度为 $0$ 的点，那么答案就是这个强连通分量中包含的结点个数。如果有多个出度为 $0$ 的点或根本没有出度为 $0$ 的点，就没有明星牛。这怎么理解呢？缩点以后点内奶牛不再互相爱慕，对于整个图，只有不爱慕别的牛的牛才能成为明星奶牛~~（看看，多不好）~~，但如果大家都不爱慕别的牛了显然也不符合要求，所以我们有了这样的判断。那么代码就是上面的题小改了一下：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 5e4 + 7;\n    int head[N], cnt;\n    struct edge &#123; int to, next; &#125;edge[N];\n    int n, m, tim, top, idx, cont, ans;\n    int dfn[N], low[N], size[N], sta[N], scc[N], diag[N];\n    bool chkin[N];\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u) &#123;\n        low[u] = dfn[u] = ++tim;\n        sta[++top] = u;\n        chkin[u] = true;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!dfn[v]) &#123;\n                Tarjan(v);\n                low[u] = min(low[u], low[v]);\n            &#125;\n            else if (chkin[v]) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125;\n        if (low[u] == dfn[u]) &#123;\n            int v; ++idx;\n            do &#123;\n                v = sta[top--];\n                scc[v] = idx;\n                chkin[v] = false;\n                ++size[idx];\n            &#125; while (v != u);\n        &#125;\n    &#125;\n\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            add(x, y);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (!dfn[i]) &#123;\n                Tarjan(i);\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = head[i]; j; j = edge[j].next) &#123;\n                int v = edge[j].to;\n                if (scc[i] != scc[v]) &#123;\n                    ++diag[scc[i]];\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= idx; ++i) &#123;\n            if (!diag[i]) &#123;\n                ++cont;\n                ans += size[i];  \n            &#125;\n        &#125;\n        if (cont == 1) &#123; cout &lt;&lt; ans &lt;&lt; '\\n'; &#125;\n        else &#123; cout &lt;&lt; &quot;0\\n&quot;; &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n<h2 id=\"总结\">总结</h2>\n<p>我们总共总结了 $\\operatorname{Tarjan}$ 算法的三种主要用法，其实与其说它是一种算法，不如说它是一种 $\\operatorname{DFS}$ 时的思想，也就是通过对于图上点先后访问关系来形成一棵 $\\operatorname{DFS}$ 生成树，用回溯的方法在树上对点对之间的关系进行操作和处理，最终得到我们想要的最近公共祖先，割点，割边或者强连通分量。而我们在运用这些方法的时候也要做到灵活变通，仔细考虑题目中给定的点边关系，然后再将统计答案的步骤加入到搜索的过程中来通过递归和筛选得到我们想要的答案。</p>\n<p><strong>以上内容如有错误或不严谨的地方，请各位巨佬指正，orz</strong></p>\n<h2 id=\"参考文献\">参考文献</h2>\n<ul>\n<li>汪星明 Tarjan相关算法及其应用</li>\n<li><a href=\"https://oi-wiki.org/graph/lca/\">OI-Wiki 最近公共祖先</a></li>\n<li><a href=\"https://www.cnblogs.com/jsawz/p/6723221.html\">江屿 tarjan算法求LCA</a></li>\n<li><a href=\"https://oi-wiki.org/graph/cut/\">OI-Wiki 割点和桥</a></li>\n<li><a href=\"https://oi-wiki.org/graph/scc/\">OI-Wiki 强连通分量</a></li>\n<li>洛谷网校《深入浅出程序设计竞赛进阶篇》</li>\n</ul>\n",
            "tags": [
                "图论"
            ]
        },
        {
            "id": "http://example.com/2023/09/02/P2376%20[USACO09OCT]%20Allowance%20G/",
            "url": "http://example.com/2023/09/02/P2376%20[USACO09OCT]%20Allowance%20G/",
            "title": "题解 洛谷 P2376 [USACO09OCT] Allowance G",
            "date_published": "2023-09-02T03:43:00.000Z",
            "content_html": "<h1>P2376 [USACO09OCT] Allowance G</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你 $n$ 种面值的货币，其中货币中面值小的货币的面值可以整除面值大的货币的面值，给你每种面值货币的数量。每周都要给贝茜发至少 $c$ 元的工资，问最多能发多少周。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>首先对于面值大于 $c$ 的货币，显然我们每周给出一张就行了，没有其它办法，所以可以直接把它们的数量加在答案中。接下来是对于面值小于 $c$ 的货币，我们先对所有货币按照面值降序排序，每次选取能够选的最大的，然后再用最小的去填补剩下的那一点点价格缝隙，因为我们有小面值货币面值是大面值货币面值因数这个条件，所以最大配最小这种做法一定会产生最小的浪费，从而得到最优解。如果这一次凑不出来了，那显然是钱不够了，那么所有情况就统计完毕，输出答案即可。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#define PII pair&lt;int, int&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    vector&lt;PII&gt; v;\n    //v.first 代表面值，v.second 代表货币数量\n    int n, c, ans; \n    bool cmp(PII x, PII y) &#123; return x.first &gt; y.first; &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; c;\n        for (int i = 1, val, b; i &lt;= n; ++i) &#123;\n            cin &gt;&gt; val &gt;&gt; b;\n            if (val &gt;= c) &#123; ans += b; &#125;\n            else &#123; v.push_back(&#123;val, b&#125;); &#125;\n        &#125;\n        sort(v.begin(), v.end(), cmp);\n        while (true) &#123;\n            int tmp = c;\n            for (int i = 0; i &lt; v.size(); ++i) &#123;\n                while (tmp &amp;&amp; v[i].second &amp;&amp; tmp &gt;= v[i].first) &#123;\n                    tmp -= v[i].first; \n                    --v[i].second;\n                &#125;\n            &#125;\n            if (tmp &gt; 0) &#123;\n                for (int i = v.size() - 1; i &gt;= 0; --i) &#123;\n                    if (v[i].second &amp;&amp; v[i].first &gt;= tmp) &#123;\n                        tmp -= v[i].first;\n                        --v[i].second;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n            if (tmp &gt; 0) &#123; break; &#125;\n            ++ans;\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "贪心"
            ]
        },
        {
            "id": "http://example.com/2023/08/31/CF1863C%20MEX%20Repetition/",
            "url": "http://example.com/2023/08/31/CF1863C%20MEX%20Repetition/",
            "title": "题解 CF1863C MEX Repetition",
            "date_published": "2023-08-31T01:18:00.000Z",
            "content_html": "<h1>CF1863C MEX Repetition</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个 $n$ 个元素的序列 $a$，其中的元素由小于等于 $n$ 的自然数构成且元素之间两两不同。现在定义一种操作，该操作会将第 $i$ 个位置的元素 $a_i$ 替换为该序列中当前没有的最小自然 数。每一轮操作都会从 $1$ 位置一直替换到 $n$。给定整数 $n,k$ 和序列 $a$，其中 $k$ 表示要进行 $k$ 轮操作，要求输出操作后的序列。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>题目中其实有一个诈骗条件。因为序列中的 $n$ 个元素包含小于等于 $n$ 的自然数且两两相同，所以我们可以发现，如果把原序列增加 $1$ 个元素，那么这个序列就变成了 $0 \\sim n$ 的一个排列。而我们要替换用的那个数其实就是原序列中没有出现的那个数。我们发现，每当我们替换了一个数字，那么我们必然要用替换下来的这个数字去替换下一个数字，因为被替换下来的这个数字变成了当前序列中缺少的那个数。我们将最开始序列中缺少的那个数放在第 $n + 1$ 个位置。然后我们就可以显然地发现，每次操作实质上就是用第 $i$ 个位置的元素去替换第 $i+1$ 个位置的元素，推广到递推形式就是：</p>\n$$\\displaylines{a_{(i+1) \\operatorname{mod} (n+1)}= a_{i \\operatorname{mod}(n+1)}\n}$$<p>现在我们就知道了替换的方法，但是如果我们按照这个递推式进行模拟显然是行不通的，所以我们需要对这个做法进行优化。我们发现，每一轮操作结束后，都相当于把这个序列滚动一次，我们以下面的输入为例：</p>\n<pre><code>5 5\n1 2 3 4 5\n</code></pre>\n<p>我们把没有出现的元素放在第 $n+1$ 个位置，然后我们每次进行一轮操作并记下来：</p>\n<pre><code>1 2 3 4 5 0\n0 1 2 3 4 5\n5 0 1 2 3 4\n4 5 0 1 2 3\n3 4 5 0 1 2 \n2 3 4 5 0 1\n1 2 3 4 5 0\n</code></pre>\n<p>于是我们就发现了，这种操作具有循环节，每一轮循环次数等于 $n+1$。原序列的元素顺序也没有太大的改变，所以我们就可以先确认没有第一次操作前没有出现的那个元素的位置，不难发现这个元素的位置等于 $k \\operatorname{mod} (n+1)$。那么我们就可以直接做了。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e5 + 7;\n    int a[N];\n    bool chk[N];\n    int T, n, k;\n    int work()\n    &#123;\n        cin &gt;&gt; T;\n        while (T--) &#123;\n            cin &gt;&gt; n &gt;&gt; k;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                cin &gt;&gt; a[i];    \n                chk[a[i]] = true;\n            &#125;\n            int fir;\n            for (int i = 0; i &lt;= n; ++i) &#123;\n            // 不想写二分了所以直接 O(n) 查\n                if (!chk[i]) &#123;\n                    fir = i;\n                    break;\n                &#125;\n            &#125;\n            a[++n] = fir;\n            int xh = k % n, cnt = n - 1;\n            int idx = n - xh + 1;\n            while (cnt--) &#123;\n                if (idx &gt; n) &#123; idx = 1; &#125;\n                cout &lt;&lt; a[idx++] &lt;&lt; ' ';\n            &#125;\n            cout &lt;&lt; '\\n';\n            memset(chk, 0, sizeof(chk));\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/29/P9118%20[%E6%98%A5%E5%AD%A3%E6%B5%8B%E8%AF%95%202023]%20%E5%B9%82%E6%AC%A1/",
            "url": "http://example.com/2023/08/29/P9118%20[%E6%98%A5%E5%AD%A3%E6%B5%8B%E8%AF%95%202023]%20%E5%B9%82%E6%AC%A1/",
            "title": "题解 洛谷 P9118 [春季测试 2023] 幂次",
            "date_published": "2023-08-29T09:05:00.000Z",
            "content_html": "<h1>P9118 [春季测试 2023] 幂次</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定两个参数 $n,k$，问在区间 $[1,n]$ 中有多少正整数 $x$ 满足 $x = a^p$，其中 $p \\ge k$。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p><strong>前置芝士</strong>：区间 $[1,n]$ 中完全平方数有 $\\left \\lfloor \\sqrt{n}  \\right \\rfloor $ 个，这个结论用整除分块很容易就可以证出来。</p>\n<p>有了这个结论，我们就已经处理完了这个题中 $k=2$ 的情况了，我们来分析剩下的情况。</p>\n<p>当 $k=1$ 时，显然区间内每个数都可以表示为 $a^1$，所以答案就是 $n$。</p>\n<p>当 $k \\ge 3$ 时，底数为 $1$ 的情况就直接跳过，我们发现现在底数最小是 $2$，而我们单次计算最大的可能次数就是 $\\log_2 n$，本题中 $n \\le 10^{18}$，所以单次最多计算次数为 $\\left \\lceil \\log_2 10^{18} \\right \\rceil = 60$。所以我们直接暴力枚举就可以了。平方不需要枚举直接用我们的结论，我们从 $\\left \\lfloor \\sqrt[3]{n}   \\right \\rfloor $ 开始枚举即可，枚举到的数标记一下，下次如果标记过则计数器不操作，碰到完全平方数记一下最后把多算的这一次减掉就行。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#include &lt;map&gt;\n#define LL unsigned long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    LL n, k, bcnt, ans, tmp, p;\n    //tmp表示底数，p表示幂次，ans是答案，bcnt是重复计算的完全平方数\n    map&lt;LL, bool&gt; m;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k;\n        LL bk = sqrtl(n);\n        // bk是[1,n]中完全平方数的数量\n        for (LL i = 2; i * i * i &lt;= n; ++i) &#123;\n            // 从三次根号下n开始枚举\n            tmp = i * i; p = 2;\n            while (tmp &lt;= n/i) &#123;\n                tmp *= i; ++p;\n                if (m[tmp] || p &lt; k) &#123; continue; &#125;\n                LL k = sqrtl(tmp);\n                if (k * k == tmp) &#123; ++bcnt; &#125;\n                m[tmp] = true; ++ans;\n            &#125;\n        &#125;\n        if (k == 1) &#123; cout &lt;&lt; n &lt;&lt; '\\n'; &#125;\n        else if (k == 2) &#123; cout &lt;&lt; ans - bcnt + bk &lt;&lt; '\\n'; &#125;\n        else if (k &gt;= 3) &#123; cout &lt;&lt; ans + 1 &lt;&lt; '\\n';&#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n<h2 id=\"特别提醒\">特别提醒</h2>\n<p>本题中要注意的是，开根的时候要用 <code>sqrtl()</code> 而不是 <code>sqrt()</code>，因为我们计算的对象和答案都是长长整型，用 <code>sqrt()</code> 可能会出错。</p>\n",
            "tags": [
                "容斥;根号分治"
            ]
        },
        {
            "id": "http://example.com/2023/08/29/CF690F1%20Tree%20of%20Life%20(easy)/",
            "url": "http://example.com/2023/08/29/CF690F1%20Tree%20of%20Life%20(easy)/",
            "title": "题解 CF690F1 Tree of Life (easy)",
            "date_published": "2023-08-29T08:09:00.000Z",
            "content_html": "<h1>CF690F1 Tree of Life (easy)</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一棵树，求树上长度为 $2$ 的路径条数</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>我们看下面这张图：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/29/pPdSEL9.png\" alt=\"\"></p>\n<p>我们发现对于点 $u,v$，$v$ 是与 $u$ 相连的一个点，从 $u$ 出发的长度为 $2$ 的路径条数就等于 $v$ 的度数减去 $1$，因为 $u$ 本身也和 $v$ 相连，所以要把自己减掉。比如说上面这张图中，与 $1$ 距离为 $2$ 的点有 $6,7,8,9,5$ 这 $5$ 个，而 $1$ 的三个子节点的度数分别为 $3,3,2$，分别减去 $1$ 再相加刚好是 $5$。</p>\n<p>我们对这整张图统计以后，其实对于每一个点我们都统计了与它距离为 $2$ 的点，因为存图时是无向图，所以同一条路径一定计算了两次，累加的答案要减半。</p>\n<p>时间复杂度 $O(n^2)$。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e4 + 7;\n    vector&lt;int&gt; edge[N];\n    int n, sum;\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1, x, y; i &lt; n; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            edge[x].emplace_back(y);\n            edge[y].emplace_back(x);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (auto it : edge[i]) &#123; \n                sum += edge[it].size() - 1; \n            &#125;\n        &#125;\n        sum &gt;&gt;= 1;\n        cout &lt;&lt; sum &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "枚举"
            ]
        },
        {
            "id": "http://example.com/2023/08/28/P5686%20[CSP-S2019%20%E6%B1%9F%E8%A5%BF]%20%E5%92%8C%E7%A7%AF%E5%92%8C/",
            "url": "http://example.com/2023/08/28/P5686%20[CSP-S2019%20%E6%B1%9F%E8%A5%BF]%20%E5%92%8C%E7%A7%AF%E5%92%8C/",
            "title": "题解 洛谷 P5686 [CSP-S2019 江西] 和积和",
            "date_published": "2023-08-28T03:06:00.000Z",
            "content_html": "<h1>P5686 [CSP-S2019 江西] 和积和</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定两个 $n$ 个元素的序列 $a,b$，求下面这个式子对 $10^9+7$ 取模的结果：</p>\n$$\\displaylines{\\sum_{l=1}^{n}\\sum_{r=l}^{n}(\\sum_{i=l}^{r}a_i \\times \\sum_{i=l}^{r}b_i)\n}$$<h2 id=\"策略分析\">策略分析</h2>\n<p>如果直接模拟那么时间复杂度是爆炸级的 $O(n^3)$，显然正常人都不会这么做，正常人会选择可爱的前缀和，所以最后一层括号复杂度变成 $O(1)$，总复杂度 $O(n^2)$，比刚刚好了很多，但依然是过不去的，所以我们考虑对前缀和进行优化。</p>\n<p>设 $a$ 的前缀数组为 $A$，$b$ 的前缀数组为 $B$。那么上面的式子显然可以写成：</p>\n$$\\displaylines{\\sum_{l=1}^{n}\\sum_{r=l}^n(A_r-A_{l-1})(B_r-B_{l-1}) \\\\\n=\\sum_{l=1}^{n}\\sum_{r=l}^n(A_rB_r+A_{l-1}B_{r-1}-A_rB_{l-1}-A_{l-1}B_r)\n}$$<p>这样看我们求解还不是很方便，因为存在前面的求和符号，我们不便于对整体的式子进行观察，所以我们用一个 $n$ 较小的式子看一下，比方说令 $n=4$，那么我们按照这个式子带进去展开化简得到：</p>\n$$\\displaylines{sum=4(A_1B_1+A_2B_2+A_3B_3+A_4B_4) \\\\\n-(A_1B_2+A_1B_3+A_1B_4+A_2B_1+A_2B_3+A_2B_4 \\\\\n+A_3B_1+A_3B_2+A_3B_4+A_4B_1+A_4B_2+A_4B_3)\n}$$<p>那么前面系数为 $4$ 的那个式子我们就可以 $O(n)$ 求了，关键转移到了如何求后面这一坨东西。我们把 $A$ 和 $B$ 按照下标放到矩阵里看一看：</p>\n$$\\displaylines{\\begin{bmatrix}\n 0&amp;  A_1B_2&amp;  A_1B_3&amp; A_1B_4\\\\\n  A_2B_1&amp;  0&amp;  A_2B_3&amp; A_2B_4\\\\\n  A_3B_1&amp;  A_3B_2&amp;  0&amp; A_3B_4\\\\\n  A_4B_1&amp;  A_4B_2&amp;  A_4B_3&amp; 0 \n\\end{bmatrix}\n}$$<p>我们发现这不就是 $A$ 每一项去乘 $B$ 每一项吗，唯一的遗憾是对角线全是 $0$。我们期望能够对这个式子进行因式分解使其变成两个只包含 $A$ 或 $B$ 的式子相乘，那么其实想办法把这个对角线给它补齐就行了，我们发现对角线的 $A,B$ 下标相等，那么就和刚刚系数为 $4$ 的那个式子一模一样了，所以我们在这多减一遍，前面多加一遍，整个式子的值不变，式子变成这样：</p>\n$$\\displaylines{sum=5 \\times \\sum_{i=1}^{4}A_iB_i-(\\sum_{i=1}^4A_i \\times \\sum_{i=1}^4B_i)\n}$$<p>然后把这个结论归纳到 $n$ 项得：</p>\n$$\\displaylines{\\begin{aligned}\nsum=(n+1) \\times \\sum_{i=1}^{n}A_iB_i-(\\sum_{i=1}^{n}A_i \\times \\sum_{i=1}^{n}B_i) \\\\\n=\\sum_{i=1}^{n}(n+1)\\times A_iB_i-(\\sum_{i=1}^{n}A_i \\times \\sum_{i=1}^{n}B_i)\n\\end{aligned}\n}$$<p>图中三个求和符不存在嵌套，所以每一个都可以拿出来单独计算，时间复杂度降低到了 $O(n)$，于是这道题就做完了。做题的时候要注意，本题给定的数都特别大，所以在求解的过程中不要忘记<strong>时刻取模</strong>。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const LL N = 5e5 + 7, mod = 1e9 + 7;\n    LL n, ans, A, B;\n    LL a[N], b[N];\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= n; ++i) &#123; \n            cin &gt;&gt; a[i];\n            a[i] = (a[i] + a[i - 1]) % mod;// 求a的前缀\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            cin &gt;&gt; b[i];\n            b[i] = (b[i] + b[i - 1]) % mod;// 求b的前缀\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            ans = (ans % mod + ((n + 1) * a[i]) % mod * b[i] % mod) % mod;\n            // 处理第一个求和符\n            A = (A + a[i]) % mod;\n            // 处理第二个求和符\n            B = (B + b[i]) % mod;\n            // 处理第三个求和符\n        &#125;\n        ans = ((ans - (A * B % mod)) + mod) % mod;\n        // 将三个求和符号按照推出来的式子加到一块\n        cout &lt;&lt; ans % mod &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "数学"
            ]
        },
        {
            "id": "http://example.com/2023/08/28/P5019%20[NOIP2018%20%E6%8F%90%E9%AB%98%E7%BB%84]%20%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF/",
            "url": "http://example.com/2023/08/28/P5019%20[NOIP2018%20%E6%8F%90%E9%AB%98%E7%BB%84]%20%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF/",
            "title": "题解 洛谷 P5019 [NOIP2018 提高组] 铺设道路",
            "date_published": "2023-08-28T02:15:00.000Z",
            "content_html": "<h1>P5019 [NOIP2018 提高组] 铺设道路</h1>\n<p>本题还有一道<a href=\"https://www.luogu.com.cn/problem/P1969\">姐妹题</a>，两题题意一样，代码也一模一样。</p>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一个序列，每次选取一个区间对这个区间内所有数都减去 $1$，使得区间内至少一个数变成 $0$，重复执行这一过程直到整个序列都为 $0$，求最小操作次数。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>本题可以用贪心在 $O(n)$ 复杂度完成。</p>\n<h3 id=\"操作方法\">操作方法</h3>\n<p>我们可以从头往尾扫，设第 $i$ 个位置的值为 $v_i$，当第 $i$ 个位置的值大于第 $i-1$ 个位置的值时，我们就要给答案加上 $v_{i-1}-v_i$，否则不操作。为了后面能够正常操作，第一次必须将第一个位置的直接减到 $0$。</p>\n<h3 id=\"正确性证明\">正确性证明</h3>\n<p>考虑如果 $v_i \\le v_{i-1}$， 那我们在填第 $i-1$ 个坑的时候一定可以把第 $i$ 个坑填上；而当 $v_i&gt; v_{i-1}$ 时，我们填第$i$ 个坑的时候又可以顺便把第 $i-1$ 个坑填上，由此递推即可得出答案。</p>\n<h2 id=\"代码\">代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e5 + 7;\n    int v[N];\n    long long ans;\n    int work()\n    &#123;\n        int n;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; v[i]; &#125;\n        ans = v[1];\n        for (int i = 2; i &lt;= n; ++i) &#123;\n            if (v[i] &gt; v[i - 1]) &#123;\n                ans += (v[i] - v[i - 1]);\n            &#125;\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "贪心"
            ]
        },
        {
            "id": "http://example.com/2023/08/28/P7960%20[NOIP2021]%20%E6%8A%A5%E6%95%B0/",
            "url": "http://example.com/2023/08/28/P7960%20[NOIP2021]%20%E6%8A%A5%E6%95%B0/",
            "title": "题解 洛谷 P7960 [NOIP2021] 报数",
            "date_published": "2023-08-28T02:15:00.000Z",
            "content_html": "<h1>P7960 [NOIP2021] 报数</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>报数游戏，凡是这个数字十进制表示含有 $7$的数和它的倍数都不能报，给定 $T$ 组询问，每次询问给定一个数 $x$，回答下一个要报的数，若 $x$ 是不能报的数，输出 <code>-1</code>。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>经过良久的思考，我们发现找不到任何可行的 $O(1)$ 性质，所以我们<s>本能的采用暴力</s>。类似线性筛法求素数，我们线性筛求不能报的数的倍数。如果是可以报的数，我们就要记下它该报的下一个数，如果是不可以报的数，我们就要打标记。具体的解释见代码。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e7 + 10;\n    int chk[N];\n    int t, x, lst;\n    // 我们可以把不符合要求的数的下一个看做-1\n    // 这样开一个数组就够了\n    \n    inline bool judge(int k) &#123;\n    // 判断这个数十进制表示里有没有7\n        while (k) &#123;\n            if (k % 10 == 7) &#123; return true; &#125;\n            k /= 10;\n        &#125;\n        return false;\n    &#125;\n\n    inline void _init() &#123;\n    \t// 线性筛\n        for (int i = 1; i &lt; N; ++i) &#123;\n            if (chk[i] == -1) &#123; continue; &#125;\n            // 已经标记过了就跳过\n            if (judge(i)) &#123;// 如果十进制含有7\n                for (int j = i; j &lt; N; j += i) &#123;\n                    chk[j] = -1;\n                &#125;// 这个数的所有倍数的下一个数都记成-1\n            &#125;\n            // 如果\n            else &#123;// 如果这个数满足要求\n            \tchk[lst] = i;\n            \tlst = i;\n                // 记下它下一个合法的数\n            &#125;\n        &#125;\n    &#125;\n    \n    int work()\n    &#123;\n        _init();\n        cin &gt;&gt; t;\n        while (t--) &#123;\n            cin &gt;&gt; x;\n            cout &lt;&lt; chk[x] &lt;&lt; '\\n';\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "线性筛"
            ]
        },
        {
            "id": "http://example.com/2023/08/24/P7687%20[CEOI2005]%20Critical%20Network%20Lines/",
            "url": "http://example.com/2023/08/24/P7687%20[CEOI2005]%20Critical%20Network%20Lines/",
            "title": "题解 洛谷 P7687 [CEOI2005] Critical Network Lines",
            "date_published": "2023-08-24T01:16:00.000Z",
            "content_html": "<h1>P7687 [CEOI2005] Critical Network Lines</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一张图，图上有两类点 $A$ 和 $B$，现在要求你找到满足下面条件的边：删除这条边后该图变为两个块，且至少有一个块中只包含 $A$ 类点或只包含 $B$ 类点。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p><a href=\"https://oi-wiki.org/graph/cut/#%E5%89%B2%E8%BE%B9\">前置芝士：割边（桥）</a></p>\n<p>我们不难看出题目想让我们求的边是图中的割边，但并非所有的割边都满足题目的条件。如下图（图中边上的数字是编号不是边权）：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/24/pPYBlad.png\" alt=\"\"></p>\n<p>这幅图中的割边有 $1,4,5,6,8$ 五条，而符合题目条件的只有 $1,6,8$ 这三条。仔细考虑我们在深搜的时候形成的深度优先生成树的性质，我们发现，<strong>当一个割边满足条件当且仅当它连接的一个节点在深度优先生成树中的子树内只包含一类点</strong>（如果后面看不懂建议反复阅读体会这句话）。求割边的时候，每找到一条割边 $(u,v)$，我们就检查一下以 $v$ 为根结点的子树内 $A$ 和 $B$ 类结点各自的数量，当其中一个个数为 $0$ 或者全满，就是要求的边，打上标记并给计数的答案加一就可以了。求数量的过程，可以在 $\\operatorname{dfs}$ 的时候递归计算。</p>\n<h2 id=\"实现\">实现</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 2e6 + 7;\n    // 请注意这里一定要开二倍空间，要不然会寄\n    int head[N], cnt;\n    struct edge &#123; int to, next; &#125;edge[N];\n    int n, m, a, b, tim, res;\n    int dfn[N], low[N], acnt[N], bcnt[N], par[N];\n    // acnt[i]表示i结点子树中A类点数量，bcnt同理\n    // par用来记每个结点在dfs生成树中的父亲\n    bool flag[N];\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u, int fa) &#123;\n        low[u] = dfn[u] = ++tim;\n        par[u] = fa;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!dfn[v]) &#123;\n                Tarjan(v, u);\n                low[u] = min(low[u], low[v]);\n                if (low[v] &gt; dfn[u]) &#123;\n                    if (!acnt[v] || !bcnt[v] || acnt[v] == a || bcnt[v] == b) &#123;\n                        // A类或B类有一个为0或全满就说明符合要求\n                        flag[v] = true;\n                        ++res;\n                        // 后来看大家的做法这里用vector套一个pair存也非常方便\n                    &#125;\n                &#125;\n                acnt[u] += acnt[v]; bcnt[u] += bcnt[v];\n                // 从下向上递归统计子树情况\n            &#125;\n            else if (dfn[v] &lt; dfn[u] &amp;&amp; fa != v) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;\n        for (int i = 1, x; i &lt;= a; ++i) &#123; cin &gt;&gt; x; acnt[x] = 1; &#125;\n        for (int i = 1, x; i &lt;= b; ++i) &#123; cin &gt;&gt; x; bcnt[x] = 1; &#125;\n        // 最开始每个点的子树就是自己\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            add(x, y); add(y, x);\n        &#125;\n        Tarjan(1, 0);\n        cout &lt;&lt; res &lt;&lt; '\\n';\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (flag[i]) &#123;\n                cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; par[i] &lt;&lt; '\\n';\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "割边;Tarjan"
            ]
        },
        {
            "id": "http://example.com/2023/08/24/P5058%20[ZJOI2004]%20%E5%97%85%E6%8E%A2%E5%99%A8/",
            "url": "http://example.com/2023/08/24/P5058%20[ZJOI2004]%20%E5%97%85%E6%8E%A2%E5%99%A8/",
            "title": "题解 洛谷 P5058 [ZJOI2004] 嗅探器",
            "date_published": "2023-08-24T01:15:00.000Z",
            "content_html": "<h1>P5058 [ZJOI2004] 嗅探器</h1>\n<h3 id=\"简要题意\">简要题意</h3>\n<p>给定一张图，再给处图中两个点 $x,y$，现在要在图中删去除了 $x,y$ 以外的一个点使得 $x$ 和 $y$ 不再连通，求要删除的点的编号</p>\n<h3 id=\"题目分析\">题目分析</h3>\n<p><a href=\"https://oi-wiki.org/graph/cut/\">前置芝士</a></p>\n<p>题目要求我们删掉一个点使得给定的两个点不连通，那么其实我们就是要找一个满足要求的割点，如下图标黑的点就是题目给定的两个点：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/23/pPJqc80.png\" alt=\"\"></p>\n<p>点 $1$ 是一个割点，我们删除点 $1$ 即可使得 $2,4$ 两点不连通，但是并非任意割点都满足要求，比方说下面这张图：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/23/pPJqg2V.png\" alt=\"\"></p>\n<p>点 $3$ 和点 $4$ 都是图中的割点，但是删去 $4$ 并不能使得目标点 $1,7$ 不连通，所以只有点 $3$ 是符合条件的点，那么我们就要去筛选割点中符合要求的点。</p>\n<p>怎么筛呢？其实我们想一想建立 DFS 树的过程，我们从题中给定的一个点开始搜，那么对于一个符合条件的割点来讲，题中给定的另一个点一定在这个符合条件的割点的子树中。所以在搜的时候加个判断条件就好了。本题因为不能删去根，所以不用考虑根是割点的情况，那么代码也就非常简单：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    int head[N], cnt;\n    struct edge &#123; int to, next; &#125;edge[N];\n    int n, tim, x, y;\n    int dfn[N], low[N];\n    bool vis[N], flag[N];\n\n    inline void add(int u, int v) &#123;\n        edge[++cnt].next = head[u];\n        edge[cnt].to = v;\n        head[u] = cnt;\n    &#125;\n\n    void Tarjan(int u, int fa) &#123;\n        low[u] = dfn[u] = ++tim;\n        vis[u] = true;\n        for (int i = head[u]; i; i = edge[i].next) &#123;\n            int v = edge[i].to;\n            if (!vis[v]) &#123;\n                Tarjan(v, u);\n                low[u] = min(low[u], low[v]);\n                // 这里多加一个u!=x和dfn[y]&gt;=dfn[v]的特判就OK了\n                if (fa != u &amp;&amp; low[v] &gt;= dfn[u] &amp;&amp; u != x &amp;&amp; dfn[y] &gt;= dfn[v]) &#123;\n                    flag[u] = true;\n                &#125;\n            &#125;\n            else if (fa != v) &#123;\n                low[u] = min(low[u], dfn[v]);\n            &#125;\n        &#125;\n    &#125;\n\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        while (cin &gt;&gt; x &gt;&gt; y &amp;&amp; x &amp;&amp; y) &#123;\n            add(x, y); add(y, x);\n        &#125;\n        cin &gt;&gt; x &gt;&gt; y;\n        Tarjan(x, x);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (flag[i]) &#123;\n                cout &lt;&lt; i &lt;&lt; '\\n';\n                return 0;\n            &#125;\n        &#125;\n        cout &lt;&lt; &quot;No solution\\n&quot;;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "割点;Tarjan"
            ]
        },
        {
            "id": "http://example.com/2023/08/21/P9570%20%E3%80%8CNnOI%20R2-T2%E3%80%8DGlaciaxion/",
            "url": "http://example.com/2023/08/21/P9570%20%E3%80%8CNnOI%20R2-T2%E3%80%8DGlaciaxion/",
            "title": "题解 洛谷 P9570 「NnOI R2-T2」Glaciaxion",
            "date_published": "2023-08-21T02:23:00.000Z",
            "content_html": "<h1>洛谷 P9570 「NnOI R2-T2」Glaciaxion</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个数 $n$ 和 $m$ 表示有从 $1$ ~ $n$ 的正整数和 $m$ 次操作。每次操作给出一个字母 <code>N</code> 或 <code>Y</code>，如果给出 <code>N</code> 说明有一个数字第一次被选中并输出，如果给出 <code>Y</code> 就要从刚刚选出来的数里再选一个输出出来。现在要求若干输出里字典序最小的序列，如果无解输出 <code>No solution</code>。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<h3 id=\"无解情况\">无解情况</h3>\n<ul>\n<li>当给出 <code>N</code> 的次数超过 $n$ 时不合法，因为每个数第一次出现的次数总和至多为 $n$。</li>\n<li>当还没有给出 <code>N</code> 就给出 <code>Y</code> 时不合法，因为 <code>Y</code> 不能选出以前没有选出来的数。</li>\n<li>$n$ 或 $m$ 等于 $0$ 的时候不合法</li>\n</ul>\n<h3 id=\"构造\">构造</h3>\n<p>下面的分析基于所有合法条件。我们要求最后输出序列字典序最小，所以我们考虑建立一个从 $1$ 开始的指针，当出现 <code>N</code> 时输出指针，然后指针移动到下一个数。给出 <code>Y</code> 前一定给出了 <code>N</code>，而第一次给出 <code>N</code> 时我们选出的数一定是 $1$，因为它的字典序最小。而既然已经选出来了，后面每一次 <code>Y</code> 我们都要在已经选出的数里选一个最小的，那么我们选出来的数必然是 $1$。所以我们只需要在输入 <code>N</code> 的时候输出递增的那个指针并将其自增，输入 <code>Y</code> 的时候输出 $1$ 就可以了。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    int n, m, idx, ncnt, ycnt;\n    // ncnt用来记录N的数量，ycnt记录Y的数量\n    string s;\n    vector&lt;int&gt; ans;// 用来记录答案\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        cin &gt;&gt; s;\n        if (!n || !m) &#123; cout &lt;&lt; &quot;No solution\\n&quot;; return 0; &#125;\n        // n或m为0无解\n        for (int i = 0; i &lt; m; ++i) &#123;\n            if (s[i] == 'N') &#123;\n                ++idx;// 指针自增\n                ++ncnt;\n                ans.emplace_back(idx);// 将指针放入答案序列\n            &#125;\n            else if (s[i] == 'Y') &#123;\n                ++ycnt;\n                ans.emplace_back(1);// 输入Y一定输出1\n            &#125;\n            if (ncnt == 0 &amp;&amp; ycnt) &#123; cout &lt;&lt; &quot;No solution\\n&quot;; return 0; &#125;\n            // 还没输入N就输入了Y无解\n        &#125;\n        if (ncnt &gt; n) &#123; cout &lt;&lt; &quot;No solution\\n&quot;; return 0; &#125;\n        // 输入N的数量大于n无解\n        for (auto it : ans) &#123; cout &lt;&lt; it &lt;&lt; ' '; &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/19/CF1413C%20Perform%20Easily/",
            "url": "http://example.com/2023/08/19/CF1413C%20Perform%20Easily/",
            "title": "题解 CF1413C Perform Easily",
            "date_published": "2023-08-19T15:18:00.000Z",
            "content_html": "<h1>题解 CF1413C Perform Easily</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个含有 $6$ 个元素的可重集 $a$，一个数 $n$ 和一个含有 $n$ 个数的可重集 $b$，现在要求 $b$ 中每个数和 $a$ 中任意一个数作差使得作差后得到的新的集合 $b$ 中最大的数和最小的数的差最小。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>首先考虑暴力，每个数最后的值都有 $6$ 种可能，所以总可能数有 $6^n$ 种，显然不行。题目中 $n$ 的大小为 $10^5$，所以我们期待一个 $O(n\\log n)$ 的做法。我们发现，所有数也只有 $6$ 种可能，想要枚举答案不可能，但我们可以枚举结果。于是我们想到把 $b$ 中每个元素都和 $a$ 中所有元素作差，最后得到 $6n$ 个数放入一个新的数组 $cp$。因为我们要考虑最大和最小的差最小，所以我们需要使 $cp$ 数组中的值变得有序，于是我们对其进行排序。排序后为了查找的时候保证查找的区间内的数必须包含原来 $b$ 中每个数的至少一种差（显然其每个数都有 $6$ 种差），我们要在插入 $cp$ 前给每个数打好标记，标记它来自于哪个数。</p>\n<p>预处理做完后，我们考虑如何查找答案。因为我们需要一个区间最大值，还需要一个区间最小值，所以我们想到了用双指针来进行查找。我们设左指针为 $lidx$，右指针为 $ridx$。$ridx$ 先走，一直走到与 $lidx$ 间包含了的数包含了原来 $b$ 中每个数的至少一个结果为止。现在开始移动左指针，每移动一次就 $ridx$ 与 $lidx$ 所指的两数之差更新答案。当两指针之间包含的数不能包含原来 $b$ 中每个数的至少一个结果时，就回到第一步重新开始移动 $ridx$，循环一轮即可得到答案。</p>\n<p>枚举复杂度为 $O(n)$，排序复杂度为 $O(n\\log n)$，最后搜索的复杂度为 $O(n)$，所以整个算法的时间复杂度为 $O(n\\log n)$，于是我们做完了，下面是代码。</p>\n<h3 id=\"参考代码\">参考代码</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7, INF = 1e9;\n    struct node &#123; int val, id; &#125;cp[N];\n    int n, idx, ans = INF;\n    int a[7], b[N], cnt[N];\n    bool cmp(node x, node y) &#123; return x.val &lt; y.val; &#125;\n    int work()\n    &#123;\n        for (int i = 1; i &lt;= 6; ++i) &#123; cin &gt;&gt; a[i]; &#125;\n        cin &gt;&gt; n;\n        if (n == 1) &#123; cout &lt;&lt; &quot;0\\n&quot;; return 0; &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            cin &gt;&gt; b[i];\n            for (int j = 1; j &lt;= 6; ++j) &#123;\n                cp[++idx] = &#123;b[i] - a[j], i&#125;;\n            &#125;\n            cnt[i] = 0;\n        &#125;// 加标记\n        sort(cp + 1, cp + idx + 1, cmp);\n        int lidx = 1, ridx = 0, ncnt = 0;\n        // cnt数组和ncnt用来维护当前区间包含原来b数组中的数的结果的个数\n        while (ridx &lt; idx) &#123;\n            // 双指针搜索\n            if (!cnt[cp[++ridx].id]) &#123; ++ncnt; &#125;\n            ++cnt[cp[ridx].id];\n            while (lidx &lt; ridx &amp;&amp; cp[ridx].val - cp[lidx].val &gt;= ans) &#123;\n                if (cnt[cp[lidx].id] == 1) &#123; --ncnt; &#125;\n                --cnt[cp[lidx].id];\n                ++lidx;\n            &#125;\n            // 移动左指针到可行方案处\n            while (lidx &lt; ridx &amp;&amp; ncnt == n) &#123;\n                ans = min(ans, cp[ridx].val - cp[lidx].val);\n                if (cnt[cp[lidx].id] == 1) &#123; --ncnt; &#125;\n                --cnt[cp[lidx].id];\n                ++lidx;\n            &#125; \n            // 移动左指针并不断更新答案\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/BNDSOJ%201263%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/",
            "url": "http://example.com/2023/08/18/BNDSOJ%201263%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/",
            "title": "题解 BNDS OJ 1263 表达式求值",
            "date_published": "2023-08-18T09:06:00.000Z",
            "content_html": "<h1>题解 BNDS OJ 1263 表达式求值</h1>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>输入一个表达式，包括 <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>(</code>，<code>)</code>。求出表达式的值，保留两位小数（不知道你谷有没有这道题）。</p>\n<p>提供一组样例：</p>\n<p>样例输入：</p>\n<pre><code>9-(6+3*5)/3\n</code></pre>\n<p>样例输出：</p>\n<pre><code>2.00\n</code></pre>\n<h4 id=\"策略分析：\">策略分析：</h4>\n<p>这不是简单的数据结构入门题，我们只需要拿两个栈，一个存数字一个存运算符，碰到后括号就把它到前括号里的值全部算出来。因为在这6个运算符中，除了括号其他均是二元运算符，所以符号栈栈顶运算符（除了括号）一定匹配数字栈的头两个数字\t，按照运算优先级取出来算就可以了。运算优先级我们可以用一个 $ \\operatorname{map} $ 来处理，具体细节见代码：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#include &lt;unordered_map&gt;\n#include &lt;stack&gt;\n#include &lt;iomanip&gt;\n#define LD long double\nusing namespace std;\n\nnamespace SHAWN &#123;\n    unordered_map&lt;char, int&gt; pri;\n    stack&lt;LD&gt; dig;\n    stack&lt;char&gt; ope;\n    string s;\n    void calcu() &#123;// 出栈计算\n        LD a = dig.top(); dig.pop();\n        LD b = dig.top(); dig.pop();\n        char opt = ope.top(); ope.pop();\n        LD res = 0;\n        if (opt == '+') &#123; res = b + a; &#125;\n        if (opt == '-') &#123; res = b - a; &#125;\n        if (opt == '*') &#123; res = b * a; &#125;\n        if (opt == '/') &#123; res = b / a; &#125;\n        dig.push(res);// 算完的结果塞回数字栈\n    &#125;\n    int work()\n    &#123;\n        pri['+'] = pri['-'] = 1;\n        pri['*'] = pri['/'] = 2;\n        cin &gt;&gt; s;\n        int len = s.length();\n        for (int i = 0; i &lt; len; ++i) &#123;\n            if (isdigit(s[i])) &#123;// 遇到数字就存进栈里\n                int x = 0, j = i;\n                while (j &lt; len &amp;&amp; isdigit(s[j])) &#123;\n                    x = x * 10 + s[j] - '0';\n                    j++;\n                &#125;\n                dig.push(x);\n                i = j - 1;\n            &#125;\n            else if (s[i] == '(') &#123; ope.push(s[i]); &#125;// 左括号进栈\n            else if (s[i] == ')') &#123;// 遇到右括号就一直向前算到上一个左括号\n                while (ope.top() != '(') &#123; calcu(); &#125;\n                ope.pop();\n            &#125;\n            else &#123;// 遇到运算符直接按优先级进行计算\n                while (ope.size() &amp;&amp; pri[ope.top()] &gt;= pri[s[i]]) &#123; calcu(); &#125;\n                ope.push(s[i]); \n            &#125;\n        &#125;\n        while (ope.size()) &#123; calcu(); &#125;// 完成剩余计算\n        cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; dig.top() &lt;&lt; '\\n';// 最后的结果就是数字栈栈顶元素，保留两位输出即可\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "栈"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/P1257,P1429,P7883%20%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/",
            "url": "http://example.com/2023/08/18/P1257,P1429,P7883%20%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/",
            "title": "题解 洛谷 P1257/P1429/P7883 平面最近点对",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>题解 洛谷 P1257/P1429/P7883 平面最近点对</h1>\n<h2 id=\"本文主要介绍分治法\">本文主要介绍分治法</h2>\n<h3 id=\"P1257\">P1257</h3>\n<p>因为数据范围太小从而可以$n^2$水过，所以只评了个橙，那么直接$n^2$做就可以了</p>\n<h3 id=\"P1429-P7883\">P1429/P7883</h3>\n<p>这两道题的数据范围都在$10^5$，所以我们期望的时间复杂度是$O(nlogn)$，这时候我们就不要充分发扬人类智慧了（，果断使用分治</p>\n<h3 id=\"分治策略\">分治策略</h3>\n<p>考虑将这些点划分成若干区间进行比较，因为点是乱序的，所以我们先对所有点按照$x$坐标从小到大进行排序，排好序以后从中间序号的点来二分整个$xOy$系，递归二分若干次后，我们只需要对三种情况的点进行比较就可以了</p>\n<p>1.两个点都在$mid$左边</p>\n<p>2.两个点都在$mid$右边</p>\n<p>3.一个在左边，一个在右边</p>\n<p>诶！我们发现这种对比方式是不是在哪里见过呀，没错，就是逆序对！<s>那么这个题可以说和逆序对没有什么关系</s>。但是我们在分治的时候采取的策略是有相似之处的，前两种情况只需要用最普通的递归就可以轻松解决，像这样：</p>\n<pre><code class=\"language-cpp\">dis = min(solve(l,mid), solve(mid + 1, r));\n</code></pre>\n<p>在实现的时候我们可以发现我们先处理出来了在各自一边的最近点对的距离$dis$,那么接下来我们其实就是要把跨区间的点对的$dis$和当前的$dis$比较然后取$min$，所以我们把距离中线$mid$水平距离小于$dis$的点都取出来扔进一个容器里（你看这个数组它就很好用），很容易证明水平距离大于$dis$的点不可能满足条件（直角三角形斜边长大于直角边总会用吧）</p>\n<p>$Well $ $Done!$ 我们离成功只剩一步之遥</p>\n<p>将这些点取出来以后，我们先对这些点按照$y$进行排序，然后枚举这些点，分别以每个点为圆心，半径为$dis$画圆，然后把圆内的点与圆心的距离和$dis$比较取较小的即可。请注意：这里的$dis$是实时更新的，所以圆的半径在不断缩小或者不变。</p>\n<p>于是这道题就做完了，下面是$P1429$的$AC$代码，$P7883$只要在它的基础上把$long$ $double$改成$long$ $long$即可</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;iomanip&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n#define LD long double\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 2e5 + 7;\n    const LD INF = 1e18;\n    struct node &#123; LD x, y; &#125;pt[N];\n    int que[N];\n    int n;\n    bool cmp1 (node a, node b) &#123; return a.x &lt; b.x; &#125;\n    bool cmp2 (int a, int b) &#123; return pt[a].y &lt; pt[b].y; &#125;\n    LD getlen(node a, node b) &#123; return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y); &#125;\n    LD solve(int l, int r)  &#123;\n        if (l == r) &#123; return INF; &#125;\n        if (l == r - 1) &#123; return getlen(pt[l], pt[r]); &#125;\n        int mid = l + ((r - l) &gt;&gt; 1);\n        LD dis = min(solve(l, mid), solve(mid + 1, r));\n        int idx = 0;\n        for (int i = l; i &lt;= r; ++i) &#123;\n            if ((pt[mid].x - pt[i].x) * (pt[mid].x - pt[i].x) &lt; dis) &#123;\n                que[++idx] = i;\n            &#125;\n        &#125;\n        sort(que + 1, que + idx + 1, cmp2);\n        for (int i = 1; i &lt;= idx; ++i) &#123;\n            for (int j = i + 1; j &lt;= idx &amp;&amp; ((pt[que[i]].y - pt[que[j]].y) * (pt[que[i]].y - pt[que[j]].y)) &lt; dis; ++j) &#123;\n                dis = min(dis, getlen(pt[que[i]], pt[que[j]]));\n            &#125;\n        &#125;\n        return dis;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; pt[i].x &gt;&gt; pt[i].y; &#125;\n        sort(pt + 1, pt + n + 1, cmp1);\n        cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; sqrt(solve(1, n)) &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "分治"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/P1168%20%E4%B8%AD%E4%BD%8D%E6%95%B0/",
            "url": "http://example.com/2023/08/18/P1168%20%E4%B8%AD%E4%BD%8D%E6%95%B0/",
            "title": "题解 洛谷 P1168 中位数",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>题解 洛谷 P1168 中位数</h1>\n<p>由于这道题目比较水，所以机房中诞生了四种做法，分别是权值线段树、堆、二分以及 $\\operatorname{multiset}$。</p>\n<h3 id=\"这里主要介绍本题的堆解法\">这里主要介绍本题的堆解法</h3>\n<p>通过读题我们可以轻易发现，每两次插入数据就需要进行一次访问，且期间必须维护当前访问过的所有元素组成的数列具有单调性 。</p>\n<h4 id=\"问题一：如何维护数列的单调性\">问题一：如何维护数列的单调性</h4>\n<p>于是我们很容易想到可以使用优先队列对其插入的数字进行动态排序来维护其单调性。如果你不知道什么是优先队列，那么不妨先通过下面的传送门去看一看优先队列的用法：<br>\n<a href=\"https://blog.csdn.net/weixin_36888577/article/details/79937886?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167776821716800184138808%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167776821716800184138808&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79937886-null-null.142%5Ev73%5Epc_search_v2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&amp;spm=1018.2226.3001.4187\">点我</a></p>\n<p>于是你现在明白了什么是优先队列，我们只需要在维护好的单调队列里取出中位数就可以了。所以此时你发现，由于单调队列是一个队列，想要访问中间的元素，就只能把它前面的元素全部弹出来，这样弹出一遍插入一遍甚至不如每次 sort 时间效率高，于是问题来了。</p>\n<h4 id=\"问题二：如何快速地在每次访问中提取中位数\">问题二：如何快速地在每次访问中提取中位数</h4>\n<p>既然我们一定需要把队列分成两段，那么我们直接定义两个优先队列就可以完美地解决问题。我们将前奇数个（这里假设为前 $\\mathit{K}$  个）数列切分后扔进左队列、右队列和中位数三种位置，那么左边的队列维护第 $ 1 $ ~ $\\left[\\frac{K}{2}\\right]$ 个元素，右边的队列维护第 $(\\left[\\frac{K}{2}\\right]+2)$ ~ $K$ 个元素，第$(\\left[\\frac{K}{2}\\right]+1)$ 个元素也就是剩下的那个元素就是中位数，将其定义为 mid 。左边的队列从大到小，使用大根堆，右边的队列从小到大，使用小根堆，定义如下：</p>\n<pre><code class=\"language-cpp\">typedef long long LL;\npriority_queue&lt;LL,vector&lt;LL&gt;,greater&lt;LL&gt; &gt; Right;\npriority_queue&lt;LL,vector&lt;LL&gt;,less&lt;LL&gt; &gt; Left;\nLL mid;\n</code></pre>\n<p>接下来在每个奇数次插入时，如果插入的数比 mid 小，就塞进左队列，如果比 mid 大，就塞进右队列。<strong>需要注意的是：为了确保 mid 就是中位数，必须在每次访问时对两个队列内的元素个数进行平衡！</strong> 所以这是最后一个问题。</p>\n<h4 id=\"问题三：平衡两个队列内的元素个数\">问题三：平衡两个队列内的元素个数</h4>\n<p>我们不妨设其中一个队列元素个数为 $x$ ，另一个队列元素个数为 $y$，设 $x&gt;y$ ，则从 $x$ 队列中转移到 $y$ 队列中的元素个数为 $(\\frac{x-y}{2}-1)$ 个，最后只需要把 mid 插入到 $y$ 中，再将 $x$ 的队头元素弹出来更新为新的 mid 即可。<strong>注意：这一步操作必须先进行当前步骤的插入再进行元素个数平衡</strong>。</p>\n<p>至此，我们已经解决了这个题目的所有小问题，下面是AC代码：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\nusing namespace std;\n\nnamespace SHAWN&#123;\n    //定义部分不解释\n\ttypedef long long LL;\n\tpriority_queue&lt;LL,vector&lt;LL&gt;,greater&lt;LL&gt; &gt; Right;\n\tpriority_queue&lt;LL,vector&lt;LL&gt;,less&lt;LL&gt; &gt; Left;\n\tLL n,mid=0;\n\n\tint main()\n\t&#123;\n\t\tcin&gt;&gt;n;//读入n并进行n次插入\n\t\tfor(LL i=1,x;i&lt;=n;i++)&#123;\n\t\t\tcin&gt;&gt;x;\n\t\t\tif(i==1)&#123;//i=1的情况边界易出错，所以做一个特判\n\t\t\t\tmid=x;\n\t\t\t\tcout&lt;&lt;mid&lt;&lt;&quot;\\n&quot;;\n\t\t\t\tcontinue;\n\t\t\t&#125;\n\t\t\tif(x&lt;=mid) Left.push(x);\n\t\t\telse if(x&gt;mid) Right.push(x);\n\t\t\tif(i&amp;1)&#123;//当插入次数为奇数时进行一次平衡和查询\n                //定义左右队列的大小\n\t\t\t\tLL llen=Left.size(),rlen=Right.size();\n\t\t\t\tif(llen&lt;rlen)&#123;//如果左队列个数比右队列个数少\n\t\t\t\t\tLeft.push(mid);//将中位数进行转移\n\t\t\t\t\tLL cha=(rlen-llen)/2;//计算转移数量\n\t\t\t\t\tfor(int j=1;i&lt;cha;j++)&#123;//循环进行转移\n\t\t\t\t\t\tLL tmp=Right.top();\n\t\t\t\t\t\tLeft.push(tmp);\n\t\t\t\t\t\tRight.pop();\n\t\t\t\t\t&#125;\n\t\t\t\t\tmid=Right.top();//更新中位数\n\t\t\t\t\tRight.pop();\n\t\t\t\t&#125;\n\t\t\t\telse if(llen&gt;rlen)&#123;//如果右队列个数比左队列个数少\n\t\t\t\t\tRight.push(mid);//将中位数进行转移\n\t\t\t\t\tLL cha=(llen-rlen)/2;//计算转移数量\n\t\t\t\t\tfor(int j=1;i&lt;cha;j++)&#123;//循环进行转移\n\t\t\t\t\t\tLL tmp=Left.top();\n\t\t\t\t\t\tRight.push(tmp);\n\t\t\t\t\t\tLeft.pop();\n\t\t\t\t\t&#125;\n\t\t\t\t\tmid=Left.top();//更新中位数\n\t\t\t\t\tLeft.pop();\n\t\t\t\t&#125;\n\t\t\t\tcout&lt;&lt;mid&lt;&lt;&quot;\\n&quot;;//操作完成后输出中位数\n\t\t\t&#125;\n\t\t\telse continue;//插入次数为偶数次时直接跳过平衡过程\n\t\t&#125;\n\t\treturn 0;\n\t&#125;\n&#125;\n\nint main()&#123;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\treturn SHAWN::main();\n&#125;\n</code></pre>\n<p>以上，如果有不对的地方，还请各位大佬指正！</p>\n",
            "tags": [
                "对顶堆;数据结构"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/P1438%20%E6%97%A0%E8%81%8A%E7%9A%84%E6%95%B0%E5%88%97/",
            "url": "http://example.com/2023/08/18/P1438%20%E6%97%A0%E8%81%8A%E7%9A%84%E6%95%B0%E5%88%97/",
            "title": "题解 洛谷 P1438 无聊的数列",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>P1438 无聊的数列</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个序列 $a$，要求进行两种操作。</p>\n<ul>\n<li>对于区间 $[l,r]$ 对应加上一个长为 $r - l +1$，首项为 $K$，公差为 $D$ 的等差数列；</li>\n<li>查询第 $p$ 个数的值。</li>\n</ul>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>题目要求将一段等差数列加到一段区间上去。我们一眼丁真想到了线段树，但是对于加的不是同一个值的情况，朴素的做法只能进行单点修改，如果这样单点改下去再单点查，和直接在数组上模拟没有任何区别，我们写线段树不光要多递归几层还很废空间。</p>\n<p>遇到这种一眼就是线段树却不知道如何维护的题，我们就需要重新再回去审题来寻找操作的<strong>特殊性质</strong>。我们发现这道题的特殊性质就是等差数列。那么等差数列有什么性质呢？<s>等差数列等差</s>。虽然说这是一句废话，但是却恰恰揭示了这道题的关键，<strong>等差数列的差分序列中的值除了开头结尾以外完全相同</strong>。我们发现，对于一个从 $l$ 位置开始到 $r$ 位置结束的公差为 $d$ 的等差数列的差分序列有如下性质：</p>\n<ul>\n<li>对于位置 $l$ ，它的值一定等于等差数列的首项；</li>\n<li>对于位置区间 $[l + 1, r]$ 内的每个位置，它的值一定等于公差 $d$；</li>\n<li>对于位置 $r + 1$，它的值一定等于等差数列的末项。</li>\n</ul>\n<p>有了这三个性质后，我们就可以把题目变成对原序列的差分序列进行一次区间加和两次单点修改，时间复杂度就大大缩减了。而单点求值其实就是求差分序列的前缀和，这样我们就可以做了，但是有如下细节需要注意：</p>\n<ul>\n<li>由于差分序列要修改 $r + 1$ 位置，所以不难发现我们建树的区间不是 $[1,n]$ 而是 $[1, n + 1]$；</li>\n<li>题目给的数据范围很有迷惑性，容易给人造成不用开 <code>long long</code> 的假象，然而如果不开就会 <code>WA on 1st</code>；</li>\n<li>题目给的修改区间存在数据使得 $l=r$，此时我们 <code>update(1, l + 1, r, d);</code> 这句就会 RE，需要特判。</li>\n</ul>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define LL long long\n#define ls ro &lt;&lt; 1\n#define rs ro &lt;&lt; 1 | 1\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e5 + 7;\n    struct tree &#123; int l, r; LL sum, tag; &#125;tree[N &lt;&lt; 2];\n    int n, m;\n    LL a[N];\n    void pushup(int ro) &#123; tree[ro].sum = tree[ls].sum + tree[rs].sum; &#125;\n    void build(int ro, int l, int r) &#123;\n        tree[ro].l = l; tree[ro].r = r;\n        tree[ro].tag = 0;\n        if (l &gt;= r) &#123;\n            tree[ro].sum = a[l] - a[l - 1];\n            return;\n        &#125;\n        int mid = l + ((r - l) &gt;&gt; 1);\n        build(ls, l, mid); build(rs, mid + 1, r);\n        pushup(ro);\n    &#125;\n    void pushdown(int ro) &#123;\n        if (tree[ro].tag) &#123;\n            tree[ls].sum += (tree[ls].r - tree[ls].l + 1) * tree[ro].tag;\n            tree[rs].sum += (tree[rs].r - tree[rs].l + 1) * tree[ro].tag;\n            tree[ls].tag += tree[ro].tag;\n            tree[rs].tag += tree[ro].tag;\n            tree[ro].tag = 0;\n        &#125;\n    &#125;\n    void update(int ro, int l, int r, LL x) &#123;\n        int lt = tree[ro].l, rt = tree[ro].r;\n        if (l &lt;= lt &amp;&amp; r &gt;= rt) &#123;\n            tree[ro].sum += (rt - lt + 1) * x;\n            tree[ro].tag += x;\n            return;\n        &#125;\n        pushdown(ro);\n        int mid = lt + ((rt - lt) &gt;&gt; 1);\n        if (l &lt;= mid) &#123; update(ls, l, r, x); &#125;\n        if (r &gt; mid) &#123; update(rs, l, r, x); &#125;\n        pushup(ro);\n    &#125;\n    LL getsum(int ro, int l, int r) &#123;\n        int lt = tree[ro].l, rt = tree[ro].r;\n        if (l &lt;= lt &amp;&amp; r &gt;= rt) &#123; return tree[ro].sum; &#125;\n        pushdown(ro);\n        int mid = lt + ((rt - lt) &gt;&gt; 1); LL res = 0;\n        if (l &lt;= mid) &#123; res += getsum(ls, l, r); &#125;\n        if (r &gt; mid) &#123; res += getsum(rs, l, r); &#125;\n        return res;\n    &#125;\n    signed work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125;\n        build(1, 1, n + 1);\n        while (m--) &#123;\n            int opt; cin &gt;&gt; opt;\n            if (opt == 1) &#123; \n                int l, r; LL k, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k &gt;&gt; d;\n                if (l != r) &#123;\n                    update(1, l, l, k);\n                    update(1, l + 1, r, d);\n                    update(1, r + 1, r + 1, -((r - l) * d + k));\n                &#125;\n                else &#123; \n                    update(1, l, l, k); \n                    update(1, r + 1, r + 1, -k);\n                &#125;\n            &#125;\n            else if (opt == 2) &#123;\n                int p; cin &gt;&gt; p;\n                cout &lt;&lt; getsum(1, 1, p) &lt;&lt; '\\n';\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "线段树;数据结构"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/UVA11149%20Power%20of%20Matrix/",
            "url": "http://example.com/2023/08/18/UVA11149%20Power%20of%20Matrix/",
            "title": "题解 UVA11149 Power of Matrix",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>题解 UVA11149 Power of Matrix</h1>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>给定一个 $n \\times n$ 的矩阵 $A$ 和一个数 $k$，求 $\\sum_{i = 1}^{k}A^i $。</p>\n<h3 id=\"法一：暴力求解，单次时间复杂度-O-n-3k\">法一：暴力求解，单次时间复杂度 $O(n^3k)$</h3>\n<h3 id=\"法二：分治，单次时间复杂度-O-n-3log-2k\">法二：分治，单次时间复杂度 $O(n^3log^2k)$</h3>\n<p>我们可以按照分治的定义照猫画虎，将原式变成这样：</p>\n$$\\displaylines{A+A^2+A^3+A^4+\\ldots+A^K = (A+A^2+A^3+\\ldots+A^{\\frac{k}{2}})+A^{\\frac{k}{2}}(A+A^2+A^3+\\ldots+A^{\\frac{k}{2}})\n}$$<p>然后递归处理即可，分治部分的代码大概长这样：</p>\n<pre><code class=\"language-cpp\">mat solve(mat bas, LL pos) &#123; \\\\bas是原矩阵，pos代表当前k的大小\n    if (pos == 1) &#123; return bas; &#125;\n    mat s; clear(s);\n    for (int i = 0; i &lt; n; ++i) &#123; s.m[i][i] = 1; &#125;\n    s = (s + qpow(bas, pos &gt;&gt; 1)) * solve(bas, pos &gt;&gt; 1);\n    if (pos &amp; 1) &#123; s = s + qpow(bas, pos); &#125;\n    return s;\n&#125;\n</code></pre>\n<p>于是我们惊喜的发现，这种做法又慢又不稳定，所以我们考虑法三。</p>\n<h3 id=\"法三：倍增，单次时间复杂度-O-n-3logk\">法三：倍增，单次时间复杂度 $O(n^3logk)$</h3>\n<p>我们观察要求的这个式子，发现 $i$ 要枚举到 $k$ 非常慢，那么我们就想办法优化这个枚举的过程，也就是对 $i$ 进行倍增，则有：</p>\n$$\\displaylines{\\sum_{i=0}^{log_2k} A^{2^i}(\\sum_{j=1}^{2^i} A^j)\n}$$<p>我们显然不能每次都从头到尾加一遍，所以我们用两个数组 $f$ 和 $s$对这个式子进行递推。</p>\n$$\\displaylines{f_i=A^{2^i},s_i=\\sum_{j=1}^{2^i}A^j\n}$$<p>不难发现在递推 $f_i$ 时只要每次把 $f_{i-1}$ 平方就可以了，而 $s_i$ 略微复杂一些，求它其实很像刚刚分治的做法，即 $s_i=s_{i-1}+f_{i-1} \\times s_{i-1}$。</p>\n<p>如果题目高速我们 $k$ 保证是 2 的若干次幂，那么这个题已经做完了，但很遗憾我们没有这个条件，所以还要想办法处理剩余的部分。<strong>本过程较为复杂，建议多看几遍。</strong> 我们知道整数的一个重要性质就是可以将其拆解为若干 2 的幂之和，假设我们的 $i$ 最后枚举到了 $m$ 使得 $2^m &gt; k$ 且 $2^{m-1} &lt; k$，那么此时我们就想要拆解 $k-2^{m-1}$ 这一部分，那么显然我们最简单的方法是从 $m-1$ 开始向下枚举，设循环变量为 $i$，当枚举到一个 $i$ 使得 $2^{m-1}+2^i&lt;k$ 的时候，就从刚刚处理出来的两个数组中取出第 $i$ 项加到答案里就可以了。这样枚举到 $s^{m-1}+2^i=k$ 时说明我们已经完成对答案的处理，输出答案就可以了。</p>\n<p>下面是参考代码（倍增过程在 $\\operatorname{solve}$ 函数部分）：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#define clear(q) memset(q.m, 0, sizeof(q.m))\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    LL n, k;\n    const int N = 41, M = 64, mod = 10;\n    struct mat &#123; LL m[N][N]; &#125;;\n    mat f[M], s[M];\n    mat operator* (const mat &amp;x, const mat &amp;y) &#123;\n        mat ans;\n        clear(ans);\n        for (int i = 0; i &lt; n; ++i) &#123;\n            for (int k = 0; k &lt; n; ++k) &#123;\n                if (x.m[i][k]) &#123;\n                    for (int j = 0; j &lt; n; ++j) &#123;\n                        ans.m[i][j] = (ans.m[i][j] % mod + (x.m[i][k] * y.m[k][j]) % mod) % mod;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n    mat operator+ (const mat &amp;x, const mat &amp;y) &#123;\n        mat ans;\n        clear(ans);\n        for (int i = 0; i &lt; n; ++i) &#123;\n            for (int j = 0; j &lt; n; ++j) &#123;\n                ans.m[i][j] = (x.m[i][j] + y.m[i][j]) % mod;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n    mat qpow(mat a, LL b) &#123;\n        mat z;\n        clear(z);\n        for (int i = 0; i &lt; n; ++i) &#123; z.m[i][i] = 1; &#125;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            if (b &amp; 1) &#123; z = z * a; &#125;\n            a = a * a; b &gt;&gt;= 1;\n        &#125;\n        return z;\n    &#125;\n    void output(mat o) &#123;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            for (int j = 0; j &lt; n; ++j) &#123;\n                cout &lt;&lt; o.m[i][j] % mod;\n                if (j != n - 1) &#123; cout &lt;&lt; ' '; &#125;\n            &#125;\n            cout &lt;&lt; '\\n'; \n        &#125; \n        cout &lt;&lt; '\\n';\n    &#125;\n    void solve() &#123;\n        LL pos = 2, p = 1; // pos用来枚举2的次幂，p用来枚举2的幂次，pos的指数即为p，二者同加同减\n        while (pos &lt;= k) &#123;\n            f[p] = f[p - 1] * f[p - 1];\n            s[p] = s[p - 1] + s[p - 1] * f[p - 1];\n            pos &lt;&lt;= 1; ++p;\n        &#125;\n        pos &gt;&gt;= 1; --p; // 第一次枚举完后肯定会超出k的范围，所以取上一次枚举到的幂\n        LL posback = pos; // posback表示拆分剩余的数时需要用到的2的次幂\n        mat po = f[p], ans = s[p]; // po表示当前已经枚举到的幂次，ans为答案，初始值为第一次枚举时枚举到最大的值\n        for (int i = p; i &gt;= 0; --i) &#123;\n            if (pos + posback &lt;= k) &#123; \n                ans = ans + po * s[i]; // 加到答案里\n                posback += pos;\n                po = po * f[i];\n            &#125;\n            pos &gt;&gt;= 1; // pos的幂次要和p同步减一\n        &#125;\n        output(ans); // 处理完输出\n    &#125;\n    int work()\n    &#123;\n        while (cin &gt;&gt; n &gt;&gt; k &amp;&amp; n &amp;&amp; k) &#123;\n            for (int i = 0; i &lt; n; ++i) &#123;\n                for (int j = 0; j &lt; n; ++j) &#123;\n                    cin &gt;&gt; s[0].m[i][j];\n                    f[0].m[i][j] = s[0].m[i][j] = s[0].m[i][j] % mod; \n                &#125;\n            &#125;\n            solve();\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n<p><strong>ps. 特别提醒，UVa要注意输入和输出格式</strong></p>\n",
            "tags": [
                "矩阵乘法;倍增"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/U334987%20%E8%90%A5%E6%95%91%E5%8D%83%E6%B3%B7%E3%81%AE%E5%B0%8F%E7%BF%BC%E9%BE%99/",
            "url": "http://example.com/2023/08/18/U334987%20%E8%90%A5%E6%95%91%E5%8D%83%E6%B3%B7%E3%81%AE%E5%B0%8F%E7%BF%BC%E9%BE%99/",
            "title": "题解 洛谷 U334987 营救千泷の小翼龙",
            "date_published": "2023-08-18T09:05:00.000Z",
            "content_html": "<h1>U334987 营救千泷の小翼龙</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给你一个数 $n$ 和 $v$，求 $v \\times \\sum_{i=1}^n i^3 \\bmod 998244353$。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>本题是一道纯纯诈骗题，我们打表或者运用数学归纳法都可以得到如下结论：</p>\n$$\\displaylines{\\sum_{i=1}^n i^3 = (\\sum_{i=1}^ni)^2 = (\\frac{n + n^2}{2})\n}$$<p>于是我们就可以直接带进去 $O(1)$ 算了，于是我们做完了，写代码时请注意取模。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int mod = 998244353;\n    LL n, v, ans;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; v;\n        n %= mod; v %= mod;\n        ans = (1 + n) * n / 2 % mod;\n        ans = ((ans * ans) % mod * v) % mod;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "数学"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/U327217%20%E5%AF%BB%E6%89%BE%E5%8D%83%E6%B3%B7%E3%81%AE%E5%B0%8F%E7%BF%BC%E9%BE%99/",
            "url": "http://example.com/2023/08/18/U327217%20%E5%AF%BB%E6%89%BE%E5%8D%83%E6%B3%B7%E3%81%AE%E5%B0%8F%E7%BF%BC%E9%BE%99/",
            "title": "题解 洛谷 U327217 寻找千泷の小翼龙",
            "date_published": "2023-08-18T09:04:00.000Z",
            "content_html": "<h1>题解 洛谷 U327217 寻找千泷の小翼龙</h1>\n<p><a href=\"https://www.luogu.com.cn/problem/U327217\">本题题面</a></p>\n<h4 id=\"原题（本题由该题数据加强而来）：\">原题（本题由该题数据加强而来）：</h4>\n<h3 id=\"USACO-Training-6-1-1-Postal-Vans\">USACO Training 6.1.1 Postal Vans</h3>\n<p>Tiring of their idyllic fields, the cows have moved to a new suburb. The suburb is a rectangular grid of streets with a post office at its Northwest corner. It has four avenues running East-West and $n(1\\le n\\le 10^{18})$ streets running North-South.</p>\n<p>For example, the following diagram shows such a suburb with $n=5$ streets, with the avenues depicted as horizontal lines, and the post office as a dark blob at the top-left corner:</p>\n<p><img src=\"https://img1.imgtp.com/2023/08/14/HuR5aj47.png\" alt=\"\"></p>\n<p>Each day the postal van leaves the post office, drives around the suburb and returns to the post office, passing exactly once through every intersection (including those on borders or corners). The executives from the post company want to know how many distinct routes can be established for the postal van (of course, the route direction is significant in this count).</p>\n<p>For example, the following diagrams show two such routes for the above suburb:</p>\n<p><img src=\"https://img1.imgtp.com/2023/08/14/cqJ1rEzT.png\" alt=\"\"></p>\n<p>As another example, the following diagrams show all the four possible routes for a suburb with $n=3$ streets:</p>\n<p><img src=\"https://img1.imgtp.com/2023/08/14/tUwsNA4a.png\" alt=\"\"></p>\n<p>Write a program that will determine the number of such distinct routes given the number of streets.</p>\n<p>INPUT FORMAT</p>\n<p>Line 1: Two integers, n, p</p>\n<p>SAMPLE INPUT：</p>\n<pre><code>4 32767\n</code></pre>\n<p>OUTPUT FORMAT</p>\n<p>Line 1: A single integer that tells how many possible distinct routes corresponding to the number of streets given in the input, mod p;</p>\n<p>SAMPLE OUTPUT:</p>\n<pre><code>12\n</code></pre>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>给定一个$4\\times n$的格子（按照格点计数），从左上角出发沿格子遍历所有格点后再返回起点，要求每个点只遍历一次，计算合法方案的总数 $mod$ $p$ 的值</p>\n<h4 id=\"策略分析：\">策略分析：</h4>\n<p>看到方案数，我们合理地想到了动态规划，而看到数据范围和动态规划，我们合理地想到了矩阵加速。设 $f_i$ 为前 $i$ 列中第 $i$ 列中总的方案数。大家小时候应该都玩过拼管子吧，就那种各种各样形状的管子可以组合成不同的形状，那么本题就是要用类似的方法。</p>\n<p>到达南北方向 $1,2$ 路口的方案只有 $2$ 种，我们将管子如下摆放：</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/eu2m5la4.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/0c03xatj.png\" alt=\"\"></p>\n<p>到达南北方向 $1,4$ 路口方案有 $7$ 种，但最后两种等价算作一种：</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/ien5q644.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/zdtegbg0.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/w7t6gcu7.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/8i80emnk.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/qu3xspnd.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/2e98lwsj.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/r44dhsqm.png\" alt=\"\"><br>\n<img src=\"https://cdn.luogu.com.cn/upload/image_hosting/cidfxurb.png\" alt=\"\"></p>\n<p>由此我们可以推出状态转移方程，即：</p>\n$$\\displaylines{f_i=2f_{i-1}+2f_{i-2}-2f_{i-3}+f_{i-4}\n}$$<p>对于这种方法和递推方程正确性的证明参见<a href=\"http://blog.csdn.net/jiangshibiao/article/details/21446033\">阿蒋大佬的blog</a></p>\n<p>得到了状态转移方程我们就可以得到转移矩阵 $M$ 了,</p>\n$$\\displaylines{M=\\begin{vmatrix}\n  2&amp;  2&amp;  -2&amp; 1\\\\\n  1&amp;  0&amp;  0&amp; 0\\\\\n  0&amp;  1&amp;  0&amp; 0\\\\\n  0&amp;  0&amp;  1&amp; 0\n\\end{vmatrix}}$$<p>我们充分发扬人类智慧，通过大脑和手求得 $f_1=0,f_2=2,f_3=4,f_4=12$</p>\n<p>剩余部分显然没有难度了，直接矩阵加速就可以了，于是我们做完了，下面是 $AC$ 代码</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#define clear(q) memset(q.m, 0, sizeof(q.m))\n#define LL long long\nusing namespace std;\n\nnamespace SHAWN &#123;\n    LL n, p;\n    struct mat &#123; LL m[4][4]; &#125;;\n    mat operator* (const mat &amp;x, const mat &amp;y) &#123;\n        mat ans;\n        clear(ans);\n        for (int i = 0; i &lt; 4; ++i) &#123;\n            for (int k = 0; k &lt; 4; ++k) &#123;\n                if (x.m[i][k]) &#123;\n                    for (int j = 0; j &lt; 4; ++j) &#123;\n                        ans.m[i][j] = ((ans.m[i][j] + (x.m[i][k] * y.m[k][j])) % p + p) % p; \n                    &#125;\n                &#125;\n            &#125;\n        &#125; \n        return ans;\n    &#125;\n    mat qpow(mat a, LL b) &#123;\n        mat z;\n        clear(z);\n        for (int i = 0; i &lt; 4; ++i) &#123; z.m[i][i] = 1; &#125;\n        while (b) &#123;\n            if (b &amp; 1) &#123; z = z * a; &#125;\n            a = a * a; b &gt;&gt;= 1;\n        &#125;\n        return z;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; p;\n        if (n &lt;= 4) &#123;\n            switch (n) &#123;\n                case 1 : cout &lt;&lt; &quot;0\\n&quot;; break;\n                case 2 : cout &lt;&lt; &quot;2\\n&quot;; break;\n                case 3 : cout &lt;&lt; &quot;4\\n&quot;; break;\n                case 4 : cout &lt;&lt; &quot;12\\n&quot;; break;\n                default : break;\n            &#125;\n            return 0;\n        &#125;\n        mat a;\n        clear(a);\n        a.m[0][0] = 2; a.m[0][1] = 2; a.m[0][2] = -2; a.m[0][3] = 1;\n        a.m[1][0] = 1; a.m[2][1] = 1; a.m[3][2] = 1;\n        mat z = qpow(a, n - 4);\n        LL ans = ((z.m[0][0] * 12 + z.m[0][1] * 4 + z.m[0][2] * 2) % p + p) % p;\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "矩阵加速;动态规划"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/AT_arc132_a%20Permutation%20Grid/",
            "url": "http://example.com/2023/08/18/AT_arc132_a%20Permutation%20Grid/",
            "title": "题解 AT_arc132_a Permutation Grid",
            "date_published": "2023-08-18T09:03:00.000Z",
            "content_html": "<h1>题解  AT_arc132_a Permutation Grid</h1>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>给定两个数列 $R$ 和 $C$ ，$R$ 和 $C$ 内均有 $n$ 个元素，要求根据 $R$ 和 $C$ 对一个 $n\\times n$ 的矩阵进行染色，使得第 $i$ 行有 $R_i$ 个黑色块，第 $j$ 列有 $C_j$ 个黑色块。<strong>最后，$R$ 和 $C$ 均为 $1-n$ 的一个排列。</strong></p>\n<h4 id=\"反思分析：\"><s>反思</s>分析：</h4>\n<p><s>有个伸臂和一个神犇在赛时没有看到最后一个条件导致两个人想出了各种各样复杂又奇葩的做法，我不说是谁</s></p>\n<p>有了排列那这不成水题了，我们以样例为例（这什么话）把它按顺序重新排列一下，就会变成这样（我们用$W$表示白色，$B$表示黑色）：</p>\n<p>$R=5,2,3,4,1\\Rightarrow R=1,2,3,4,5$</p>\n<p>$C=4,2,3,1,5\\Rightarrow C=1,2,3,4,5$</p>\n<p>$\n\\begin{matrix}\n   &amp; 1&amp;  2&amp;  3&amp;  4&amp; 5&amp;\\\\\n  1&amp;  W&amp;  W&amp;  W&amp;  W&amp; B\\\\\n  2&amp;  W&amp;  W&amp;  W&amp;  B&amp; B\\\\\n  3&amp;  W&amp;  W&amp;  B&amp;  B&amp; B\\\\\n  4&amp;  W&amp;  B&amp;  B&amp;  B&amp; B\\\\\n  5&amp;  B&amp;  B&amp;  B&amp;  B&amp; B\n\\end{matrix}\n$</p>\n<p>我们稍加观察，然后<strong>惊奇地</strong>发现，坐标为$x,y$的块是黑色当且仅当$R_x+C_y&gt;n$，然后我们恢复原序列<br>\n$\n\\begin{matrix}\n   &amp; 4&amp;  2&amp;  3&amp;  1&amp; 5&amp;\\\\\n  5&amp;  B&amp;  B&amp;  B&amp;  B&amp; B\\\\\n  2&amp;  B&amp;  W&amp;  W&amp;  W&amp; B\\\\\n  3&amp;  B&amp;  W&amp;  B&amp;  W&amp; B\\\\\n  4&amp;  B&amp;  B&amp;  B&amp;  W&amp; B\\\\\n  1&amp;  W&amp;  W&amp;  W&amp;  W&amp; B\n\\end{matrix}\n$<br>\n发现这个性质仍然存在！</p>\n<p>我们可以通过简单地平移来证明这种做法的正确性，而代码也就相应的非常好写了：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e5 + 7;\n    int r[N],c[N];\n    int n, q;\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; r[i]; &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; c[i]; &#125;\n        cin &gt;&gt; q;\n        for (int i = 1, x, y; i &lt;= q; ++i) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            if (r[x] + c[y] &gt; n) &#123; cout &lt;&lt; '#'; &#125;\n            else &#123; cout &lt;&lt; '.'; &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/P1045%20[NOIP2003%20%E6%99%AE%E5%8F%8A%E7%BB%84]%20%E9%BA%A6%E6%A3%AE%E6%95%B0/",
            "url": "http://example.com/2023/08/18/P1045%20[NOIP2003%20%E6%99%AE%E5%8F%8A%E7%BB%84]%20%E9%BA%A6%E6%A3%AE%E6%95%B0/",
            "title": "题解 洛谷 P1045 [NOIP2003 普及组] 麦森数",
            "date_published": "2023-08-18T09:00:00.000Z",
            "content_html": "<h1>题解 洛谷 P1045 [NOIP2003 普及组] 麦森数</h1>\n<h3 id=\"简要题意：\">简要题意：</h3>\n<p>给定一个数$p$，求$2^p$-1的位数和后500位的值，其中$p\\in [1\\times10^3,3.1\\times10^6]$。</p>\n<h2 id=\"策略分析：\">策略分析：</h2>\n<p>我们可以将这个问题分为两步来处理，第一步求出位数，第二步求后$500$位</p>\n<h3 id=\"求出位数：\">求出位数：</h3>\n<p>首先有一个非常平凡的结论：$10^k$的位数为$k+1$。那么一个$10^k$的数的位数也等于$lg10^k$，设$n =2^p$，因为不存在最后一位为$0$的$2^p$的数，所以$2^p-1$的位数一定与$2^p$的位数相同。我们希望能够将$10^k$所具有的性质应用在$2^p$中，设$10^m=2$，那么$lg2=m$，所以$10^{lg2}=2$，所以$n=2^p=(10^{lg2})^p=10^{(lg2)·p}$，那么$n$的位数就等于$10^{(lg2)·p}$的位数，即$(lg2)·p+1$，那这不就简单多了，直接$cmath$库里随便一搞就出来了</p>\n<h3 id=\"求后500位的值：\">求后500位的值：</h3>\n<p>我们发现一个朴素的高精度乘法的时间复杂度是$O(n^2)$，那么就寄了，所以我们要用<strong>超级快速的高精乘法</strong>，C++里什么样的数据类型存的数最大呢？~~（谁刚说__$int128$拉出去枪毙$5$分钟）~~显然我们要用$unsigned$  $long$  $long$来存储这500位，那么我们就要尽量挑战它的极限，一次乘$2^{60}$ <s>（讨厌没有边界感的$ull$）</s>，这样我们就可以在更短的时间内完成计算</p>\n<h3 id=\"AC代码：\">AC代码：</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#define ULL unsigned long long\nusing namespace std;\n\nnamespace Rick &#123; int work() &#123; cout &lt;&lt; &quot;Never gonna give you up, never gonna let you down~\\n&quot;; &#125; &#125;\nnamespace SHAWN &#123;\n    const int N = 507;\n    ULL t[N] = &#123; 1 &#125;;\n    int p;\n    int work()\n    &#123;\n        cin &gt;&gt; p;\n        cout &lt;&lt; (int)(log10(2) * p) + 1 &lt;&lt; '\\n';\n        for (; p &gt; 0; p -= 60) &#123;\n            ULL jin = 0;\n            for (int i = 0; i &lt; 500; ++i) &#123;\n                if (p &gt; 60) &#123; t[i] &lt;&lt;= 60; &#125;\n                else &#123; t[i] &lt;&lt;= p; &#125;\n                t[i] += jin; jin = t[i] / 10; t[i] %= 10;\n            &#125;\n        &#125;\n        t[0] -= 1; \n        // 最开始为了让乘法有值我们设成了1，所以一通操作后要减1\n        for (int i = 499; i &gt;= 0; --i) &#123;\n            cout &lt;&lt; t[i];\n            if (! (i % 50)) &#123; cout &lt;&lt; '\\n'; &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    // return SHAWN :: work();\n    return Rick :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "二进制;高精度"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/BNDSOJ%201575%20%E5%93%88%E5%A4%AB%E6%9B%BC/",
            "url": "http://example.com/2023/08/18/BNDSOJ%201575%20%E5%93%88%E5%A4%AB%E6%9B%BC/",
            "title": "题解 BNDS OJ 1575 哈夫曼",
            "date_published": "2023-08-18T08:57:00.000Z",
            "content_html": "<h1>题解 BNDS OJ 1575 哈夫曼</h1>\n<h4 id=\"前置芝士：\">前置芝士：</h4>\n<p><a href=\"https://oi-wiki.org/ds/huffman-tree/\">哈夫曼树</a></p>\n<h4 id=\"简要题意：\">简要题意：</h4>\n<p>给定一个仅包含小写字母的字符序列，要求输出这个序列的哈夫曼编码</p>\n<h4 id=\"分析-求解：\">分析/求解：</h4>\n<p>哈夫曼建树时要求每次配对权值最小的两个儿子，它们配对所产生的父亲也要重新与其它的树进行比较，所以我们很容易可以想到通过优先队列来维护当前所有的树，具体细节见代码</p>\n<h4 id=\"AC代码：\">AC代码：</h4>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    struct node &#123; int ma,val,fa,l,r,pos; &#125;;\n    // ma,val,fa,l,r,pos分别表示当前节点对应的字母，出现的数量，父节点编号，左右儿子编号，当前节点编号\n    struct cmp&#123;\n        bool operator()(const node&amp;a, const node&amp;b)const&#123;\n            if(a.val != b.val) &#123; return a.val &gt; b.val; &#125;\n            else &#123; return a.ma &gt; b.ma; &#125;\n        &#125;\n    &#125;;// 重载函数调用运算符\n    priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; q; \n    // 用优先队列来维护森林\n    string s;\n    node tree[N];\n    // tree[]维护整棵哈夫曼树\n    vector&lt;int&gt; haff[30];\n    // haff[]维护每个字母对应的哈夫曼编码\n    int used[30];\n    // used[]维护每个字母出现的次数\n    int n, m, idx;\n    void build() &#123;\n        while (q.size() &gt;= 2) &#123; // 森林中还有元素时持续配对\n            node x = q.top(); q.pop();\n            node y = q.top(); q.pop();\n            // 取出堆顶两个元素配对\n            if (!x.pos) &#123; tree[++idx] = x; tree[idx].pos = x.pos = idx; &#125;\n            if (!y.pos) &#123; tree[++idx] = y; tree[idx].pos = y.pos = idx; &#125;\n            // 如果取出的点没有在树中则新建一个树上节点\n            node z = &#123;-1,(x.val+y.val), -1, x.pos, y.pos, ++idx&#125;;\n            tree[x.pos].fa = tree[y.pos].fa = idx;\n            q.push(z); tree[idx] = z;\n            // 建立这两个节点的父亲并扔进森林\n        &#125;\n    &#125;\n    void solve() &#123;\n        for (int i = 1; i &lt;= idx; ++i) &#123;\n            // 遍历树上节点找到最原始的代表单独字符的节点\n            if (tree[i].ma != -1) &#123;\n                int now = i;\n                while (tree[now].fa != -1) &#123;\n                    if (now == tree[tree[now].fa].l) &#123; haff[tree[i].ma].push_back(0); &#125;\n                    else &#123; haff[tree[i].ma].push_back(1); &#125;\n                    now = tree[now].fa;\n                    // 向上搜索找根来获取编码\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= 27; ++i) &#123;\n            if (haff[i].size()) &#123;\n                for(int j = haff[i].size()-1; j &gt;= 0; --j) &#123; cout &lt;&lt; haff[i][j]; &#125;\n                // 由于获取编码时是反向获取的，所以倒序输出\n                cout &lt;&lt; '\\n';\n            &#125;\n        &#125;\n        for (int i = 0; i &lt;= n; ++i) &#123;\n            int a = s[i] - 'a' + 1;\n            for(int j = haff[a].size()-1; j &gt;= 0; --j) &#123; cout &lt;&lt; haff[a][j]; &#125;\n            // 查询并输出整个字符串的哈夫曼编码\n        &#125;\n    &#125;\n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n        for (int i = 0; i &lt; n; ++i) &#123; used[s[i] - 'a' + 1]++; &#125;\n        // 统计每个字母出现的次数\n        for (int i = 1; i &lt;=26; ++i) &#123; \n            if (used[i]) &#123; // 如果存在当前字母\n                q.push(&#123;i,used[i],0,-1,-1,0&#125;); \n                // 将该节点作为一个子树插入森林\n            &#125;\n        &#125;\n        build(); // 建树\n        solve(); // 求霍夫曼编码\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "哈夫曼树;哈夫曼编码"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/CF1413D%20Shurikens/",
            "url": "http://example.com/2023/08/18/CF1413D%20Shurikens/",
            "title": "题解 CF1413D Shurikens",
            "date_published": "2023-08-18T03:15:00.000Z",
            "content_html": "<h1>题解 CF1413D Shurikens</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个 $n$ 和 $2n$ 个操作，第一种操作 “+” 表示从 $1$ ~ $n$ 中选择一个数插入序列，第二种操作 &quot; - $x$&quot; 表示从当前序列中删除 $x$ 且 $x$ 为当前序列里的最小值，根据给出的操作来推断将数插入序列的合法顺序。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<h3 id=\"不合法情况\">不合法情况</h3>\n<p>不合法的情况有两种。第一种是当在连续取出的两个值中，后取出的值比前取出的值小，因为每次必须取出序列里最小的值，所以这种情况显然是不符合要求的。第二种情况是取出的操作数比放入的操作数多，这样显然也是不合法的。</p>\n<h3 id=\"如何处理合法情况\">如何处理合法情况</h3>\n<p>我们看到这种有进有出的结构能够想到什么，怎么才能反转操作呢？我们很自然地想到可以用栈来实现。我们倒着进行操作，遇到取数操作就把取出来的数压入栈 $s$，遇到插入操作就把 $s$ 栈顶元素弹出来塞进另一个栈 $ans$ 里，最后把 $ans$ 里的元素依次弹出就是答案所要的序列了。按照刚刚讨论过的不合法情况，当 $s$ 中入栈元素比栈顶元素大则不合法，如果需要弹出时栈 $s$ 为空则不合法。</p>\n<h3 id=\"正确性证明\">正确性证明</h3>\n<p>因为每次都要取序列中的最小值，所以后出来的元素一定是更大的，我们就默认它插入得更早。而倒序插入的时候保证了小的元素一定后进栈，所以也不会出现弹出一个数时它还没插入的情况。当 $s$ 入栈元素大于栈顶元素，就相当于操作时取出的值不是最小值；而当弹栈时栈空了，就说明插入的数量少于取出的数量，刚好就对应上了上面分析的不合法情况。由此就可以判断出其正确性。</p>\n<h2 id=\"实现\">实现</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    stack&lt;int&gt; s;\n    stack&lt;int&gt; ans;\n    vector&lt;int&gt; opt;// 记录操作\n    int n;\n    int work()\n    &#123;\n        cin &gt;&gt; n;\n        for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n            char op; int x;\n            cin &gt;&gt; op;\n            if (op == '+') &#123; opt.emplace_back(0); &#125;\n            else if(op == '-') &#123; cin &gt;&gt; x; opt.emplace_back(x); &#125;\n        &#125;\n        for (int i = opt.size() - 1; i &gt;= 0; --i) &#123;\n            // 倒着复现操作\n            if (!opt[i]) &#123;\n                if (s.empty()) &#123; cout &lt;&lt; &quot;NO\\n&quot;; return 0; &#125;\n                // 插入的数量少于取出的数量\n                else &#123; ans.push(s.top()); s.pop(); &#125;\n            &#125;\n            else &#123;\n                if (s.size() &amp;&amp; opt[i] &gt; s.top()) &#123; cout &lt;&lt; &quot;NO\\n&quot;; return 0; &#125;\n                // 操作时取出的值不是最小值\n                else &#123; s.push(opt[i]); &#125;\n            &#125;\n        &#125;\n        cout &lt;&lt; &quot;YES\\n&quot;; \n        while (!ans.empty()) &#123; cout &lt;&lt; ans.top() &lt;&lt; ' '; ans.pop(); &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/CF958E1%20Guard%20Duty%20(easy)/",
            "url": "http://example.com/2023/08/18/CF958E1%20Guard%20Duty%20(easy)/",
            "title": "题解 洛谷 CF958E1 Guard Duty (easy)",
            "date_published": "2023-08-18T03:15:00.000Z",
            "content_html": "<h1>题解 CF958E1 Guard Duty (easy)</h1>\n<h2 id=\"这是一道诈骗题\">这是一道诈骗题</h2>\n<h3 id=\"简要题意\">简要题意</h3>\n<p>给你 $n$ 个 $R$ 点和 $m$ 个 $B$ 点，现在给你这些点的坐标，问能否在这两类点间连线来构造出一种情况使得一个线段两边分别是 $R$ 和 $B$。</p>\n<h3 id=\"策略分析\">策略分析</h3>\n<h4 id=\"不合法情况\">不合法情况</h4>\n<p>当 $n\\ne m$ 时，我们顺次连接 $R$ 和 $B$，先不考虑相交不相交，发现连到最后要么 $R$ 和 $R$ 相连，要么 $B$ 和 $B$ 相连，一定不合法。</p>\n<h4 id=\"合法情况\">合法情况</h4>\n<p><strong>当 $n=m$ 时，答案一定合法</strong></p>\n<h5 id=\"正确性证明\">正确性证明</h5>\n<p>我们设有点 $R_1,R_2,B_1,B_2$，那么我们加上边 $(R_1,B_1),(R_2,B_1),(R_1,B_2)$，发现相交了，如下图：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/22/pPJ85D0.jpg\" alt=\"\"></p>\n<p>但我们发现，当这种相交情况出现时，我们只需要改连边 $(R_1,B_1),(R_2,B_1),(R_2,B_2)$，就一定能变成不相交的情况，如下图：</p>\n<p><img src=\"https://s1.ax1x.com/2023/08/22/pPJ84uq.jpg\" alt=\"\"></p>\n<p>于是我们做完了，下面是AC代码</p>\n<h3 id=\"参考代码\">参考代码</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    int n, m;\n    int work()\n    &#123;   \n        cin &gt;&gt; n &gt;&gt; m;\n        n == m ? cout &lt;&lt; &quot;Yes\\n&quot; : cout &lt;&lt; &quot;No\\n&quot;;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "平面几何"
            ]
        },
        {
            "id": "http://example.com/2023/08/18/P3514%20[POI2011]%20LIZ-Lollipop/",
            "url": "http://example.com/2023/08/18/P3514%20[POI2011]%20LIZ-Lollipop/",
            "title": "题解 洛谷 P3514 [POI2011] LIZ-Lollipop",
            "date_published": "2023-08-18T03:15:00.000Z",
            "content_html": "<h1>P3514 [POI2011] LIZ-Lollipop</h1>\n<h2 id=\"简要题意\">简要题意</h2>\n<p>给定一个只有 $1$ 和 $2$ 的序列，给出 $m$ 次询问，每次询问给出一个数 $k$，查询序列中有没有一个子串和为 $k$，如果有则输出区间两端点，如果没有输出 <code>NIE</code>。</p>\n<h2 id=\"策略分析\">策略分析</h2>\n<p>本题最重要的条件就是该序列中只含有 $1$ 和 $2$，因为这个条件，我们就可以得到下面这个性质：<strong>若 $k$ 可以被表示，则 $k-2$ 也一定可以被表示</strong>。这个性质很容易被证明。我们很容易发现，一个区间的两端点有三种情况，全为 $1$，全为 $2$ 以及一边 $1$ 一边 $2$。那么当两边存在 $2$ 时，只需要减掉这个 $2$ 即可；如果是两个 $1$，那么把这两个 $1$ 一起减掉即可。</p>\n<p>现在我们知道了上面这个性质，开始考虑非法情况。既然 $k-2$ 可以被表示，那么我们只需要找到最大的 $k$ 就可以了。如果给出的 $k$ 比我们能找到的最大的数还大，那么这个数是不合法的。</p>\n<p>考虑完非法情况以后，我们来考虑如何求解。我们发现，一个数减去 $2$ 后奇偶性不变，也就是说如果 $k$ 是奇数，那么我们将永远无法得到偶数，反之亦然，所以这要求我们分类讨论，分别求出最大的奇数和最大的偶数。因为题目告诉我们序列长度 $n \\le 10^6$，也就是说能够被表示出来的数最多有 $2 \\times 10^6$ 种。我们可以提前将这些数的左右区间都预处理出来，然后 $O(1)$ 查询即可。处理这些数的方法是将最大的奇数和偶数分别缩减，每次缩减 $2$ 并记下左右区间，按照最开始分析的性质来移动左右指针，知道两指针相遇为止。</p>\n<h2 id=\"参考代码\">参考代码</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nnamespace SHAWN &#123;\n    const int N = 1e6 + 7;\n    int a[N];\n    int n, m, jmax, omax, sum;\n    struct node &#123; int l, r; &#125;b[N &lt;&lt; 1];\n    \n    inline void _init() &#123;\n        int jlidx, jridx, olidx, oridx, tmp1, tmp2, tag1, tag2;\n        jlidx = olidx = 1; jridx = oridx = n; tmp1 = tmp2 = 0;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            tmp1 += a[i];\n            if (a[i] == 1) &#123; tag1 = i + 1; break; &#125;\n        &#125;\n        for (int  i = n; i &gt;= 1; --i) &#123;\n            tmp2 += a[i];\n            if (a[i] == 1) &#123; tag2 = i - 1; break; &#125;\n        &#125;\n        if (sum % 2) &#123;\n            jmax = sum;\n            if (tmp1 &lt; tmp2) &#123;\n                omax = sum - tmp1;\n                olidx = tag1;\n            &#125;\n            else &#123;\n                omax = sum - tmp2;\n                oridx = tag2;\n            &#125;\n        &#125;\n        else &#123;\n            omax = sum;\n            if (tmp1 &lt; tmp2) &#123;\n                jmax = sum - tmp1;\n                jlidx = tag1; \n            &#125;\n            else &#123;\n                jmax = sum - tmp2;\n                jridx = tag2;\n            &#125;\n        &#125;\n        \n        //----以上处理最大的奇数和偶数以及其左右端点----\n        //----以下分别缩减奇偶数得到所有数的左右端点----\n        \n        int otmp = omax, jtmp = jmax;\n        b[omax] = &#123;olidx, oridx&#125;;\n        b[jmax] = &#123;jlidx, jridx&#125;; \n        while (olidx &lt; oridx &amp;&amp; otmp &gt; 0) &#123;\n            otmp -= 2;\n            if (a[olidx] == 1) &#123;\n                if (a[oridx] == 1) &#123; b[otmp] = &#123;++olidx, --oridx&#125;; &#125;\n                else if (a[oridx] == 2) &#123; b[otmp] = &#123;olidx, --oridx&#125;; &#125;\n            &#125;\n            else if (a[olidx] == 2) &#123; b[otmp] = &#123;++olidx, oridx&#125;; &#125;\n        &#125;\n        while (jlidx &lt; jridx &amp;&amp; jtmp &gt; 0) &#123;\n            jtmp -= 2;\n            if (a[jlidx] == 1) &#123;\n                if (a[jridx] == 1) &#123; b[jtmp] = &#123;++jlidx, --jridx&#125;; &#125;\n                else if (a[jridx] == 2) &#123; b[jtmp] = &#123;jlidx, --jridx&#125;; &#125;\n            &#125;\n            else if (a[jlidx] == 2) &#123; b[jtmp] = &#123;++jlidx, jridx&#125;; &#125;\n        &#125;\n        return;\n    &#125;\n    \n    int work()\n    &#123;\n        cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char c; cin &gt;&gt; c;\n            if (c == 'T') &#123; a[i] = 2; &#125;\n            else if (c == 'W') &#123; a[i] = 1; &#125;\n            sum += a[i];\n        &#125;\n        _init();\n        while (m--) &#123;\n            int sar; cin &gt;&gt; sar;\n            if (sar % 2 &amp;&amp; sar &gt; jmax) &#123; cout &lt;&lt; &quot;NIE\\n&quot;; continue; &#125;\n            else if (!(sar % 2) &amp;&amp; sar &gt; omax) &#123; cout &lt;&lt; &quot;NIE\\n&quot;; continue; &#125;\n            cout &lt;&lt; b[sar].l &lt;&lt; ' ' &lt;&lt; b[sar].r &lt;&lt; '\\n';\n        &#125;\n        return 0;\n    &#125;\n&#125;\n\nsigned int main() &#123;\n    ios :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    return SHAWN :: work();\n&#125;\n</code></pre>\n",
            "tags": [
                "构造"
            ]
        }
    ]
}